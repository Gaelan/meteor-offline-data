//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Package-scope variables */
var _, exports;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/pre.js                                                                            //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
// Define an object named exports. This will cause underscore.js to put `_` as a                         // 1
// field on it, instead of in the global namespace.  See also post.js.                                   // 2
exports = {};                                                                                            // 3
                                                                                                         // 4
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/underscore.js                                                                     //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
//     Underscore.js 1.5.1                                                                               // 1
//     http://underscorejs.org                                                                           // 2
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors                // 3
//     Underscore may be freely distributed under the MIT license.                                       // 4
                                                                                                         // 5
(function() {                                                                                            // 6
                                                                                                         // 7
  // Baseline setup                                                                                      // 8
  // --------------                                                                                      // 9
                                                                                                         // 10
  // Establish the root object, `window` in the browser, or `global` on the server.                      // 11
  var root = this;                                                                                       // 12
                                                                                                         // 13
  // Save the previous value of the `_` variable.                                                        // 14
  var previousUnderscore = root._;                                                                       // 15
                                                                                                         // 16
  // Establish the object that gets returned to break out of a loop iteration.                           // 17
  var breaker = {};                                                                                      // 18
                                                                                                         // 19
  // Save bytes in the minified (but not gzipped) version:                                               // 20
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;         // 21
                                                                                                         // 22
  // Create quick reference variables for speed access to core prototypes.                               // 23
  var                                                                                                    // 24
    push             = ArrayProto.push,                                                                  // 25
    slice            = ArrayProto.slice,                                                                 // 26
    concat           = ArrayProto.concat,                                                                // 27
    toString         = ObjProto.toString,                                                                // 28
    hasOwnProperty   = ObjProto.hasOwnProperty;                                                          // 29
                                                                                                         // 30
  // All **ECMAScript 5** native function implementations that we hope to use                            // 31
  // are declared here.                                                                                  // 32
  var                                                                                                    // 33
    nativeForEach      = ArrayProto.forEach,                                                             // 34
    nativeMap          = ArrayProto.map,                                                                 // 35
    nativeReduce       = ArrayProto.reduce,                                                              // 36
    nativeReduceRight  = ArrayProto.reduceRight,                                                         // 37
    nativeFilter       = ArrayProto.filter,                                                              // 38
    nativeEvery        = ArrayProto.every,                                                               // 39
    nativeSome         = ArrayProto.some,                                                                // 40
    nativeIndexOf      = ArrayProto.indexOf,                                                             // 41
    nativeLastIndexOf  = ArrayProto.lastIndexOf,                                                         // 42
    nativeIsArray      = Array.isArray,                                                                  // 43
    nativeKeys         = Object.keys,                                                                    // 44
    nativeBind         = FuncProto.bind;                                                                 // 45
                                                                                                         // 46
  // Create a safe reference to the Underscore object for use below.                                     // 47
  var _ = function(obj) {                                                                                // 48
    if (obj instanceof _) return obj;                                                                    // 49
    if (!(this instanceof _)) return new _(obj);                                                         // 50
    this._wrapped = obj;                                                                                 // 51
  };                                                                                                     // 52
                                                                                                         // 53
  // Export the Underscore object for **Node.js**, with                                                  // 54
  // backwards-compatibility for the old `require()` API. If we're in                                    // 55
  // the browser, add `_` as a global object via a string identifier,                                    // 56
  // for Closure Compiler "advanced" mode.                                                               // 57
  if (typeof exports !== 'undefined') {                                                                  // 58
    if (typeof module !== 'undefined' && module.exports) {                                               // 59
      exports = module.exports = _;                                                                      // 60
    }                                                                                                    // 61
    exports._ = _;                                                                                       // 62
  } else {                                                                                               // 63
    root._ = _;                                                                                          // 64
  }                                                                                                      // 65
                                                                                                         // 66
  // Current version.                                                                                    // 67
  _.VERSION = '1.5.1';                                                                                   // 68
                                                                                                         // 69
  // Collection Functions                                                                                // 70
  // --------------------                                                                                // 71
                                                                                                         // 72
  // The cornerstone, an `each` implementation, aka `forEach`.                                           // 73
  // Handles objects with the built-in `forEach`, arrays, and raw objects.                               // 74
  // Delegates to **ECMAScript 5**'s native `forEach` if available.                                      // 75
  var each = _.each = _.forEach = function(obj, iterator, context) {                                     // 76
    if (obj == null) return;                                                                             // 77
    if (nativeForEach && obj.forEach === nativeForEach) {                                                // 78
      obj.forEach(iterator, context);                                                                    // 79
    } else if (obj.length === +obj.length) {                                                             // 80
      for (var i = 0, l = obj.length; i < l; i++) {                                                      // 81
        if (iterator.call(context, obj[i], i, obj) === breaker) return;                                  // 82
      }                                                                                                  // 83
    } else {                                                                                             // 84
      for (var key in obj) {                                                                             // 85
        if (_.has(obj, key)) {                                                                           // 86
          if (iterator.call(context, obj[key], key, obj) === breaker) return;                            // 87
        }                                                                                                // 88
      }                                                                                                  // 89
    }                                                                                                    // 90
  };                                                                                                     // 91
                                                                                                         // 92
  // Return the results of applying the iterator to each element.                                        // 93
  // Delegates to **ECMAScript 5**'s native `map` if available.                                          // 94
  _.map = _.collect = function(obj, iterator, context) {                                                 // 95
    var results = [];                                                                                    // 96
    if (obj == null) return results;                                                                     // 97
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);                           // 98
    each(obj, function(value, index, list) {                                                             // 99
      results.push(iterator.call(context, value, index, list));                                          // 100
    });                                                                                                  // 101
    return results;                                                                                      // 102
  };                                                                                                     // 103
                                                                                                         // 104
  var reduceError = 'Reduce of empty array with no initial value';                                       // 105
                                                                                                         // 106
  // **Reduce** builds up a single result from a list of values, aka `inject`,                           // 107
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.                           // 108
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {                               // 109
    var initial = arguments.length > 2;                                                                  // 110
    if (obj == null) obj = [];                                                                           // 111
    if (nativeReduce && obj.reduce === nativeReduce) {                                                   // 112
      if (context) iterator = _.bind(iterator, context);                                                 // 113
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);                                // 114
    }                                                                                                    // 115
    each(obj, function(value, index, list) {                                                             // 116
      if (!initial) {                                                                                    // 117
        memo = value;                                                                                    // 118
        initial = true;                                                                                  // 119
      } else {                                                                                           // 120
        memo = iterator.call(context, memo, value, index, list);                                         // 121
      }                                                                                                  // 122
    });                                                                                                  // 123
    if (!initial) throw new TypeError(reduceError);                                                      // 124
    return memo;                                                                                         // 125
  };                                                                                                     // 126
                                                                                                         // 127
  // The right-associative version of reduce, also known as `foldr`.                                     // 128
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.                                  // 129
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {                                     // 130
    var initial = arguments.length > 2;                                                                  // 131
    if (obj == null) obj = [];                                                                           // 132
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {                                    // 133
      if (context) iterator = _.bind(iterator, context);                                                 // 134
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);                      // 135
    }                                                                                                    // 136
    var length = obj.length;                                                                             // 137
    if (length !== +length) {                                                                            // 138
      var keys = _.keys(obj);                                                                            // 139
      length = keys.length;                                                                              // 140
    }                                                                                                    // 141
    each(obj, function(value, index, list) {                                                             // 142
      index = keys ? keys[--length] : --length;                                                          // 143
      if (!initial) {                                                                                    // 144
        memo = obj[index];                                                                               // 145
        initial = true;                                                                                  // 146
      } else {                                                                                           // 147
        memo = iterator.call(context, memo, obj[index], index, list);                                    // 148
      }                                                                                                  // 149
    });                                                                                                  // 150
    if (!initial) throw new TypeError(reduceError);                                                      // 151
    return memo;                                                                                         // 152
  };                                                                                                     // 153
                                                                                                         // 154
  // Return the first value which passes a truth test. Aliased as `detect`.                              // 155
  _.find = _.detect = function(obj, iterator, context) {                                                 // 156
    var result;                                                                                          // 157
    any(obj, function(value, index, list) {                                                              // 158
      if (iterator.call(context, value, index, list)) {                                                  // 159
        result = value;                                                                                  // 160
        return true;                                                                                     // 161
      }                                                                                                  // 162
    });                                                                                                  // 163
    return result;                                                                                       // 164
  };                                                                                                     // 165
                                                                                                         // 166
  // Return all the elements that pass a truth test.                                                     // 167
  // Delegates to **ECMAScript 5**'s native `filter` if available.                                       // 168
  // Aliased as `select`.                                                                                // 169
  _.filter = _.select = function(obj, iterator, context) {                                               // 170
    var results = [];                                                                                    // 171
    if (obj == null) return results;                                                                     // 172
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);               // 173
    each(obj, function(value, index, list) {                                                             // 174
      if (iterator.call(context, value, index, list)) results.push(value);                               // 175
    });                                                                                                  // 176
    return results;                                                                                      // 177
  };                                                                                                     // 178
                                                                                                         // 179
  // Return all the elements for which a truth test fails.                                               // 180
  _.reject = function(obj, iterator, context) {                                                          // 181
    return _.filter(obj, function(value, index, list) {                                                  // 182
      return !iterator.call(context, value, index, list);                                                // 183
    }, context);                                                                                         // 184
  };                                                                                                     // 185
                                                                                                         // 186
  // Determine whether all of the elements match a truth test.                                           // 187
  // Delegates to **ECMAScript 5**'s native `every` if available.                                        // 188
  // Aliased as `all`.                                                                                   // 189
  _.every = _.all = function(obj, iterator, context) {                                                   // 190
    iterator || (iterator = _.identity);                                                                 // 191
    var result = true;                                                                                   // 192
    if (obj == null) return result;                                                                      // 193
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);                   // 194
    each(obj, function(value, index, list) {                                                             // 195
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;              // 196
    });                                                                                                  // 197
    return !!result;                                                                                     // 198
  };                                                                                                     // 199
                                                                                                         // 200
  // Determine if at least one element in the object matches a truth test.                               // 201
  // Delegates to **ECMAScript 5**'s native `some` if available.                                         // 202
  // Aliased as `any`.                                                                                   // 203
  var any = _.some = _.any = function(obj, iterator, context) {                                          // 204
    iterator || (iterator = _.identity);                                                                 // 205
    var result = false;                                                                                  // 206
    if (obj == null) return result;                                                                      // 207
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);                       // 208
    each(obj, function(value, index, list) {                                                             // 209
      if (result || (result = iterator.call(context, value, index, list))) return breaker;               // 210
    });                                                                                                  // 211
    return !!result;                                                                                     // 212
  };                                                                                                     // 213
                                                                                                         // 214
  // Determine if the array or object contains a given value (using `===`).                              // 215
  // Aliased as `include`.                                                                               // 216
  _.contains = _.include = function(obj, target) {                                                       // 217
    if (obj == null) return false;                                                                       // 218
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;                // 219
    return any(obj, function(value) {                                                                    // 220
      return value === target;                                                                           // 221
    });                                                                                                  // 222
  };                                                                                                     // 223
                                                                                                         // 224
  // Invoke a method (with arguments) on every item in a collection.                                     // 225
  _.invoke = function(obj, method) {                                                                     // 226
    var args = slice.call(arguments, 2);                                                                 // 227
    var isFunc = _.isFunction(method);                                                                   // 228
    return _.map(obj, function(value) {                                                                  // 229
      return (isFunc ? method : value[method]).apply(value, args);                                       // 230
    });                                                                                                  // 231
  };                                                                                                     // 232
                                                                                                         // 233
  // Convenience version of a common use case of `map`: fetching a property.                             // 234
  _.pluck = function(obj, key) {                                                                         // 235
    return _.map(obj, function(value){ return value[key]; });                                            // 236
  };                                                                                                     // 237
                                                                                                         // 238
  // Convenience version of a common use case of `filter`: selecting only objects                        // 239
  // containing specific `key:value` pairs.                                                              // 240
  _.where = function(obj, attrs, first) {                                                                // 241
    if (_.isEmpty(attrs)) return first ? void 0 : [];                                                    // 242
    return _[first ? 'find' : 'filter'](obj, function(value) {                                           // 243
      for (var key in attrs) {                                                                           // 244
        if (attrs[key] !== value[key]) return false;                                                     // 245
      }                                                                                                  // 246
      return true;                                                                                       // 247
    });                                                                                                  // 248
  };                                                                                                     // 249
                                                                                                         // 250
  // Convenience version of a common use case of `find`: getting the first object                        // 251
  // containing specific `key:value` pairs.                                                              // 252
  _.findWhere = function(obj, attrs) {                                                                   // 253
    return _.where(obj, attrs, true);                                                                    // 254
  };                                                                                                     // 255
                                                                                                         // 256
  // Return the maximum element or (element-based computation).                                          // 257
  // Can't optimize arrays of integers longer than 65,535 elements.                                      // 258
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)                               // 259
  _.max = function(obj, iterator, context) {                                                             // 260
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 261
      return Math.max.apply(Math, obj);                                                                  // 262
    }                                                                                                    // 263
    if (!iterator && _.isEmpty(obj)) return -Infinity;                                                   // 264
    var result = {computed : -Infinity, value: -Infinity};                                               // 265
    each(obj, function(value, index, list) {                                                             // 266
      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 267
      computed > result.computed && (result = {value : value, computed : computed});                     // 268
    });                                                                                                  // 269
    return result.value;                                                                                 // 270
  };                                                                                                     // 271
                                                                                                         // 272
  // Return the minimum element (or element-based computation).                                          // 273
  _.min = function(obj, iterator, context) {                                                             // 274
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {                       // 275
      return Math.min.apply(Math, obj);                                                                  // 276
    }                                                                                                    // 277
    if (!iterator && _.isEmpty(obj)) return Infinity;                                                    // 278
    var result = {computed : Infinity, value: Infinity};                                                 // 279
    each(obj, function(value, index, list) {                                                             // 280
      var computed = iterator ? iterator.call(context, value, index, list) : value;                      // 281
      computed < result.computed && (result = {value : value, computed : computed});                     // 282
    });                                                                                                  // 283
    return result.value;                                                                                 // 284
  };                                                                                                     // 285
                                                                                                         // 286
  // Shuffle an array.                                                                                   // 287
  _.shuffle = function(obj) {                                                                            // 288
    var rand;                                                                                            // 289
    var index = 0;                                                                                       // 290
    var shuffled = [];                                                                                   // 291
    each(obj, function(value) {                                                                          // 292
      rand = _.random(index++);                                                                          // 293
      shuffled[index - 1] = shuffled[rand];                                                              // 294
      shuffled[rand] = value;                                                                            // 295
    });                                                                                                  // 296
    return shuffled;                                                                                     // 297
  };                                                                                                     // 298
                                                                                                         // 299
  // An internal function to generate lookup iterators.                                                  // 300
  var lookupIterator = function(value) {                                                                 // 301
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };                            // 302
  };                                                                                                     // 303
                                                                                                         // 304
  // Sort the object's values by a criterion produced by an iterator.                                    // 305
  _.sortBy = function(obj, value, context) {                                                             // 306
    var iterator = lookupIterator(value);                                                                // 307
    return _.pluck(_.map(obj, function(value, index, list) {                                             // 308
      return {                                                                                           // 309
        value : value,                                                                                   // 310
        index : index,                                                                                   // 311
        criteria : iterator.call(context, value, index, list)                                            // 312
      };                                                                                                 // 313
    }).sort(function(left, right) {                                                                      // 314
      var a = left.criteria;                                                                             // 315
      var b = right.criteria;                                                                            // 316
      if (a !== b) {                                                                                     // 317
        if (a > b || a === void 0) return 1;                                                             // 318
        if (a < b || b === void 0) return -1;                                                            // 319
      }                                                                                                  // 320
      return left.index < right.index ? -1 : 1;                                                          // 321
    }), 'value');                                                                                        // 322
  };                                                                                                     // 323
                                                                                                         // 324
  // An internal function used for aggregate "group by" operations.                                      // 325
  var group = function(obj, value, context, behavior) {                                                  // 326
    var result = {};                                                                                     // 327
    var iterator = lookupIterator(value == null ? _.identity : value);                                   // 328
    each(obj, function(value, index) {                                                                   // 329
      var key = iterator.call(context, value, index, obj);                                               // 330
      behavior(result, key, value);                                                                      // 331
    });                                                                                                  // 332
    return result;                                                                                       // 333
  };                                                                                                     // 334
                                                                                                         // 335
  // Groups the object's values by a criterion. Pass either a string attribute                           // 336
  // to group by, or a function that returns the criterion.                                              // 337
  _.groupBy = function(obj, value, context) {                                                            // 338
    return group(obj, value, context, function(result, key, value) {                                     // 339
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);                               // 340
    });                                                                                                  // 341
  };                                                                                                     // 342
                                                                                                         // 343
  // Counts instances of an object that group by a certain criterion. Pass                               // 344
  // either a string attribute to count by, or a function that returns the                               // 345
  // criterion.                                                                                          // 346
  _.countBy = function(obj, value, context) {                                                            // 347
    return group(obj, value, context, function(result, key) {                                            // 348
      if (!_.has(result, key)) result[key] = 0;                                                          // 349
      result[key]++;                                                                                     // 350
    });                                                                                                  // 351
  };                                                                                                     // 352
                                                                                                         // 353
  // Use a comparator function to figure out the smallest index at which                                 // 354
  // an object should be inserted so as to maintain order. Uses binary search.                           // 355
  _.sortedIndex = function(array, obj, iterator, context) {                                              // 356
    iterator = iterator == null ? _.identity : lookupIterator(iterator);                                 // 357
    var value = iterator.call(context, obj);                                                             // 358
    var low = 0, high = array.length;                                                                    // 359
    while (low < high) {                                                                                 // 360
      var mid = (low + high) >>> 1;                                                                      // 361
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;                           // 362
    }                                                                                                    // 363
    return low;                                                                                          // 364
  };                                                                                                     // 365
                                                                                                         // 366
  // Safely create a real, live array from anything iterable.                                            // 367
  _.toArray = function(obj) {                                                                            // 368
    if (!obj) return [];                                                                                 // 369
    if (_.isArray(obj)) return slice.call(obj);                                                          // 370
    if (obj.length === +obj.length) return _.map(obj, _.identity);                                       // 371
    return _.values(obj);                                                                                // 372
  };                                                                                                     // 373
                                                                                                         // 374
  // Return the number of elements in an object.                                                         // 375
  _.size = function(obj) {                                                                               // 376
    if (obj == null) return 0;                                                                           // 377
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;                               // 378
  };                                                                                                     // 379
                                                                                                         // 380
  // Array Functions                                                                                     // 381
  // ---------------                                                                                     // 382
                                                                                                         // 383
  // Get the first element of an array. Passing **n** will return the first N                            // 384
  // values in the array. Aliased as `head` and `take`. The **guard** check                              // 385
  // allows it to work with `_.map`.                                                                     // 386
  _.first = _.head = _.take = function(array, n, guard) {                                                // 387
    if (array == null) return void 0;                                                                    // 388
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];                                   // 389
  };                                                                                                     // 390
                                                                                                         // 391
  // Returns everything but the last entry of the array. Especially useful on                            // 392
  // the arguments object. Passing **n** will return all the values in                                   // 393
  // the array, excluding the last N. The **guard** check allows it to work with                         // 394
  // `_.map`.                                                                                            // 395
  _.initial = function(array, n, guard) {                                                                // 396
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));                          // 397
  };                                                                                                     // 398
                                                                                                         // 399
  // Get the last element of an array. Passing **n** will return the last N                              // 400
  // values in the array. The **guard** check allows it to work with `_.map`.                            // 401
  _.last = function(array, n, guard) {                                                                   // 402
    if (array == null) return void 0;                                                                    // 403
    if ((n != null) && !guard) {                                                                         // 404
      return slice.call(array, Math.max(array.length - n, 0));                                           // 405
    } else {                                                                                             // 406
      return array[array.length - 1];                                                                    // 407
    }                                                                                                    // 408
  };                                                                                                     // 409
                                                                                                         // 410
  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.                  // 411
  // Especially useful on the arguments object. Passing an **n** will return                             // 412
  // the rest N values in the array. The **guard**                                                       // 413
  // check allows it to work with `_.map`.                                                               // 414
  _.rest = _.tail = _.drop = function(array, n, guard) {                                                 // 415
    return slice.call(array, (n == null) || guard ? 1 : n);                                              // 416
  };                                                                                                     // 417
                                                                                                         // 418
  // Trim out all falsy values from an array.                                                            // 419
  _.compact = function(array) {                                                                          // 420
    return _.filter(array, _.identity);                                                                  // 421
  };                                                                                                     // 422
                                                                                                         // 423
  // Internal implementation of a recursive `flatten` function.                                          // 424
  var flatten = function(input, shallow, output) {                                                       // 425
    if (shallow && _.every(input, _.isArray)) {                                                          // 426
      return concat.apply(output, input);                                                                // 427
    }                                                                                                    // 428
    each(input, function(value) {                                                                        // 429
      if (_.isArray(value) || _.isArguments(value)) {                                                    // 430
        shallow ? push.apply(output, value) : flatten(value, shallow, output);                           // 431
      } else {                                                                                           // 432
        output.push(value);                                                                              // 433
      }                                                                                                  // 434
    });                                                                                                  // 435
    return output;                                                                                       // 436
  };                                                                                                     // 437
                                                                                                         // 438
  // Return a completely flattened version of an array.                                                  // 439
  _.flatten = function(array, shallow) {                                                                 // 440
    return flatten(array, shallow, []);                                                                  // 441
  };                                                                                                     // 442
                                                                                                         // 443
  // Return a version of the array that does not contain the specified value(s).                         // 444
  _.without = function(array) {                                                                          // 445
    return _.difference(array, slice.call(arguments, 1));                                                // 446
  };                                                                                                     // 447
                                                                                                         // 448
  // Produce a duplicate-free version of the array. If the array has already                             // 449
  // been sorted, you have the option of using a faster algorithm.                                       // 450
  // Aliased as `unique`.                                                                                // 451
  _.uniq = _.unique = function(array, isSorted, iterator, context) {                                     // 452
    if (_.isFunction(isSorted)) {                                                                        // 453
      context = iterator;                                                                                // 454
      iterator = isSorted;                                                                               // 455
      isSorted = false;                                                                                  // 456
    }                                                                                                    // 457
    var initial = iterator ? _.map(array, iterator, context) : array;                                    // 458
    var results = [];                                                                                    // 459
    var seen = [];                                                                                       // 460
    each(initial, function(value, index) {                                                               // 461
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {           // 462
        seen.push(value);                                                                                // 463
        results.push(array[index]);                                                                      // 464
      }                                                                                                  // 465
    });                                                                                                  // 466
    return results;                                                                                      // 467
  };                                                                                                     // 468
                                                                                                         // 469
  // Produce an array that contains the union: each distinct element from all of                         // 470
  // the passed-in arrays.                                                                               // 471
  _.union = function() {                                                                                 // 472
    return _.uniq(_.flatten(arguments, true));                                                           // 473
  };                                                                                                     // 474
                                                                                                         // 475
  // Produce an array that contains every item shared between all the                                    // 476
  // passed-in arrays.                                                                                   // 477
  _.intersection = function(array) {                                                                     // 478
    var rest = slice.call(arguments, 1);                                                                 // 479
    return _.filter(_.uniq(array), function(item) {                                                      // 480
      return _.every(rest, function(other) {                                                             // 481
        return _.indexOf(other, item) >= 0;                                                              // 482
      });                                                                                                // 483
    });                                                                                                  // 484
  };                                                                                                     // 485
                                                                                                         // 486
  // Take the difference between one array and a number of other arrays.                                 // 487
  // Only the elements present in just the first array will remain.                                      // 488
  _.difference = function(array) {                                                                       // 489
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 490
    return _.filter(array, function(value){ return !_.contains(rest, value); });                         // 491
  };                                                                                                     // 492
                                                                                                         // 493
  // Zip together multiple lists into a single array -- elements that share                              // 494
  // an index go together.                                                                               // 495
  _.zip = function() {                                                                                   // 496
    var length = _.max(_.pluck(arguments, "length").concat(0));                                          // 497
    var results = new Array(length);                                                                     // 498
    for (var i = 0; i < length; i++) {                                                                   // 499
      results[i] = _.pluck(arguments, '' + i);                                                           // 500
    }                                                                                                    // 501
    return results;                                                                                      // 502
  };                                                                                                     // 503
                                                                                                         // 504
  // Converts lists into objects. Pass either a single array of `[key, value]`                           // 505
  // pairs, or two parallel arrays of the same length -- one of keys, and one of                         // 506
  // the corresponding values.                                                                           // 507
  _.object = function(list, values) {                                                                    // 508
    if (list == null) return {};                                                                         // 509
    var result = {};                                                                                     // 510
    for (var i = 0, l = list.length; i < l; i++) {                                                       // 511
      if (values) {                                                                                      // 512
        result[list[i]] = values[i];                                                                     // 513
      } else {                                                                                           // 514
        result[list[i][0]] = list[i][1];                                                                 // 515
      }                                                                                                  // 516
    }                                                                                                    // 517
    return result;                                                                                       // 518
  };                                                                                                     // 519
                                                                                                         // 520
  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),                       // 521
  // we need this function. Return the position of the first occurrence of an                            // 522
  // item in an array, or -1 if the item is not included in the array.                                   // 523
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.                                      // 524
  // If the array is large and already in sort order, pass `true`                                        // 525
  // for **isSorted** to use binary search.                                                              // 526
  _.indexOf = function(array, item, isSorted) {                                                          // 527
    if (array == null) return -1;                                                                        // 528
    var i = 0, l = array.length;                                                                         // 529
    if (isSorted) {                                                                                      // 530
      if (typeof isSorted == 'number') {                                                                 // 531
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);                                       // 532
      } else {                                                                                           // 533
        i = _.sortedIndex(array, item);                                                                  // 534
        return array[i] === item ? i : -1;                                                               // 535
      }                                                                                                  // 536
    }                                                                                                    // 537
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);          // 538
    for (; i < l; i++) if (array[i] === item) return i;                                                  // 539
    return -1;                                                                                           // 540
  };                                                                                                     // 541
                                                                                                         // 542
  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.                                  // 543
  _.lastIndexOf = function(array, item, from) {                                                          // 544
    if (array == null) return -1;                                                                        // 545
    var hasIndex = from != null;                                                                         // 546
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {                                  // 547
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);                         // 548
    }                                                                                                    // 549
    var i = (hasIndex ? from : array.length);                                                            // 550
    while (i--) if (array[i] === item) return i;                                                         // 551
    return -1;                                                                                           // 552
  };                                                                                                     // 553
                                                                                                         // 554
  // Generate an integer Array containing an arithmetic progression. A port of                           // 555
  // the native Python `range()` function. See                                                           // 556
  // [the Python documentation](http://docs.python.org/library/functions.html#range).                    // 557
  _.range = function(start, stop, step) {                                                                // 558
    if (arguments.length <= 1) {                                                                         // 559
      stop = start || 0;                                                                                 // 560
      start = 0;                                                                                         // 561
    }                                                                                                    // 562
    step = arguments[2] || 1;                                                                            // 563
                                                                                                         // 564
    var len = Math.max(Math.ceil((stop - start) / step), 0);                                             // 565
    var idx = 0;                                                                                         // 566
    var range = new Array(len);                                                                          // 567
                                                                                                         // 568
    while(idx < len) {                                                                                   // 569
      range[idx++] = start;                                                                              // 570
      start += step;                                                                                     // 571
    }                                                                                                    // 572
                                                                                                         // 573
    return range;                                                                                        // 574
  };                                                                                                     // 575
                                                                                                         // 576
  // Function (ahem) Functions                                                                           // 577
  // ------------------                                                                                  // 578
                                                                                                         // 579
  // Reusable constructor function for prototype setting.                                                // 580
  var ctor = function(){};                                                                               // 581
                                                                                                         // 582
  // Create a function bound to a given object (assigning `this`, and arguments,                         // 583
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if                              // 584
  // available.                                                                                          // 585
  _.bind = function(func, context) {                                                                     // 586
    var args, bound;                                                                                     // 587
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1)); // 588
    if (!_.isFunction(func)) throw new TypeError;                                                        // 589
    args = slice.call(arguments, 2);                                                                     // 590
    return bound = function() {                                                                          // 591
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));      // 592
      ctor.prototype = func.prototype;                                                                   // 593
      var self = new ctor;                                                                               // 594
      ctor.prototype = null;                                                                             // 595
      var result = func.apply(self, args.concat(slice.call(arguments)));                                 // 596
      if (Object(result) === result) return result;                                                      // 597
      return self;                                                                                       // 598
    };                                                                                                   // 599
  };                                                                                                     // 600
                                                                                                         // 601
  // Partially apply a function by creating a version that has had some of its                           // 602
  // arguments pre-filled, without changing its dynamic `this` context.                                  // 603
  _.partial = function(func) {                                                                           // 604
    var args = slice.call(arguments, 1);                                                                 // 605
    return function() {                                                                                  // 606
      return func.apply(this, args.concat(slice.call(arguments)));                                       // 607
    };                                                                                                   // 608
  };                                                                                                     // 609
                                                                                                         // 610
  // Bind all of an object's methods to that object. Useful for ensuring that                            // 611
  // all callbacks defined on an object belong to it.                                                    // 612
  _.bindAll = function(obj) {                                                                            // 613
    var funcs = slice.call(arguments, 1);                                                                // 614
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");                    // 615
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });                                          // 616
    return obj;                                                                                          // 617
  };                                                                                                     // 618
                                                                                                         // 619
  // Memoize an expensive function by storing its results.                                               // 620
  _.memoize = function(func, hasher) {                                                                   // 621
    var memo = {};                                                                                       // 622
    hasher || (hasher = _.identity);                                                                     // 623
    return function() {                                                                                  // 624
      var key = hasher.apply(this, arguments);                                                           // 625
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));                   // 626
    };                                                                                                   // 627
  };                                                                                                     // 628
                                                                                                         // 629
  // Delays a function for the given number of milliseconds, and then calls                              // 630
  // it with the arguments supplied.                                                                     // 631
  _.delay = function(func, wait) {                                                                       // 632
    var args = slice.call(arguments, 2);                                                                 // 633
    return setTimeout(function(){ return func.apply(null, args); }, wait);                               // 634
  };                                                                                                     // 635
                                                                                                         // 636
  // Defers a function, scheduling it to run after the current call stack has                            // 637
  // cleared.                                                                                            // 638
  _.defer = function(func) {                                                                             // 639
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));                                 // 640
  };                                                                                                     // 641
                                                                                                         // 642
  // Returns a function, that, when invoked, will only be triggered at most once                         // 643
  // during a given window of time. Normally, the throttled function will run                            // 644
  // as much as it can, without ever going more than once per `wait` duration;                           // 645
  // but if you'd like to disable the execution on the leading edge, pass                                // 646
  // `{leading: false}`. To disable execution on the trailing edge, ditto.                               // 647
  _.throttle = function(func, wait, options) {                                                           // 648
    var context, args, result;                                                                           // 649
    var timeout = null;                                                                                  // 650
    var previous = 0;                                                                                    // 651
    options || (options = {});                                                                           // 652
    var later = function() {                                                                             // 653
      previous = options.leading === false ? 0 : new Date;                                               // 654
      timeout = null;                                                                                    // 655
      result = func.apply(context, args);                                                                // 656
    };                                                                                                   // 657
    return function() {                                                                                  // 658
      var now = new Date;                                                                                // 659
      if (!previous && options.leading === false) previous = now;                                        // 660
      var remaining = wait - (now - previous);                                                           // 661
      context = this;                                                                                    // 662
      args = arguments;                                                                                  // 663
      if (remaining <= 0) {                                                                              // 664
        clearTimeout(timeout);                                                                           // 665
        timeout = null;                                                                                  // 666
        previous = now;                                                                                  // 667
        result = func.apply(context, args);                                                              // 668
      } else if (!timeout && options.trailing !== false) {                                               // 669
        timeout = setTimeout(later, remaining);                                                          // 670
      }                                                                                                  // 671
      return result;                                                                                     // 672
    };                                                                                                   // 673
  };                                                                                                     // 674
                                                                                                         // 675
  // Returns a function, that, as long as it continues to be invoked, will not                           // 676
  // be triggered. The function will be called after it stops being called for                           // 677
  // N milliseconds. If `immediate` is passed, trigger the function on the                               // 678
  // leading edge, instead of the trailing.                                                              // 679
  _.debounce = function(func, wait, immediate) {                                                         // 680
    var result;                                                                                          // 681
    var timeout = null;                                                                                  // 682
    return function() {                                                                                  // 683
      var context = this, args = arguments;                                                              // 684
      var later = function() {                                                                           // 685
        timeout = null;                                                                                  // 686
        if (!immediate) result = func.apply(context, args);                                              // 687
      };                                                                                                 // 688
      var callNow = immediate && !timeout;                                                               // 689
      clearTimeout(timeout);                                                                             // 690
      timeout = setTimeout(later, wait);                                                                 // 691
      if (callNow) result = func.apply(context, args);                                                   // 692
      return result;                                                                                     // 693
    };                                                                                                   // 694
  };                                                                                                     // 695
                                                                                                         // 696
  // Returns a function that will be executed at most one time, no matter how                            // 697
  // often you call it. Useful for lazy initialization.                                                  // 698
  _.once = function(func) {                                                                              // 699
    var ran = false, memo;                                                                               // 700
    return function() {                                                                                  // 701
      if (ran) return memo;                                                                              // 702
      ran = true;                                                                                        // 703
      memo = func.apply(this, arguments);                                                                // 704
      func = null;                                                                                       // 705
      return memo;                                                                                       // 706
    };                                                                                                   // 707
  };                                                                                                     // 708
                                                                                                         // 709
  // Returns the first function passed as an argument to the second,                                     // 710
  // allowing you to adjust arguments, run code before and after, and                                    // 711
  // conditionally execute the original function.                                                        // 712
  _.wrap = function(func, wrapper) {                                                                     // 713
    return function() {                                                                                  // 714
      var args = [func];                                                                                 // 715
      push.apply(args, arguments);                                                                       // 716
      return wrapper.apply(this, args);                                                                  // 717
    };                                                                                                   // 718
  };                                                                                                     // 719
                                                                                                         // 720
  // Returns a function that is the composition of a list of functions, each                             // 721
  // consuming the return value of the function that follows.                                            // 722
  _.compose = function() {                                                                               // 723
    var funcs = arguments;                                                                               // 724
    return function() {                                                                                  // 725
      var args = arguments;                                                                              // 726
      for (var i = funcs.length - 1; i >= 0; i--) {                                                      // 727
        args = [funcs[i].apply(this, args)];                                                             // 728
      }                                                                                                  // 729
      return args[0];                                                                                    // 730
    };                                                                                                   // 731
  };                                                                                                     // 732
                                                                                                         // 733
  // Returns a function that will only be executed after being called N times.                           // 734
  _.after = function(times, func) {                                                                      // 735
    return function() {                                                                                  // 736
      if (--times < 1) {                                                                                 // 737
        return func.apply(this, arguments);                                                              // 738
      }                                                                                                  // 739
    };                                                                                                   // 740
  };                                                                                                     // 741
                                                                                                         // 742
  // Object Functions                                                                                    // 743
  // ----------------                                                                                    // 744
                                                                                                         // 745
  // Retrieve the names of an object's properties.                                                       // 746
  // Delegates to **ECMAScript 5**'s native `Object.keys`                                                // 747
  _.keys = nativeKeys || function(obj) {                                                                 // 748
    if (obj !== Object(obj)) throw new TypeError('Invalid object');                                      // 749
    var keys = [];                                                                                       // 750
    for (var key in obj) if (_.has(obj, key)) keys.push(key);                                            // 751
    return keys;                                                                                         // 752
  };                                                                                                     // 753
                                                                                                         // 754
  // Retrieve the values of an object's properties.                                                      // 755
  _.values = function(obj) {                                                                             // 756
    var values = [];                                                                                     // 757
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);                                     // 758
    return values;                                                                                       // 759
  };                                                                                                     // 760
                                                                                                         // 761
  // Convert an object into a list of `[key, value]` pairs.                                              // 762
  _.pairs = function(obj) {                                                                              // 763
    var pairs = [];                                                                                      // 764
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);                               // 765
    return pairs;                                                                                        // 766
  };                                                                                                     // 767
                                                                                                         // 768
  // Invert the keys and values of an object. The values must be serializable.                           // 769
  _.invert = function(obj) {                                                                             // 770
    var result = {};                                                                                     // 771
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;                                    // 772
    return result;                                                                                       // 773
  };                                                                                                     // 774
                                                                                                         // 775
  // Return a sorted list of the function names available on the object.                                 // 776
  // Aliased as `methods`                                                                                // 777
  _.functions = _.methods = function(obj) {                                                              // 778
    var names = [];                                                                                      // 779
    for (var key in obj) {                                                                               // 780
      if (_.isFunction(obj[key])) names.push(key);                                                       // 781
    }                                                                                                    // 782
    return names.sort();                                                                                 // 783
  };                                                                                                     // 784
                                                                                                         // 785
  // Extend a given object with all the properties in passed-in object(s).                               // 786
  _.extend = function(obj) {                                                                             // 787
    each(slice.call(arguments, 1), function(source) {                                                    // 788
      if (source) {                                                                                      // 789
        for (var prop in source) {                                                                       // 790
          obj[prop] = source[prop];                                                                      // 791
        }                                                                                                // 792
      }                                                                                                  // 793
    });                                                                                                  // 794
    return obj;                                                                                          // 795
  };                                                                                                     // 796
                                                                                                         // 797
  // Return a copy of the object only containing the whitelisted properties.                             // 798
  _.pick = function(obj) {                                                                               // 799
    var copy = {};                                                                                       // 800
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 801
    each(keys, function(key) {                                                                           // 802
      if (key in obj) copy[key] = obj[key];                                                              // 803
    });                                                                                                  // 804
    return copy;                                                                                         // 805
  };                                                                                                     // 806
                                                                                                         // 807
   // Return a copy of the object without the blacklisted properties.                                    // 808
  _.omit = function(obj) {                                                                               // 809
    var copy = {};                                                                                       // 810
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));                                       // 811
    for (var key in obj) {                                                                               // 812
      if (!_.contains(keys, key)) copy[key] = obj[key];                                                  // 813
    }                                                                                                    // 814
    return copy;                                                                                         // 815
  };                                                                                                     // 816
                                                                                                         // 817
  // Fill in a given object with default properties.                                                     // 818
  _.defaults = function(obj) {                                                                           // 819
    each(slice.call(arguments, 1), function(source) {                                                    // 820
      if (source) {                                                                                      // 821
        for (var prop in source) {                                                                       // 822
          if (obj[prop] === void 0) obj[prop] = source[prop];                                            // 823
        }                                                                                                // 824
      }                                                                                                  // 825
    });                                                                                                  // 826
    return obj;                                                                                          // 827
  };                                                                                                     // 828
                                                                                                         // 829
  // Create a (shallow-cloned) duplicate of an object.                                                   // 830
  _.clone = function(obj) {                                                                              // 831
    if (!_.isObject(obj)) return obj;                                                                    // 832
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);                                             // 833
  };                                                                                                     // 834
                                                                                                         // 835
  // Invokes interceptor with the obj, and then returns obj.                                             // 836
  // The primary purpose of this method is to "tap into" a method chain, in                              // 837
  // order to perform operations on intermediate results within the chain.                               // 838
  _.tap = function(obj, interceptor) {                                                                   // 839
    interceptor(obj);                                                                                    // 840
    return obj;                                                                                          // 841
  };                                                                                                     // 842
                                                                                                         // 843
  // Internal recursive comparison function for `isEqual`.                                               // 844
  var eq = function(a, b, aStack, bStack) {                                                              // 845
    // Identical objects are equal. `0 === -0`, but they aren't identical.                               // 846
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).           // 847
    if (a === b) return a !== 0 || 1 / a == 1 / b;                                                       // 848
    // A strict comparison is necessary because `null == undefined`.                                     // 849
    if (a == null || b == null) return a === b;                                                          // 850
    // Unwrap any wrapped objects.                                                                       // 851
    if (a instanceof _) a = a._wrapped;                                                                  // 852
    if (b instanceof _) b = b._wrapped;                                                                  // 853
    // Compare `[[Class]]` names.                                                                        // 854
    var className = toString.call(a);                                                                    // 855
    if (className != toString.call(b)) return false;                                                     // 856
    switch (className) {                                                                                 // 857
      // Strings, numbers, dates, and booleans are compared by value.                                    // 858
      case '[object String]':                                                                            // 859
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is             // 860
        // equivalent to `new String("5")`.                                                              // 861
        return a == String(b);                                                                           // 862
      case '[object Number]':                                                                            // 863
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for               // 864
        // other numeric values.                                                                         // 865
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);                                  // 866
      case '[object Date]':                                                                              // 867
      case '[object Boolean]':                                                                           // 868
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their            // 869
        // millisecond representations. Note that invalid dates with millisecond representations         // 870
        // of `NaN` are not equivalent.                                                                  // 871
        return +a == +b;                                                                                 // 872
      // RegExps are compared by their source patterns and flags.                                        // 873
      case '[object RegExp]':                                                                            // 874
        return a.source == b.source &&                                                                   // 875
               a.global == b.global &&                                                                   // 876
               a.multiline == b.multiline &&                                                             // 877
               a.ignoreCase == b.ignoreCase;                                                             // 878
    }                                                                                                    // 879
    if (typeof a != 'object' || typeof b != 'object') return false;                                      // 880
    // Assume equality for cyclic structures. The algorithm for detecting cyclic                         // 881
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.                       // 882
    var length = aStack.length;                                                                          // 883
    while (length--) {                                                                                   // 884
      // Linear search. Performance is inversely proportional to the number of                           // 885
      // unique nested structures.                                                                       // 886
      if (aStack[length] == a) return bStack[length] == b;                                               // 887
    }                                                                                                    // 888
    // Objects with different constructors are not equivalent, but `Object`s                             // 889
    // from different frames are.                                                                        // 890
    var aCtor = a.constructor, bCtor = b.constructor;                                                    // 891
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&                          // 892
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {                         // 893
      return false;                                                                                      // 894
    }                                                                                                    // 895
    // Add the first object to the stack of traversed objects.                                           // 896
    aStack.push(a);                                                                                      // 897
    bStack.push(b);                                                                                      // 898
    var size = 0, result = true;                                                                         // 899
    // Recursively compare objects and arrays.                                                           // 900
    if (className == '[object Array]') {                                                                 // 901
      // Compare array lengths to determine if a deep comparison is necessary.                           // 902
      size = a.length;                                                                                   // 903
      result = size == b.length;                                                                         // 904
      if (result) {                                                                                      // 905
        // Deep compare the contents, ignoring non-numeric properties.                                   // 906
        while (size--) {                                                                                 // 907
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;                                   // 908
        }                                                                                                // 909
      }                                                                                                  // 910
    } else {                                                                                             // 911
      // Deep compare objects.                                                                           // 912
      for (var key in a) {                                                                               // 913
        if (_.has(a, key)) {                                                                             // 914
          // Count the expected number of properties.                                                    // 915
          size++;                                                                                        // 916
          // Deep compare each member.                                                                   // 917
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;                    // 918
        }                                                                                                // 919
      }                                                                                                  // 920
      // Ensure that both objects contain the same number of properties.                                 // 921
      if (result) {                                                                                      // 922
        for (key in b) {                                                                                 // 923
          if (_.has(b, key) && !(size--)) break;                                                         // 924
        }                                                                                                // 925
        result = !size;                                                                                  // 926
      }                                                                                                  // 927
    }                                                                                                    // 928
    // Remove the first object from the stack of traversed objects.                                      // 929
    aStack.pop();                                                                                        // 930
    bStack.pop();                                                                                        // 931
    return result;                                                                                       // 932
  };                                                                                                     // 933
                                                                                                         // 934
  // Perform a deep comparison to check if two objects are equal.                                        // 935
  _.isEqual = function(a, b) {                                                                           // 936
    return eq(a, b, [], []);                                                                             // 937
  };                                                                                                     // 938
                                                                                                         // 939
  // Is a given array, string, or object empty?                                                          // 940
  // An "empty" object has no enumerable own-properties.                                                 // 941
  _.isEmpty = function(obj) {                                                                            // 942
    if (obj == null) return true;                                                                        // 943
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;                                      // 944
    for (var key in obj) if (_.has(obj, key)) return false;                                              // 945
    return true;                                                                                         // 946
  };                                                                                                     // 947
                                                                                                         // 948
  // Is a given value a DOM element?                                                                     // 949
  _.isElement = function(obj) {                                                                          // 950
    return !!(obj && obj.nodeType === 1);                                                                // 951
  };                                                                                                     // 952
                                                                                                         // 953
  // Is a given value an array?                                                                          // 954
  // Delegates to ECMA5's native Array.isArray                                                           // 955
  _.isArray = nativeIsArray || function(obj) {                                                           // 956
    return toString.call(obj) == '[object Array]';                                                       // 957
  };                                                                                                     // 958
                                                                                                         // 959
  // Is a given variable an object?                                                                      // 960
  _.isObject = function(obj) {                                                                           // 961
    return obj === Object(obj);                                                                          // 962
  };                                                                                                     // 963
                                                                                                         // 964
  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.             // 965
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {                 // 966
    _['is' + name] = function(obj) {                                                                     // 967
      return toString.call(obj) == '[object ' + name + ']';                                              // 968
    };                                                                                                   // 969
  });                                                                                                    // 970
                                                                                                         // 971
  // Define a fallback version of the method in browsers (ahem, IE), where                               // 972
  // there isn't any inspectable "Arguments" type.                                                       // 973
  if (!_.isArguments(arguments)) {                                                                       // 974
    _.isArguments = function(obj) {                                                                      // 975
      return !!(obj && _.has(obj, 'callee'));                                                            // 976
    };                                                                                                   // 977
  }                                                                                                      // 978
                                                                                                         // 979
  // Optimize `isFunction` if appropriate.                                                               // 980
  if (typeof (/./) !== 'function') {                                                                     // 981
    _.isFunction = function(obj) {                                                                       // 982
      return typeof obj === 'function';                                                                  // 983
    };                                                                                                   // 984
  }                                                                                                      // 985
                                                                                                         // 986
  // Is a given object a finite number?                                                                  // 987
  _.isFinite = function(obj) {                                                                           // 988
    return isFinite(obj) && !isNaN(parseFloat(obj));                                                     // 989
  };                                                                                                     // 990
                                                                                                         // 991
  // Is the given value `NaN`? (NaN is the only number which does not equal itself).                     // 992
  _.isNaN = function(obj) {                                                                              // 993
    return _.isNumber(obj) && obj != +obj;                                                               // 994
  };                                                                                                     // 995
                                                                                                         // 996
  // Is a given value a boolean?                                                                         // 997
  _.isBoolean = function(obj) {                                                                          // 998
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';                    // 999
  };                                                                                                     // 1000
                                                                                                         // 1001
  // Is a given value equal to null?                                                                     // 1002
  _.isNull = function(obj) {                                                                             // 1003
    return obj === null;                                                                                 // 1004
  };                                                                                                     // 1005
                                                                                                         // 1006
  // Is a given variable undefined?                                                                      // 1007
  _.isUndefined = function(obj) {                                                                        // 1008
    return obj === void 0;                                                                               // 1009
  };                                                                                                     // 1010
                                                                                                         // 1011
  // Shortcut function for checking if an object has a given property directly                           // 1012
  // on itself (in other words, not on a prototype).                                                     // 1013
  _.has = function(obj, key) {                                                                           // 1014
    return hasOwnProperty.call(obj, key);                                                                // 1015
  };                                                                                                     // 1016
                                                                                                         // 1017
  // Utility Functions                                                                                   // 1018
  // -----------------                                                                                   // 1019
                                                                                                         // 1020
  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its                           // 1021
  // previous owner. Returns a reference to the Underscore object.                                       // 1022
  _.noConflict = function() {                                                                            // 1023
    root._ = previousUnderscore;                                                                         // 1024
    return this;                                                                                         // 1025
  };                                                                                                     // 1026
                                                                                                         // 1027
  // Keep the identity function around for default iterators.                                            // 1028
  _.identity = function(value) {                                                                         // 1029
    return value;                                                                                        // 1030
  };                                                                                                     // 1031
                                                                                                         // 1032
  // Run a function **n** times.                                                                         // 1033
  _.times = function(n, iterator, context) {                                                             // 1034
    var accum = Array(Math.max(0, n));                                                                   // 1035
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);                                    // 1036
    return accum;                                                                                        // 1037
  };                                                                                                     // 1038
                                                                                                         // 1039
  // Return a random integer between min and max (inclusive).                                            // 1040
  _.random = function(min, max) {                                                                        // 1041
    if (max == null) {                                                                                   // 1042
      max = min;                                                                                         // 1043
      min = 0;                                                                                           // 1044
    }                                                                                                    // 1045
    return min + Math.floor(Math.random() * (max - min + 1));                                            // 1046
  };                                                                                                     // 1047
                                                                                                         // 1048
  // List of HTML entities for escaping.                                                                 // 1049
  var entityMap = {                                                                                      // 1050
    escape: {                                                                                            // 1051
      '&': '&amp;',                                                                                      // 1052
      '<': '&lt;',                                                                                       // 1053
      '>': '&gt;',                                                                                       // 1054
      '"': '&quot;',                                                                                     // 1055
      "'": '&#x27;',                                                                                     // 1056
      '/': '&#x2F;'                                                                                      // 1057
    }                                                                                                    // 1058
  };                                                                                                     // 1059
  entityMap.unescape = _.invert(entityMap.escape);                                                       // 1060
                                                                                                         // 1061
  // Regexes containing the keys and values listed immediately above.                                    // 1062
  var entityRegexes = {                                                                                  // 1063
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),                            // 1064
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')                          // 1065
  };                                                                                                     // 1066
                                                                                                         // 1067
  // Functions for escaping and unescaping strings to/from HTML interpolation.                           // 1068
  _.each(['escape', 'unescape'], function(method) {                                                      // 1069
    _[method] = function(string) {                                                                       // 1070
      if (string == null) return '';                                                                     // 1071
      return ('' + string).replace(entityRegexes[method], function(match) {                              // 1072
        return entityMap[method][match];                                                                 // 1073
      });                                                                                                // 1074
    };                                                                                                   // 1075
  });                                                                                                    // 1076
                                                                                                         // 1077
  // If the value of the named `property` is a function then invoke it with the                          // 1078
  // `object` as context; otherwise, return it.                                                          // 1079
  _.result = function(object, property) {                                                                // 1080
    if (object == null) return void 0;                                                                   // 1081
    var value = object[property];                                                                        // 1082
    return _.isFunction(value) ? value.call(object) : value;                                             // 1083
  };                                                                                                     // 1084
                                                                                                         // 1085
  // Add your own custom functions to the Underscore object.                                             // 1086
  _.mixin = function(obj) {                                                                              // 1087
    each(_.functions(obj), function(name){                                                               // 1088
      var func = _[name] = obj[name];                                                                    // 1089
      _.prototype[name] = function() {                                                                   // 1090
        var args = [this._wrapped];                                                                      // 1091
        push.apply(args, arguments);                                                                     // 1092
        return result.call(this, func.apply(_, args));                                                   // 1093
      };                                                                                                 // 1094
    });                                                                                                  // 1095
  };                                                                                                     // 1096
                                                                                                         // 1097
  // Generate a unique integer id (unique within the entire client session).                             // 1098
  // Useful for temporary DOM ids.                                                                       // 1099
  var idCounter = 0;                                                                                     // 1100
  _.uniqueId = function(prefix) {                                                                        // 1101
    var id = ++idCounter + '';                                                                           // 1102
    return prefix ? prefix + id : id;                                                                    // 1103
  };                                                                                                     // 1104
                                                                                                         // 1105
  // By default, Underscore uses ERB-style template delimiters, change the                               // 1106
  // following template settings to use alternative delimiters.                                          // 1107
  _.templateSettings = {                                                                                 // 1108
    evaluate    : /<%([\s\S]+?)%>/g,                                                                     // 1109
    interpolate : /<%=([\s\S]+?)%>/g,                                                                    // 1110
    escape      : /<%-([\s\S]+?)%>/g                                                                     // 1111
  };                                                                                                     // 1112
                                                                                                         // 1113
  // When customizing `templateSettings`, if you don't want to define an                                 // 1114
  // interpolation, evaluation or escaping regex, we need one that is                                    // 1115
  // guaranteed not to match.                                                                            // 1116
  var noMatch = /(.)^/;                                                                                  // 1117
                                                                                                         // 1118
  // Certain characters need to be escaped so that they can be put into a                                // 1119
  // string literal.                                                                                     // 1120
  var escapes = {                                                                                        // 1121
    "'":      "'",                                                                                       // 1122
    '\\':     '\\',                                                                                      // 1123
    '\r':     'r',                                                                                       // 1124
    '\n':     'n',                                                                                       // 1125
    '\t':     't',                                                                                       // 1126
    '\u2028': 'u2028',                                                                                   // 1127
    '\u2029': 'u2029'                                                                                    // 1128
  };                                                                                                     // 1129
                                                                                                         // 1130
  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;                                                          // 1131
                                                                                                         // 1132
  // JavaScript micro-templating, similar to John Resig's implementation.                                // 1133
  // Underscore templating handles arbitrary delimiters, preserves whitespace,                           // 1134
  // and correctly escapes quotes within interpolated code.                                              // 1135
  _.template = function(text, data, settings) {                                                          // 1136
    var render;                                                                                          // 1137
    settings = _.defaults({}, settings, _.templateSettings);                                             // 1138
                                                                                                         // 1139
    // Combine delimiters into one regular expression via alternation.                                   // 1140
    var matcher = new RegExp([                                                                           // 1141
      (settings.escape || noMatch).source,                                                               // 1142
      (settings.interpolate || noMatch).source,                                                          // 1143
      (settings.evaluate || noMatch).source                                                              // 1144
    ].join('|') + '|$', 'g');                                                                            // 1145
                                                                                                         // 1146
    // Compile the template source, escaping string literals appropriately.                              // 1147
    var index = 0;                                                                                       // 1148
    var source = "__p+='";                                                                               // 1149
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {                       // 1150
      source += text.slice(index, offset)                                                                // 1151
        .replace(escaper, function(match) { return '\\' + escapes[match]; });                            // 1152
                                                                                                         // 1153
      if (escape) {                                                                                      // 1154
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";                             // 1155
      }                                                                                                  // 1156
      if (interpolate) {                                                                                 // 1157
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";                                  // 1158
      }                                                                                                  // 1159
      if (evaluate) {                                                                                    // 1160
        source += "';\n" + evaluate + "\n__p+='";                                                        // 1161
      }                                                                                                  // 1162
      index = offset + match.length;                                                                     // 1163
      return match;                                                                                      // 1164
    });                                                                                                  // 1165
    source += "';\n";                                                                                    // 1166
                                                                                                         // 1167
    // If a variable is not specified, place data values in local scope.                                 // 1168
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';                                // 1169
                                                                                                         // 1170
    source = "var __t,__p='',__j=Array.prototype.join," +                                                // 1171
      "print=function(){__p+=__j.call(arguments,'');};\n" +                                              // 1172
      source + "return __p;\n";                                                                          // 1173
                                                                                                         // 1174
    try {                                                                                                // 1175
      render = new Function(settings.variable || 'obj', '_', source);                                    // 1176
    } catch (e) {                                                                                        // 1177
      e.source = source;                                                                                 // 1178
      throw e;                                                                                           // 1179
    }                                                                                                    // 1180
                                                                                                         // 1181
    if (data) return render(data, _);                                                                    // 1182
    var template = function(data) {                                                                      // 1183
      return render.call(this, data, _);                                                                 // 1184
    };                                                                                                   // 1185
                                                                                                         // 1186
    // Provide the compiled function source as a convenience for precompilation.                         // 1187
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';                // 1188
                                                                                                         // 1189
    return template;                                                                                     // 1190
  };                                                                                                     // 1191
                                                                                                         // 1192
  // Add a "chain" function, which will delegate to the wrapper.                                         // 1193
  _.chain = function(obj) {                                                                              // 1194
    return _(obj).chain();                                                                               // 1195
  };                                                                                                     // 1196
                                                                                                         // 1197
  // OOP                                                                                                 // 1198
  // ---------------                                                                                     // 1199
  // If Underscore is called as a function, it returns a wrapped object that                             // 1200
  // can be used OO-style. This wrapper holds altered versions of all the                                // 1201
  // underscore functions. Wrapped objects may be chained.                                               // 1202
                                                                                                         // 1203
  // Helper function to continue chaining intermediate results.                                          // 1204
  var result = function(obj) {                                                                           // 1205
    return this._chain ? _(obj).chain() : obj;                                                           // 1206
  };                                                                                                     // 1207
                                                                                                         // 1208
  // Add all of the Underscore functions to the wrapper object.                                          // 1209
  _.mixin(_);                                                                                            // 1210
                                                                                                         // 1211
  // Add all mutator Array functions to the wrapper.                                                     // 1212
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {                // 1213
    var method = ArrayProto[name];                                                                       // 1214
    _.prototype[name] = function() {                                                                     // 1215
      var obj = this._wrapped;                                                                           // 1216
      method.apply(obj, arguments);                                                                      // 1217
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];                      // 1218
      return result.call(this, obj);                                                                     // 1219
    };                                                                                                   // 1220
  });                                                                                                    // 1221
                                                                                                         // 1222
  // Add all accessor Array functions to the wrapper.                                                    // 1223
  each(['concat', 'join', 'slice'], function(name) {                                                     // 1224
    var method = ArrayProto[name];                                                                       // 1225
    _.prototype[name] = function() {                                                                     // 1226
      return result.call(this, method.apply(this._wrapped, arguments));                                  // 1227
    };                                                                                                   // 1228
  });                                                                                                    // 1229
                                                                                                         // 1230
  _.extend(_.prototype, {                                                                                // 1231
                                                                                                         // 1232
    // Start chaining a wrapped Underscore object.                                                       // 1233
    chain: function() {                                                                                  // 1234
      this._chain = true;                                                                                // 1235
      return this;                                                                                       // 1236
    },                                                                                                   // 1237
                                                                                                         // 1238
    // Extracts the result from a wrapped and chained object.                                            // 1239
    value: function() {                                                                                  // 1240
      return this._wrapped;                                                                              // 1241
    }                                                                                                    // 1242
                                                                                                         // 1243
  });                                                                                                    // 1244
                                                                                                         // 1245
}).call(this);                                                                                           // 1246
                                                                                                         // 1247
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                       //
// packages/underscore/post.js                                                                           //
//                                                                                                       //
///////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                         //
// This exports object was created in pre.js.  Now copy the `_` object from it                           // 1
// into the package-scope variable `_`, which will get exported.                                         // 2
_ = exports._;                                                                                           // 3
                                                                                                         // 4
///////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.underscore = {
  _: _
};

})();

//# sourceMappingURL=a1286cdb983623d4d035c8d7cd7a1e8e15274cf5.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var _ = Package.underscore._;

/* Package-scope variables */
var Meteor;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/client_environment.js                                                            //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
Meteor = {                                                                                          // 1
  isClient: true,                                                                                   // 2
  isServer: false                                                                                   // 3
};                                                                                                  // 4
                                                                                                    // 5
if (typeof __meteor_runtime_config__ === 'object' &&                                                // 6
    __meteor_runtime_config__.PUBLIC_SETTINGS) {                                                    // 7
  Meteor.settings = { 'public': __meteor_runtime_config__.PUBLIC_SETTINGS };                        // 8
}                                                                                                   // 9
                                                                                                    // 10
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/helpers.js                                                                       //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
if (Meteor.isServer)                                                                                // 1
  var Future = Npm.require('fibers/future');                                                        // 2
                                                                                                    // 3
if (typeof __meteor_runtime_config__ === 'object' &&                                                // 4
    __meteor_runtime_config__.meteorRelease)                                                        // 5
  Meteor.release = __meteor_runtime_config__.meteorRelease;                                         // 6
                                                                                                    // 7
// XXX find a better home for these? Ideally they would be _.get,                                   // 8
// _.ensure, _.delete..                                                                             // 9
                                                                                                    // 10
_.extend(Meteor, {                                                                                  // 11
  // _get(a,b,c,d) returns a[b][c][d], or else undefined if a[b] or                                 // 12
  // a[b][c] doesn't exist.                                                                         // 13
  //                                                                                                // 14
  _get: function (obj /*, arguments */) {                                                           // 15
    for (var i = 1; i < arguments.length; i++) {                                                    // 16
      if (!(arguments[i] in obj))                                                                   // 17
        return undefined;                                                                           // 18
      obj = obj[arguments[i]];                                                                      // 19
    }                                                                                               // 20
    return obj;                                                                                     // 21
  },                                                                                                // 22
                                                                                                    // 23
  // _ensure(a,b,c,d) ensures that a[b][c][d] exists. If it does not,                               // 24
  // it is created and set to {}. Either way, it is returned.                                       // 25
  //                                                                                                // 26
  _ensure: function (obj /*, arguments */) {                                                        // 27
    for (var i = 1; i < arguments.length; i++) {                                                    // 28
      var key = arguments[i];                                                                       // 29
      if (!(key in obj))                                                                            // 30
        obj[key] = {};                                                                              // 31
      obj = obj[key];                                                                               // 32
    }                                                                                               // 33
                                                                                                    // 34
    return obj;                                                                                     // 35
  },                                                                                                // 36
                                                                                                    // 37
  // _delete(a, b, c, d) deletes a[b][c][d], then a[b][c] unless it                                 // 38
  // isn't empty, then a[b] unless it isn't empty.                                                  // 39
  //                                                                                                // 40
  _delete: function (obj /*, arguments */) {                                                        // 41
    var stack = [obj];                                                                              // 42
    var leaf = true;                                                                                // 43
    for (var i = 1; i < arguments.length - 1; i++) {                                                // 44
      var key = arguments[i];                                                                       // 45
      if (!(key in obj)) {                                                                          // 46
        leaf = false;                                                                               // 47
        break;                                                                                      // 48
      }                                                                                             // 49
      obj = obj[key];                                                                               // 50
      if (typeof obj !== "object")                                                                  // 51
        break;                                                                                      // 52
      stack.push(obj);                                                                              // 53
    }                                                                                               // 54
                                                                                                    // 55
    for (var i = stack.length - 1; i >= 0; i--) {                                                   // 56
      var key = arguments[i+1];                                                                     // 57
                                                                                                    // 58
      if (leaf)                                                                                     // 59
        leaf = false;                                                                               // 60
      else                                                                                          // 61
        for (var other in stack[i][key])                                                            // 62
          return; // not empty -- we're done                                                        // 63
                                                                                                    // 64
      delete stack[i][key];                                                                         // 65
    }                                                                                               // 66
  },                                                                                                // 67
                                                                                                    // 68
  // _wrapAsync can wrap any function that takes some number of arguments that                      // 69
  // can't be undefined, followed by some optional arguments, where the callback                    // 70
  // is the last optional argument.                                                                 // 71
  // e.g. fs.readFile(pathname, [callback]),                                                        // 72
  // fs.open(pathname, flags, [mode], [callback])                                                   // 73
  // For maximum effectiveness and least confusion, wrapAsync should be used on                     // 74
  // functions where the callback is the only argument of type Function.                            // 75
  //                                                                                                // 76
  _wrapAsync: function (fn) {                                                                       // 77
    return function (/* arguments */) {                                                             // 78
      var self = this;                                                                              // 79
      var callback;                                                                                 // 80
      var fut;                                                                                      // 81
      var newArgs = _.toArray(arguments);                                                           // 82
                                                                                                    // 83
      var logErr = function (err) {                                                                 // 84
        if (err)                                                                                    // 85
          return Meteor._debug("Exception in callback of async function",                           // 86
                               err ? err.stack : err);                                              // 87
      };                                                                                            // 88
                                                                                                    // 89
      // Pop off optional args that are undefined                                                   // 90
      while (newArgs.length > 0 &&                                                                  // 91
             typeof(newArgs[newArgs.length - 1]) === "undefined") {                                 // 92
        newArgs.pop();                                                                              // 93
      }                                                                                             // 94
      // If we have any left and the last one is a function, then that's our                        // 95
      // callback; otherwise, we don't have one.                                                    // 96
      if (newArgs.length > 0 &&                                                                     // 97
          newArgs[newArgs.length - 1] instanceof Function) {                                        // 98
        callback = newArgs.pop();                                                                   // 99
      } else {                                                                                      // 100
        if (Meteor.isClient) {                                                                      // 101
          callback = logErr;                                                                        // 102
        } else {                                                                                    // 103
          fut = new Future();                                                                       // 104
          callback = fut.resolver();                                                                // 105
        }                                                                                           // 106
      }                                                                                             // 107
      newArgs.push(Meteor.bindEnvironment(callback, logErr));                                       // 108
      var result = fn.apply(self, newArgs);                                                         // 109
      if (fut)                                                                                      // 110
        return fut.wait();                                                                          // 111
      return result;                                                                                // 112
    };                                                                                              // 113
  }                                                                                                 // 114
});                                                                                                 // 115
                                                                                                    // 116
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/setimmediate.js                                                                  //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// Chooses one of three setImmediate implementations:                                               // 1
//                                                                                                  // 2
// * Native setImmediate (IE 10, Node 0.9+)                                                         // 3
//                                                                                                  // 4
// * postMessage (many browsers)                                                                    // 5
//                                                                                                  // 6
// * setTimeout  (fallback)                                                                         // 7
//                                                                                                  // 8
// The postMessage implementation is based on                                                       // 9
// https://github.com/NobleJS/setImmediate/tree/1.0.1                                               // 10
//                                                                                                  // 11
// Don't use `nextTick` for Node since it runs its callbacks before                                 // 12
// I/O, which is stricter than we're looking for.                                                   // 13
//                                                                                                  // 14
// Not installed as a polyfill, as our public API is `Meteor.defer`.                                // 15
// Since we're not trying to be a polyfill, we have some                                            // 16
// simplifications:                                                                                 // 17
//                                                                                                  // 18
// If one invocation of a setImmediate callback pauses itself by a                                  // 19
// call to alert/prompt/showModelDialog, the NobleJS polyfill                                       // 20
// implementation ensured that no setImmedate callback would run until                              // 21
// the first invocation completed.  While correct per the spec, what it                             // 22
// would mean for us in practice is that any reactive updates relying                               // 23
// on Meteor.defer would be hung in the main window until the modal                                 // 24
// dialog was dismissed.  Thus we only ensure that a setImmediate                                   // 25
// function is called in a later event loop.                                                        // 26
//                                                                                                  // 27
// We don't need to support using a string to be eval'ed for the                                    // 28
// callback, arguments to the function, or clearImmediate.                                          // 29
                                                                                                    // 30
"use strict";                                                                                       // 31
                                                                                                    // 32
var global = this;                                                                                  // 33
                                                                                                    // 34
                                                                                                    // 35
// IE 10, Node >= 9.1                                                                               // 36
                                                                                                    // 37
function useSetImmediate() {                                                                        // 38
  if (! global.setImmediate)                                                                        // 39
    return null;                                                                                    // 40
  else {                                                                                            // 41
    var setImmediate = function (fn) {                                                              // 42
      global.setImmediate(fn);                                                                      // 43
    };                                                                                              // 44
    setImmediate.implementation = 'setImmediate';                                                   // 45
    return setImmediate;                                                                            // 46
  }                                                                                                 // 47
}                                                                                                   // 48
                                                                                                    // 49
                                                                                                    // 50
// Android 2.3.6, Chrome 26, Firefox 20, IE 8-9, iOS 5.1.1 Safari                                   // 51
                                                                                                    // 52
function usePostMessage() {                                                                         // 53
  // The test against `importScripts` prevents this implementation                                  // 54
  // from being installed inside a web worker, where                                                // 55
  // `global.postMessage` means something completely different and                                  // 56
  // can't be used for this purpose.                                                                // 57
                                                                                                    // 58
  if (!global.postMessage || global.importScripts) {                                                // 59
    return null;                                                                                    // 60
  }                                                                                                 // 61
                                                                                                    // 62
  // Avoid synchronous post message implementations.                                                // 63
                                                                                                    // 64
  var postMessageIsAsynchronous = true;                                                             // 65
  var oldOnMessage = global.onmessage;                                                              // 66
  global.onmessage = function () {                                                                  // 67
      postMessageIsAsynchronous = false;                                                            // 68
  };                                                                                                // 69
  global.postMessage("", "*");                                                                      // 70
  global.onmessage = oldOnMessage;                                                                  // 71
                                                                                                    // 72
  if (! postMessageIsAsynchronous)                                                                  // 73
    return null;                                                                                    // 74
                                                                                                    // 75
  var funcIndex = 0;                                                                                // 76
  var funcs = {};                                                                                   // 77
                                                                                                    // 78
  // Installs an event handler on `global` for the `message` event: see                             // 79
  // * https://developer.mozilla.org/en/DOM/window.postMessage                                      // 80
  // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages // 81
                                                                                                    // 82
  // XXX use Random.id() here?                                                                      // 83
  var MESSAGE_PREFIX = "Meteor._setImmediate." + Math.random() + '.';                               // 84
                                                                                                    // 85
  function isStringAndStartsWith(string, putativeStart) {                                           // 86
    return (typeof string === "string" &&                                                           // 87
            string.substring(0, putativeStart.length) === putativeStart);                           // 88
  }                                                                                                 // 89
                                                                                                    // 90
  function onGlobalMessage(event) {                                                                 // 91
    // This will catch all incoming messages (even from other                                       // 92
    // windows!), so we need to try reasonably hard to avoid letting                                // 93
    // anyone else trick us into firing off. We test the origin is                                  // 94
    // still this window, and that a (randomly generated)                                           // 95
    // unpredictable identifying prefix is present.                                                 // 96
    if (event.source === global &&                                                                  // 97
        isStringAndStartsWith(event.data, MESSAGE_PREFIX)) {                                        // 98
      var index = event.data.substring(MESSAGE_PREFIX.length);                                      // 99
      try {                                                                                         // 100
        if (funcs[index])                                                                           // 101
          funcs[index]();                                                                           // 102
      }                                                                                             // 103
      finally {                                                                                     // 104
        delete funcs[index];                                                                        // 105
      }                                                                                             // 106
    }                                                                                               // 107
  }                                                                                                 // 108
                                                                                                    // 109
  if (global.addEventListener) {                                                                    // 110
    global.addEventListener("message", onGlobalMessage, false);                                     // 111
  } else {                                                                                          // 112
    global.attachEvent("onmessage", onGlobalMessage);                                               // 113
  }                                                                                                 // 114
                                                                                                    // 115
  var setImmediate = function (fn) {                                                                // 116
    // Make `global` post a message to itself with the handle and                                   // 117
    // identifying prefix, thus asynchronously invoking our                                         // 118
    // onGlobalMessage listener above.                                                              // 119
    ++funcIndex;                                                                                    // 120
    funcs[funcIndex] = fn;                                                                          // 121
    global.postMessage(MESSAGE_PREFIX + funcIndex, "*");                                            // 122
  };                                                                                                // 123
  setImmediate.implementation = 'postMessage';                                                      // 124
  return setImmediate;                                                                              // 125
}                                                                                                   // 126
                                                                                                    // 127
                                                                                                    // 128
function useTimeout() {                                                                             // 129
  var setImmediate = function (fn) {                                                                // 130
    global.setTimeout(fn, 0);                                                                       // 131
  };                                                                                                // 132
  setImmediate.implementation = 'setTimeout';                                                       // 133
  return setImmediate;                                                                              // 134
}                                                                                                   // 135
                                                                                                    // 136
                                                                                                    // 137
Meteor._setImmediate =                                                                              // 138
  useSetImmediate() ||                                                                              // 139
  usePostMessage() ||                                                                               // 140
  useTimeout();                                                                                     // 141
                                                                                                    // 142
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/timers.js                                                                        //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
var withoutInvocation = function (f) {                                                              // 1
  if (Package.livedata) {                                                                           // 2
    var _CurrentInvocation = Package.livedata.DDP._CurrentInvocation;                               // 3
    if (_CurrentInvocation.get() && _CurrentInvocation.get().isSimulation)                          // 4
      throw new Error("Can't set timers inside simulations");                                       // 5
    return function () { _CurrentInvocation.withValue(null, f); };                                  // 6
  }                                                                                                 // 7
  else                                                                                              // 8
    return f;                                                                                       // 9
};                                                                                                  // 10
                                                                                                    // 11
var bindAndCatch = function (context, f) {                                                          // 12
  return Meteor.bindEnvironment(withoutInvocation(f), function (e) {                                // 13
    // XXX report nicely (or, should we catch it at all?)                                           // 14
    Meteor._debug("Exception from " + context + ":", e, e.stack);                                   // 15
  });                                                                                               // 16
};                                                                                                  // 17
                                                                                                    // 18
_.extend(Meteor, {                                                                                  // 19
  // Meteor.setTimeout and Meteor.setInterval callbacks scheduled                                   // 20
  // inside a server method are not part of the method invocation and                               // 21
  // should clear out the CurrentInvocation environment variable.                                   // 22
                                                                                                    // 23
  setTimeout: function (f, duration) {                                                              // 24
    return setTimeout(bindAndCatch("setTimeout callback", f), duration);                            // 25
  },                                                                                                // 26
                                                                                                    // 27
  setInterval: function (f, duration) {                                                             // 28
    return setInterval(bindAndCatch("setInterval callback", f), duration);                          // 29
  },                                                                                                // 30
                                                                                                    // 31
  clearInterval: function(x) {                                                                      // 32
    return clearInterval(x);                                                                        // 33
  },                                                                                                // 34
                                                                                                    // 35
  clearTimeout: function(x) {                                                                       // 36
    return clearTimeout(x);                                                                         // 37
  },                                                                                                // 38
                                                                                                    // 39
  // XXX consider making this guarantee ordering of defer'd callbacks, like                         // 40
  // Deps.afterFlush or Node's nextTick (in practice). Then tests can do:                           // 41
  //    callSomethingThatDefersSomeWork();                                                          // 42
  //    Meteor.defer(expect(somethingThatValidatesThatTheWorkHappened));                            // 43
  defer: function (f) {                                                                             // 44
    Meteor._setImmediate(bindAndCatch("defer callback", f));                                        // 45
  }                                                                                                 // 46
});                                                                                                 // 47
                                                                                                    // 48
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/errors.js                                                                        //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// http://davidshariff.com/blog/javascript-inheritance-patterns/                                    // 1
var inherits = function (child, parent) {                                                           // 2
  var tmp = function () {};                                                                         // 3
  tmp.prototype = parent.prototype;                                                                 // 4
  child.prototype = new tmp;                                                                        // 5
  child.prototype.constructor = child;                                                              // 6
};                                                                                                  // 7
                                                                                                    // 8
// Makes an error subclass which properly contains a stack trace in most                            // 9
// environments. constructor can set fields on `this` (and should probably set                      // 10
// `message`, which is what gets displayed at the top of a stack trace).                            // 11
//                                                                                                  // 12
Meteor.makeErrorType = function (name, constructor) {                                               // 13
  var errorClass = function (/*arguments*/) {                                                       // 14
    var self = this;                                                                                // 15
                                                                                                    // 16
    // Ensure we get a proper stack trace in most Javascript environments                           // 17
    if (Error.captureStackTrace) {                                                                  // 18
      // V8 environments (Chrome and Node.js)                                                       // 19
      Error.captureStackTrace(self, errorClass);                                                    // 20
    } else {                                                                                        // 21
      // Firefox                                                                                    // 22
      var e = new Error;                                                                            // 23
      e.__proto__ = errorClass.prototype;                                                           // 24
      if (e instanceof errorClass)                                                                  // 25
        self = e;                                                                                   // 26
    }                                                                                               // 27
    // Safari magically works.                                                                      // 28
                                                                                                    // 29
    constructor.apply(self, arguments);                                                             // 30
                                                                                                    // 31
    self.errorType = name;                                                                          // 32
                                                                                                    // 33
    return self;                                                                                    // 34
  };                                                                                                // 35
                                                                                                    // 36
  inherits(errorClass, Error);                                                                      // 37
                                                                                                    // 38
  return errorClass;                                                                                // 39
};                                                                                                  // 40
                                                                                                    // 41
// This should probably be in the livedata package, but we don't want                               // 42
// to require you to use the livedata package to get it. Eventually we                              // 43
// should probably rename it to DDP.Error and put it back in the                                    // 44
// 'livedata' package (which we should rename to 'ddp' also.)                                       // 45
//                                                                                                  // 46
// Note: The DDP server assumes that Meteor.Error EJSON-serializes as an object                     // 47
// containing 'error' and optionally 'reason' and 'details'.                                        // 48
// The DDP client manually puts these into Meteor.Error objects. (We don't use                      // 49
// EJSON.addType here because the type is determined by location in the                             // 50
// protocol, not text on the wire.)                                                                 // 51
//                                                                                                  // 52
Meteor.Error = Meteor.makeErrorType(                                                                // 53
  "Meteor.Error",                                                                                   // 54
  function (error, reason, details) {                                                               // 55
    var self = this;                                                                                // 56
                                                                                                    // 57
    // Currently, a numeric code, likely similar to a HTTP code (eg,                                // 58
    // 404, 500). That is likely to change though.                                                  // 59
    self.error = error;                                                                             // 60
                                                                                                    // 61
    // Optional: A short human-readable summary of the error. Not                                   // 62
    // intended to be shown to end users, just developers. ("Not Found",                            // 63
    // "Internal Server Error")                                                                     // 64
    self.reason = reason;                                                                           // 65
                                                                                                    // 66
    // Optional: Additional information about the error, say for                                    // 67
    // debugging. It might be a (textual) stack trace if the server is                              // 68
    // willing to provide one. The corresponding thing in HTTP would be                             // 69
    // the body of a 404 or 500 response. (The difference is that we                                // 70
    // never expect this to be shown to end users, only developers, so                              // 71
    // it doesn't need to be pretty.)                                                               // 72
    self.details = details;                                                                         // 73
                                                                                                    // 74
    // This is what gets displayed at the top of a stack trace. Current                             // 75
    // format is "[404]" (if no reason is set) or "File not found [404]"                            // 76
    if (self.reason)                                                                                // 77
      self.message = self.reason + ' [' + self.error + ']';                                         // 78
    else                                                                                            // 79
      self.message = '[' + self.error + ']';                                                        // 80
  });                                                                                               // 81
                                                                                                    // 82
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/fiber_stubs_client.js                                                            //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// This file is a partial analogue to fiber_helpers.js, which allows the client                     // 1
// to use a queue too, and also to call noYieldsAllowed.                                            // 2
                                                                                                    // 3
// The client has no ability to yield, so noYieldsAllowed is a noop.                                // 4
//                                                                                                  // 5
Meteor._noYieldsAllowed = function (f) {                                                            // 6
  return f();                                                                                       // 7
};                                                                                                  // 8
                                                                                                    // 9
// An even simpler queue of tasks than the fiber-enabled one.  This one just                        // 10
// runs all the tasks when you call runTask or flush, synchronously.                                // 11
//                                                                                                  // 12
Meteor._SynchronousQueue = function () {                                                            // 13
  var self = this;                                                                                  // 14
  self._tasks = [];                                                                                 // 15
  self._running = false;                                                                            // 16
};                                                                                                  // 17
                                                                                                    // 18
_.extend(Meteor._SynchronousQueue.prototype, {                                                      // 19
  runTask: function (task) {                                                                        // 20
    var self = this;                                                                                // 21
    if (!self.safeToRunTask())                                                                      // 22
      throw new Error("Could not synchronously run a task from a running task");                    // 23
    self._tasks.push(task);                                                                         // 24
    var tasks = self._tasks;                                                                        // 25
    self._tasks = [];                                                                               // 26
    self._running = true;                                                                           // 27
    try {                                                                                           // 28
      while (!_.isEmpty(tasks)) {                                                                   // 29
        var t = tasks.shift();                                                                      // 30
        try {                                                                                       // 31
          t();                                                                                      // 32
        } catch (e) {                                                                               // 33
          if (_.isEmpty(tasks)) {                                                                   // 34
            // this was the last task, that is, the one we're calling runTask                       // 35
            // for.                                                                                 // 36
            throw e;                                                                                // 37
          } else {                                                                                  // 38
            Meteor._debug("Exception in queued task: " + e.stack);                                  // 39
          }                                                                                         // 40
        }                                                                                           // 41
      }                                                                                             // 42
    } finally {                                                                                     // 43
      self._running = false;                                                                        // 44
    }                                                                                               // 45
  },                                                                                                // 46
                                                                                                    // 47
  queueTask: function (task) {                                                                      // 48
    var self = this;                                                                                // 49
    var wasEmpty = _.isEmpty(self._tasks);                                                          // 50
    self._tasks.push(task);                                                                         // 51
    // Intentionally not using Meteor.setTimeout, because it doesn't like runing                    // 52
    // in stubs for now.                                                                            // 53
    if (wasEmpty)                                                                                   // 54
      setTimeout(_.bind(self.flush, self), 0);                                                      // 55
  },                                                                                                // 56
                                                                                                    // 57
  flush: function () {                                                                              // 58
    var self = this;                                                                                // 59
    self.runTask(function () {});                                                                   // 60
  },                                                                                                // 61
                                                                                                    // 62
  drain: function () {                                                                              // 63
    var self = this;                                                                                // 64
    if (!self.safeToRunTask())                                                                      // 65
      return;                                                                                       // 66
    while (!_.isEmpty(self._tasks)) {                                                               // 67
      self.flush();                                                                                 // 68
    }                                                                                               // 69
  },                                                                                                // 70
                                                                                                    // 71
  safeToRunTask: function () {                                                                      // 72
    var self = this;                                                                                // 73
    return !self._running;                                                                          // 74
  }                                                                                                 // 75
});                                                                                                 // 76
                                                                                                    // 77
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/startup_client.js                                                                //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
var queue = [];                                                                                     // 1
var loaded = false;                                                                                 // 2
                                                                                                    // 3
Meteor.startup = function (cb) {                                                                    // 4
  if (loaded)                                                                                       // 5
    cb();                                                                                           // 6
  else                                                                                              // 7
    queue.push(cb);                                                                                 // 8
};                                                                                                  // 9
                                                                                                    // 10
Meteor._start = function () {                                                                       // 11
  while (queue.length > 0)                                                                          // 12
    (queue.shift())();                                                                              // 13
  loaded = true;                                                                                    // 14
};                                                                                                  // 15
                                                                                                    // 16
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/debug.js                                                                         //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
var suppress = 0;                                                                                   // 1
                                                                                                    // 2
// replacement for console.log. This is a temporary API. We should                                  // 3
// provide a real logging API soon (possibly just a polyfill for                                    // 4
// console?)                                                                                        // 5
//                                                                                                  // 6
// NOTE: this is used on the server to print the warning about                                      // 7
// having autopublish enabled when you probably meant to turn it                                    // 8
// off. it's not really the proper use of something called                                          // 9
// _debug. the intent is for this message to go to the terminal and                                 // 10
// be very visible. if you change _debug to go someplace else, etc,                                 // 11
// please fix the autopublish code to do something reasonable.                                      // 12
//                                                                                                  // 13
Meteor._debug = function (/* arguments */) {                                                        // 14
  if (suppress) {                                                                                   // 15
    suppress--;                                                                                     // 16
    return;                                                                                         // 17
  }                                                                                                 // 18
  if (typeof console !== 'undefined' &&                                                             // 19
      typeof console.log !== 'undefined') {                                                         // 20
    if (arguments.length == 0) { // IE Companion breaks otherwise                                   // 21
      // IE10 PP4 requires at least one argument                                                    // 22
      console.log('');                                                                              // 23
    } else {                                                                                        // 24
      // IE doesn't have console.log.apply, it's not a real Object.                                 // 25
      // http://stackoverflow.com/questions/5538972/console-log-apply-not-working-in-ie9            // 26
      // http://patik.com/blog/complete-cross-browser-console-log/                                  // 27
      if (typeof console.log.apply === "function") {                                                // 28
        // Most browsers                                                                            // 29
                                                                                                    // 30
        // Chrome and Safari only hyperlink URLs to source files in first argument of               // 31
        // console.log, so try to call it with one argument if possible.                            // 32
        // Approach taken here: If all arguments are strings, join them on space.                   // 33
        // See https://github.com/meteor/meteor/pull/732#issuecomment-13975991                      // 34
        var allArgumentsOfTypeString = true;                                                        // 35
        for (var i = 0; i < arguments.length; i++)                                                  // 36
          if (typeof arguments[i] !== "string")                                                     // 37
            allArgumentsOfTypeString = false;                                                       // 38
                                                                                                    // 39
        if (allArgumentsOfTypeString)                                                               // 40
          console.log.apply(console, [Array.prototype.join.call(arguments, " ")]);                  // 41
        else                                                                                        // 42
          console.log.apply(console, arguments);                                                    // 43
                                                                                                    // 44
      } else if (typeof Function.prototype.bind === "function") {                                   // 45
        // IE9                                                                                      // 46
        var log = Function.prototype.bind.call(console.log, console);                               // 47
        log.apply(console, arguments);                                                              // 48
      } else {                                                                                      // 49
        // IE8                                                                                      // 50
        Function.prototype.call.call(console.log, console, Array.prototype.slice.call(arguments));  // 51
      }                                                                                             // 52
    }                                                                                               // 53
  }                                                                                                 // 54
};                                                                                                  // 55
                                                                                                    // 56
// Suppress the next 'count' Meteor._debug messsages. Use this to                                   // 57
// stop tests from spamming the console.                                                            // 58
//                                                                                                  // 59
Meteor._suppress_log = function (count) {                                                           // 60
  suppress += count;                                                                                // 61
};                                                                                                  // 62
                                                                                                    // 63
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/dynamics_browser.js                                                              //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
// Simple implementation of dynamic scoping, for use in browsers                                    // 1
                                                                                                    // 2
var nextSlot = 0;                                                                                   // 3
var currentValues = [];                                                                             // 4
                                                                                                    // 5
Meteor.EnvironmentVariable = function () {                                                          // 6
  this.slot = nextSlot++;                                                                           // 7
};                                                                                                  // 8
                                                                                                    // 9
_.extend(Meteor.EnvironmentVariable.prototype, {                                                    // 10
  get: function () {                                                                                // 11
    return currentValues[this.slot];                                                                // 12
  },                                                                                                // 13
                                                                                                    // 14
  withValue: function (value, func) {                                                               // 15
    var saved = currentValues[this.slot];                                                           // 16
    try {                                                                                           // 17
      currentValues[this.slot] = value;                                                             // 18
      var ret = func();                                                                             // 19
    } finally {                                                                                     // 20
      currentValues[this.slot] = saved;                                                             // 21
    }                                                                                               // 22
    return ret;                                                                                     // 23
  }                                                                                                 // 24
});                                                                                                 // 25
                                                                                                    // 26
Meteor.bindEnvironment = function (func, onException, _this) {                                      // 27
  // needed in order to be able to create closures inside func and                                  // 28
  // have the closed variables not change back to their original                                    // 29
  // values                                                                                         // 30
  var boundValues = _.clone(currentValues);                                                         // 31
                                                                                                    // 32
  if (!onException)                                                                                 // 33
    throw new Error("onException must be supplied");                                                // 34
                                                                                                    // 35
  return function (/* arguments */) {                                                               // 36
    var savedValues = currentValues;                                                                // 37
    try {                                                                                           // 38
      currentValues = boundValues;                                                                  // 39
      var ret = func.apply(_this, _.toArray(arguments));                                            // 40
    } catch (e) {                                                                                   // 41
      onException(e);                                                                               // 42
    } finally {                                                                                     // 43
      currentValues = savedValues;                                                                  // 44
    }                                                                                               // 45
    return ret;                                                                                     // 46
  };                                                                                                // 47
};                                                                                                  // 48
                                                                                                    // 49
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                  //
// packages/meteor/url_common.js                                                                    //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                    //
Meteor.absoluteUrl = function (path, options) {                                                     // 1
  // path is optional                                                                               // 2
  if (!options && typeof path === 'object') {                                                       // 3
    options = path;                                                                                 // 4
    path = undefined;                                                                               // 5
  }                                                                                                 // 6
  // merge options with defaults                                                                    // 7
  options = _.extend({}, Meteor.absoluteUrl.defaultOptions, options || {});                         // 8
                                                                                                    // 9
  var url = options.rootUrl;                                                                        // 10
  if (!url)                                                                                         // 11
    throw new Error("Must pass options.rootUrl or set ROOT_URL in the server environment");         // 12
                                                                                                    // 13
  if (!/^http[s]?:\/\//i.test(url)) // url starts with 'http://' or 'https://'                      // 14
    url = 'http://' + url; // we will later fix to https if options.secure is set                   // 15
                                                                                                    // 16
  if (!/\/$/.test(url)) // url ends with '/'                                                        // 17
    url += '/';                                                                                     // 18
                                                                                                    // 19
  if (path)                                                                                         // 20
    url += path;                                                                                    // 21
                                                                                                    // 22
  // turn http to http if secure option is set, and we're not talking                               // 23
  // to localhost.                                                                                  // 24
  if (options.secure &&                                                                             // 25
      /^http:/.test(url) && // url starts with 'http:'                                              // 26
      !/http:\/\/localhost[:\/]/.test(url) && // doesn't match localhost                            // 27
      !/http:\/\/127\.0\.0\.1[:\/]/.test(url)) // or 127.0.0.1                                      // 28
    url = url.replace(/^http:/, 'https:');                                                          // 29
                                                                                                    // 30
  if (options.replaceLocalhost)                                                                     // 31
    url = url.replace(/^http:\/\/localhost([:\/].*)/, 'http://127.0.0.1$1');                        // 32
                                                                                                    // 33
  return url;                                                                                       // 34
};                                                                                                  // 35
                                                                                                    // 36
// allow later packages to override default options                                                 // 37
Meteor.absoluteUrl.defaultOptions = { };                                                            // 38
if (typeof __meteor_runtime_config__ === "object" &&                                                // 39
    __meteor_runtime_config__.ROOT_URL)                                                             // 40
  Meteor.absoluteUrl.defaultOptions.rootUrl = __meteor_runtime_config__.ROOT_URL;                   // 41
                                                                                                    // 42
                                                                                                    // 43
Meteor._relativeToSiteRootUrl = function (link) {                                                   // 44
  if (typeof __meteor_runtime_config__ === "object" &&                                              // 45
      link.substr(0, 1) === "/")                                                                    // 46
    link = (__meteor_runtime_config__.ROOT_URL_PATH_PREFIX || "") + link;                           // 47
  return link;                                                                                      // 48
};                                                                                                  // 49
                                                                                                    // 50
//////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.meteor = {
  Meteor: Meteor
};

})();

//# sourceMappingURL=ab878d29a26fb3a09ef45687aef34fab3f1c2e0c.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var Deps;

(function () {

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// packages/deps/deps.js                                                        //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
                                                                                //
Deps = {};                                                                      // 1
Deps.active = false;                                                            // 2
Deps.currentComputation = null;                                                 // 3
                                                                                // 4
var setCurrentComputation = function (c) {                                      // 5
  Deps.currentComputation = c;                                                  // 6
  Deps.active = !! c;                                                           // 7
};                                                                              // 8
                                                                                // 9
var _debugFunc = function () {                                                  // 10
  // lazy evaluation because `Meteor` does not exist right away                 // 11
  return (typeof Meteor !== "undefined" ? Meteor._debug :                       // 12
          ((typeof console !== "undefined") && console.log ? console.log :      // 13
           function () {}));                                                    // 14
};                                                                              // 15
                                                                                // 16
var nextId = 1;                                                                 // 17
// computations whose callbacks we should call at flush time                    // 18
var pendingComputations = [];                                                   // 19
// `true` if a Deps.flush is scheduled, or if we are in Deps.flush now          // 20
var willFlush = false;                                                          // 21
// `true` if we are in Deps.flush now                                           // 22
var inFlush = false;                                                            // 23
// `true` if we are computing a computation now, either first time              // 24
// or recompute.  This matches Deps.active unless we are inside                 // 25
// Deps.nonreactive, which nullfies currentComputation even though              // 26
// an enclosing computation may still be running.                               // 27
var inCompute = false;                                                          // 28
                                                                                // 29
var afterFlushCallbacks = [];                                                   // 30
                                                                                // 31
var requireFlush = function () {                                                // 32
  if (! willFlush) {                                                            // 33
    setTimeout(Deps.flush, 0);                                                  // 34
    willFlush = true;                                                           // 35
  }                                                                             // 36
};                                                                              // 37
                                                                                // 38
// Deps.Computation constructor is visible but private                          // 39
// (throws an error if you try to call it)                                      // 40
var constructingComputation = false;                                            // 41
                                                                                // 42
Deps.Computation = function (f, parent) {                                       // 43
  if (! constructingComputation)                                                // 44
    throw new Error(                                                            // 45
      "Deps.Computation constructor is private; use Deps.autorun");             // 46
  constructingComputation = false;                                              // 47
                                                                                // 48
  var self = this;                                                              // 49
  self.stopped = false;                                                         // 50
  self.invalidated = false;                                                     // 51
  self.firstRun = true;                                                         // 52
                                                                                // 53
  self._id = nextId++;                                                          // 54
  self._onInvalidateCallbacks = [];                                             // 55
  // the plan is at some point to use the parent relation                       // 56
  // to constrain the order that computations are processed                     // 57
  self._parent = parent;                                                        // 58
  self._func = f;                                                               // 59
  self._recomputing = false;                                                    // 60
                                                                                // 61
  var errored = true;                                                           // 62
  try {                                                                         // 63
    self._compute();                                                            // 64
    errored = false;                                                            // 65
  } finally {                                                                   // 66
    self.firstRun = false;                                                      // 67
    if (errored)                                                                // 68
      self.stop();                                                              // 69
  }                                                                             // 70
};                                                                              // 71
                                                                                // 72
_.extend(Deps.Computation.prototype, {                                          // 73
                                                                                // 74
  onInvalidate: function (f) {                                                  // 75
    var self = this;                                                            // 76
                                                                                // 77
    if (typeof f !== 'function')                                                // 78
      throw new Error("onInvalidate requires a function");                      // 79
                                                                                // 80
    var g = function () {                                                       // 81
      Deps.nonreactive(function () {                                            // 82
        f(self);                                                                // 83
      });                                                                       // 84
    };                                                                          // 85
                                                                                // 86
    if (self.invalidated)                                                       // 87
      g();                                                                      // 88
    else                                                                        // 89
      self._onInvalidateCallbacks.push(g);                                      // 90
  },                                                                            // 91
                                                                                // 92
  invalidate: function () {                                                     // 93
    var self = this;                                                            // 94
    if (! self.invalidated) {                                                   // 95
      // if we're currently in _recompute(), don't enqueue                      // 96
      // ourselves, since we'll rerun immediately anyway.                       // 97
      if (! self._recomputing && ! self.stopped) {                              // 98
        requireFlush();                                                         // 99
        pendingComputations.push(this);                                         // 100
      }                                                                         // 101
                                                                                // 102
      self.invalidated = true;                                                  // 103
                                                                                // 104
      // callbacks can't add callbacks, because                                 // 105
      // self.invalidated === true.                                             // 106
      for(var i = 0, f; f = self._onInvalidateCallbacks[i]; i++)                // 107
        f(); // already bound with self as argument                             // 108
      self._onInvalidateCallbacks = [];                                         // 109
    }                                                                           // 110
  },                                                                            // 111
                                                                                // 112
  stop: function () {                                                           // 113
    if (! this.stopped) {                                                       // 114
      this.stopped = true;                                                      // 115
      this.invalidate();                                                        // 116
    }                                                                           // 117
  },                                                                            // 118
                                                                                // 119
  _compute: function () {                                                       // 120
    var self = this;                                                            // 121
    self.invalidated = false;                                                   // 122
                                                                                // 123
    var previous = Deps.currentComputation;                                     // 124
    setCurrentComputation(self);                                                // 125
    var previousInCompute = inCompute;                                          // 126
    inCompute = true;                                                           // 127
    try {                                                                       // 128
      self._func(self);                                                         // 129
    } finally {                                                                 // 130
      setCurrentComputation(previous);                                          // 131
      inCompute = false;                                                        // 132
    }                                                                           // 133
  },                                                                            // 134
                                                                                // 135
  _recompute: function () {                                                     // 136
    var self = this;                                                            // 137
                                                                                // 138
    self._recomputing = true;                                                   // 139
    while (self.invalidated && ! self.stopped) {                                // 140
      try {                                                                     // 141
        self._compute();                                                        // 142
      } catch (e) {                                                             // 143
        _debugFunc()("Exception from Deps recompute:", e.stack || e.message);   // 144
      }                                                                         // 145
      // If _compute() invalidated us, we run again immediately.                // 146
      // A computation that invalidates itself indefinitely is an               // 147
      // infinite loop, of course.                                              // 148
      //                                                                        // 149
      // We could put an iteration counter here and catch run-away              // 150
      // loops.                                                                 // 151
    }                                                                           // 152
    self._recomputing = false;                                                  // 153
  }                                                                             // 154
});                                                                             // 155
                                                                                // 156
Deps.Dependency = function () {                                                 // 157
  this._dependentsById = {};                                                    // 158
};                                                                              // 159
                                                                                // 160
_.extend(Deps.Dependency.prototype, {                                           // 161
  // Adds `computation` to this set if it is not already                        // 162
  // present.  Returns true if `computation` is a new member of the set.        // 163
  // If no argument, defaults to currentComputation, or does nothing            // 164
  // if there is no currentComputation.                                         // 165
  depend: function (computation) {                                              // 166
    if (! computation) {                                                        // 167
      if (! Deps.active)                                                        // 168
        return false;                                                           // 169
                                                                                // 170
      computation = Deps.currentComputation;                                    // 171
    }                                                                           // 172
    var self = this;                                                            // 173
    var id = computation._id;                                                   // 174
    if (! (id in self._dependentsById)) {                                       // 175
      self._dependentsById[id] = computation;                                   // 176
      computation.onInvalidate(function () {                                    // 177
        delete self._dependentsById[id];                                        // 178
      });                                                                       // 179
      return true;                                                              // 180
    }                                                                           // 181
    return false;                                                               // 182
  },                                                                            // 183
  changed: function () {                                                        // 184
    var self = this;                                                            // 185
    for (var id in self._dependentsById)                                        // 186
      self._dependentsById[id].invalidate();                                    // 187
  },                                                                            // 188
  hasDependents: function () {                                                  // 189
    var self = this;                                                            // 190
    for(var id in self._dependentsById)                                         // 191
      return true;                                                              // 192
    return false;                                                               // 193
  }                                                                             // 194
});                                                                             // 195
                                                                                // 196
_.extend(Deps, {                                                                // 197
  flush: function () {                                                          // 198
    // Nested flush could plausibly happen if, say, a flush causes              // 199
    // DOM mutation, which causes a "blur" event, which runs an                 // 200
    // app event handler that calls Deps.flush.  At the moment                  // 201
    // Spark blocks event handlers during DOM mutation anyway,                  // 202
    // because the LiveRange tree isn't valid.  And we don't have               // 203
    // any useful notion of a nested flush.                                     // 204
    //                                                                          // 205
    // https://app.asana.com/0/159908330244/385138233856                        // 206
    if (inFlush)                                                                // 207
      throw new Error("Can't call Deps.flush while flushing");                  // 208
                                                                                // 209
    if (inCompute)                                                              // 210
      throw new Error("Can't flush inside Deps.autorun");                       // 211
                                                                                // 212
    inFlush = true;                                                             // 213
    willFlush = true;                                                           // 214
                                                                                // 215
    while (pendingComputations.length ||                                        // 216
           afterFlushCallbacks.length) {                                        // 217
                                                                                // 218
      // recompute all pending computations                                     // 219
      var comps = pendingComputations;                                          // 220
      pendingComputations = [];                                                 // 221
                                                                                // 222
      for (var i = 0, comp; comp = comps[i]; i++)                               // 223
        comp._recompute();                                                      // 224
                                                                                // 225
      if (afterFlushCallbacks.length) {                                         // 226
        // call one afterFlush callback, which may                              // 227
        // invalidate more computations                                         // 228
        var func = afterFlushCallbacks.shift();                                 // 229
        try {                                                                   // 230
          func();                                                               // 231
        } catch (e) {                                                           // 232
          _debugFunc()("Exception from Deps afterFlush function:",              // 233
                       e.stack || e.message);                                   // 234
        }                                                                       // 235
      }                                                                         // 236
    }                                                                           // 237
                                                                                // 238
    inFlush = false;                                                            // 239
    willFlush = false;                                                          // 240
  },                                                                            // 241
                                                                                // 242
  // Run f(). Record its dependencies. Rerun it whenever the                    // 243
  // dependencies change.                                                       // 244
  //                                                                            // 245
  // Returns a new Computation, which is also passed to f.                      // 246
  //                                                                            // 247
  // Links the computation to the current computation                           // 248
  // so that it is stopped if the current computation is invalidated.           // 249
  autorun: function (f) {                                                       // 250
    if (typeof f !== 'function')                                                // 251
      throw new Error('Deps.autorun requires a function argument');             // 252
                                                                                // 253
    constructingComputation = true;                                             // 254
    var c = new Deps.Computation(f, Deps.currentComputation);                   // 255
                                                                                // 256
    if (Deps.active)                                                            // 257
      Deps.onInvalidate(function () {                                           // 258
        c.stop();                                                               // 259
      });                                                                       // 260
                                                                                // 261
    return c;                                                                   // 262
  },                                                                            // 263
                                                                                // 264
  // Run `f` with no current computation, returning the return value            // 265
  // of `f`.  Used to turn off reactivity for the duration of `f`,              // 266
  // so that reactive data sources accessed by `f` will not result in any       // 267
  // computations being invalidated.                                            // 268
  nonreactive: function (f) {                                                   // 269
    var previous = Deps.currentComputation;                                     // 270
    setCurrentComputation(null);                                                // 271
    try {                                                                       // 272
      return f();                                                               // 273
    } finally {                                                                 // 274
      setCurrentComputation(previous);                                          // 275
    }                                                                           // 276
  },                                                                            // 277
                                                                                // 278
  // Wrap `f` so that it is always run nonreactively.                           // 279
  _makeNonreactive: function (f) {                                              // 280
    if (f.$isNonreactive) // avoid multiple layers of wrapping.                 // 281
      return f;                                                                 // 282
    var nonreactiveVersion = function (/*arguments*/) {                         // 283
      var self = this;                                                          // 284
      var args = _.toArray(arguments);                                          // 285
      var ret;                                                                  // 286
      Deps.nonreactive(function () {                                            // 287
        ret = f.apply(self, args);                                              // 288
      });                                                                       // 289
      return ret;                                                               // 290
    };                                                                          // 291
    nonreactiveVersion.$isNonreactive = true;                                   // 292
    return nonreactiveVersion;                                                  // 293
  },                                                                            // 294
                                                                                // 295
  onInvalidate: function (f) {                                                  // 296
    if (! Deps.active)                                                          // 297
      throw new Error("Deps.onInvalidate requires a currentComputation");       // 298
                                                                                // 299
    Deps.currentComputation.onInvalidate(f);                                    // 300
  },                                                                            // 301
                                                                                // 302
  afterFlush: function (f) {                                                    // 303
    afterFlushCallbacks.push(f);                                                // 304
    requireFlush();                                                             // 305
  }                                                                             // 306
});                                                                             // 307
                                                                                // 308
//////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// packages/deps/deprecated.js                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
                                                                                //
// Deprecated (Deps-recated?) functions.                                        // 1
                                                                                // 2
// These functions used to be on the Meteor object (and worked slightly         // 3
// differently).                                                                // 4
// XXX COMPAT WITH 0.5.7                                                        // 5
Meteor.flush = Deps.flush;                                                      // 6
Meteor.autorun = Deps.autorun;                                                  // 7
                                                                                // 8
// We used to require a special "autosubscribe" call to reactively subscribe to // 9
// things. Now, it works with autorun.                                          // 10
// XXX COMPAT WITH 0.5.4                                                        // 11
Meteor.autosubscribe = Deps.autorun;                                            // 12
                                                                                // 13
// This Deps API briefly existed in 0.5.8 and 0.5.9                             // 14
// XXX COMPAT WITH 0.5.9                                                        // 15
Deps.depend = function (d) {                                                    // 16
  return d.depend();                                                            // 17
};                                                                              // 18
                                                                                // 19
//////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.deps = {
  Deps: Deps
};

})();

//# sourceMappingURL=5ac28feec1f3e0539889ecde598dd9d01e408b41.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;

/* Package-scope variables */
var JSON;

(function () {

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// packages/json/json_native.js                                           //
//                                                                        //
////////////////////////////////////////////////////////////////////////////
                                                                          //
// Do we already have a global JSON object? Export it as our JSON object. // 1
if (this.JSON)                                                            // 2
  JSON = this.JSON;                                                       // 3
                                                                          // 4
////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.json = {
  JSON: JSON
};

})();

//# sourceMappingURL=e84abe078c21ceca23ffed270b7c3af779da0462.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var JSON = Package.json.JSON;
var _ = Package.underscore._;

/* Package-scope variables */
var EJSON, EJSONTest, base64Encode, base64Decode;

(function () {

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// packages/ejson/ejson.js                                                              //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
                                                                                        //
EJSON = {};                                                                             // 1
EJSONTest = {};                                                                         // 2
                                                                                        // 3
var customTypes = {};                                                                   // 4
// Add a custom type, using a method of your choice to get to and                       // 5
// from a basic JSON-able representation.  The factory argument                         // 6
// is a function of JSON-able --> your object                                           // 7
// The type you add must have:                                                          // 8
// - A clone() method, so that Meteor can deep-copy it when necessary.                  // 9
// - A equals() method, so that Meteor can compare it                                   // 10
// - A toJSONValue() method, so that Meteor can serialize it                            // 11
// - a typeName() method, to show how to look it up in our type table.                  // 12
// It is okay if these methods are monkey-patched on.                                   // 13
//                                                                                      // 14
EJSON.addType = function (name, factory) {                                              // 15
  if (_.has(customTypes, name))                                                         // 16
    throw new Error("Type " + name + " already present");                               // 17
  customTypes[name] = factory;                                                          // 18
};                                                                                      // 19
                                                                                        // 20
var builtinConverters = [                                                               // 21
  { // Date                                                                             // 22
    matchJSONValue: function (obj) {                                                    // 23
      return _.has(obj, '$date') && _.size(obj) === 1;                                  // 24
    },                                                                                  // 25
    matchObject: function (obj) {                                                       // 26
      return obj instanceof Date;                                                       // 27
    },                                                                                  // 28
    toJSONValue: function (obj) {                                                       // 29
      return {$date: obj.getTime()};                                                    // 30
    },                                                                                  // 31
    fromJSONValue: function (obj) {                                                     // 32
      return new Date(obj.$date);                                                       // 33
    }                                                                                   // 34
  },                                                                                    // 35
  { // Binary                                                                           // 36
    matchJSONValue: function (obj) {                                                    // 37
      return _.has(obj, '$binary') && _.size(obj) === 1;                                // 38
    },                                                                                  // 39
    matchObject: function (obj) {                                                       // 40
      return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array             // 41
        || (obj && _.has(obj, '$Uint8ArrayPolyfill'));                                  // 42
    },                                                                                  // 43
    toJSONValue: function (obj) {                                                       // 44
      return {$binary: base64Encode(obj)};                                              // 45
    },                                                                                  // 46
    fromJSONValue: function (obj) {                                                     // 47
      return base64Decode(obj.$binary);                                                 // 48
    }                                                                                   // 49
  },                                                                                    // 50
  { // Escaping one level                                                               // 51
    matchJSONValue: function (obj) {                                                    // 52
      return _.has(obj, '$escape') && _.size(obj) === 1;                                // 53
    },                                                                                  // 54
    matchObject: function (obj) {                                                       // 55
      if (_.isEmpty(obj) || _.size(obj) > 2) {                                          // 56
        return false;                                                                   // 57
      }                                                                                 // 58
      return _.any(builtinConverters, function (converter) {                            // 59
        return converter.matchJSONValue(obj);                                           // 60
      });                                                                               // 61
    },                                                                                  // 62
    toJSONValue: function (obj) {                                                       // 63
      var newObj = {};                                                                  // 64
      _.each(obj, function (value, key) {                                               // 65
        newObj[key] = EJSON.toJSONValue(value);                                         // 66
      });                                                                               // 67
      return {$escape: newObj};                                                         // 68
    },                                                                                  // 69
    fromJSONValue: function (obj) {                                                     // 70
      var newObj = {};                                                                  // 71
      _.each(obj.$escape, function (value, key) {                                       // 72
        newObj[key] = EJSON.fromJSONValue(value);                                       // 73
      });                                                                               // 74
      return newObj;                                                                    // 75
    }                                                                                   // 76
  },                                                                                    // 77
  { // Custom                                                                           // 78
    matchJSONValue: function (obj) {                                                    // 79
      return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;          // 80
    },                                                                                  // 81
    matchObject: function (obj) {                                                       // 82
      return EJSON._isCustomType(obj);                                                  // 83
    },                                                                                  // 84
    toJSONValue: function (obj) {                                                       // 85
      return {$type: obj.typeName(), $value: obj.toJSONValue()};                        // 86
    },                                                                                  // 87
    fromJSONValue: function (obj) {                                                     // 88
      var typeName = obj.$type;                                                         // 89
      var converter = customTypes[typeName];                                            // 90
      return converter(obj.$value);                                                     // 91
    }                                                                                   // 92
  }                                                                                     // 93
];                                                                                      // 94
                                                                                        // 95
EJSON._isCustomType = function (obj) {                                                  // 96
  return obj &&                                                                         // 97
    typeof obj.toJSONValue === 'function' &&                                            // 98
    typeof obj.typeName === 'function' &&                                               // 99
    _.has(customTypes, obj.typeName());                                                 // 100
};                                                                                      // 101
                                                                                        // 102
                                                                                        // 103
// for both arrays and objects, in-place modification.                                  // 104
var adjustTypesToJSONValue =                                                            // 105
EJSON._adjustTypesToJSONValue = function (obj) {                                        // 106
  if (obj === null)                                                                     // 107
    return null;                                                                        // 108
  var maybeChanged = toJSONValueHelper(obj);                                            // 109
  if (maybeChanged !== undefined)                                                       // 110
    return maybeChanged;                                                                // 111
  _.each(obj, function (value, key) {                                                   // 112
    if (typeof value !== 'object' && value !== undefined)                               // 113
      return; // continue                                                               // 114
    var changed = toJSONValueHelper(value);                                             // 115
    if (changed) {                                                                      // 116
      obj[key] = changed;                                                               // 117
      return; // on to the next key                                                     // 118
    }                                                                                   // 119
    // if we get here, value is an object but not adjustable                            // 120
    // at this level.  recurse.                                                         // 121
    adjustTypesToJSONValue(value);                                                      // 122
  });                                                                                   // 123
  return obj;                                                                           // 124
};                                                                                      // 125
                                                                                        // 126
// Either return the JSON-compatible version of the argument, or undefined (if          // 127
// the item isn't itself replaceable, but maybe some fields in it are)                  // 128
var toJSONValueHelper = function (item) {                                               // 129
  for (var i = 0; i < builtinConverters.length; i++) {                                  // 130
    var converter = builtinConverters[i];                                               // 131
    if (converter.matchObject(item)) {                                                  // 132
      return converter.toJSONValue(item);                                               // 133
    }                                                                                   // 134
  }                                                                                     // 135
  return undefined;                                                                     // 136
};                                                                                      // 137
                                                                                        // 138
EJSON.toJSONValue = function (item) {                                                   // 139
  var changed = toJSONValueHelper(item);                                                // 140
  if (changed !== undefined)                                                            // 141
    return changed;                                                                     // 142
  if (typeof item === 'object') {                                                       // 143
    item = EJSON.clone(item);                                                           // 144
    adjustTypesToJSONValue(item);                                                       // 145
  }                                                                                     // 146
  return item;                                                                          // 147
};                                                                                      // 148
                                                                                        // 149
// for both arrays and objects. Tries its best to just                                  // 150
// use the object you hand it, but may return something                                 // 151
// different if the object you hand it itself needs changing.                           // 152
//                                                                                      // 153
var adjustTypesFromJSONValue =                                                          // 154
EJSON._adjustTypesFromJSONValue = function (obj) {                                      // 155
  if (obj === null)                                                                     // 156
    return null;                                                                        // 157
  var maybeChanged = fromJSONValueHelper(obj);                                          // 158
  if (maybeChanged !== obj)                                                             // 159
    return maybeChanged;                                                                // 160
  _.each(obj, function (value, key) {                                                   // 161
    if (typeof value === 'object') {                                                    // 162
      var changed = fromJSONValueHelper(value);                                         // 163
      if (value !== changed) {                                                          // 164
        obj[key] = changed;                                                             // 165
        return;                                                                         // 166
      }                                                                                 // 167
      // if we get here, value is an object but not adjustable                          // 168
      // at this level.  recurse.                                                       // 169
      adjustTypesFromJSONValue(value);                                                  // 170
    }                                                                                   // 171
  });                                                                                   // 172
  return obj;                                                                           // 173
};                                                                                      // 174
                                                                                        // 175
// Either return the argument changed to have the non-json                              // 176
// rep of itself (the Object version) or the argument itself.                           // 177
                                                                                        // 178
// DOES NOT RECURSE.  For actually getting the fully-changed value, use                 // 179
// EJSON.fromJSONValue                                                                  // 180
var fromJSONValueHelper = function (value) {                                            // 181
  if (typeof value === 'object' && value !== null) {                                    // 182
    if (_.size(value) <= 2                                                              // 183
        && _.all(value, function (v, k) {                                               // 184
          return typeof k === 'string' && k.substr(0, 1) === '$';                       // 185
        })) {                                                                           // 186
      for (var i = 0; i < builtinConverters.length; i++) {                              // 187
        var converter = builtinConverters[i];                                           // 188
        if (converter.matchJSONValue(value)) {                                          // 189
          return converter.fromJSONValue(value);                                        // 190
        }                                                                               // 191
      }                                                                                 // 192
    }                                                                                   // 193
  }                                                                                     // 194
  return value;                                                                         // 195
};                                                                                      // 196
                                                                                        // 197
EJSON.fromJSONValue = function (item) {                                                 // 198
  var changed = fromJSONValueHelper(item);                                              // 199
  if (changed === item && typeof item === 'object') {                                   // 200
    item = EJSON.clone(item);                                                           // 201
    adjustTypesFromJSONValue(item);                                                     // 202
    return item;                                                                        // 203
  } else {                                                                              // 204
    return changed;                                                                     // 205
  }                                                                                     // 206
};                                                                                      // 207
                                                                                        // 208
EJSON.stringify = function (item) {                                                     // 209
  return JSON.stringify(EJSON.toJSONValue(item));                                       // 210
};                                                                                      // 211
                                                                                        // 212
EJSON.parse = function (item) {                                                         // 213
  return EJSON.fromJSONValue(JSON.parse(item));                                         // 214
};                                                                                      // 215
                                                                                        // 216
EJSON.isBinary = function (obj) {                                                       // 217
  return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||         // 218
    (obj && obj.$Uint8ArrayPolyfill));                                                  // 219
};                                                                                      // 220
                                                                                        // 221
EJSON.equals = function (a, b, options) {                                               // 222
  var i;                                                                                // 223
  var keyOrderSensitive = !!(options && options.keyOrderSensitive);                     // 224
  if (a === b)                                                                          // 225
    return true;                                                                        // 226
  if (!a || !b) // if either one is falsy, they'd have to be === to be equal            // 227
    return false;                                                                       // 228
  if (!(typeof a === 'object' && typeof b === 'object'))                                // 229
    return false;                                                                       // 230
  if (a instanceof Date && b instanceof Date)                                           // 231
    return a.valueOf() === b.valueOf();                                                 // 232
  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {                                         // 233
    if (a.length !== b.length)                                                          // 234
      return false;                                                                     // 235
    for (i = 0; i < a.length; i++) {                                                    // 236
      if (a[i] !== b[i])                                                                // 237
        return false;                                                                   // 238
    }                                                                                   // 239
    return true;                                                                        // 240
  }                                                                                     // 241
  if (typeof (a.equals) === 'function')                                                 // 242
    return a.equals(b, options);                                                        // 243
  if (a instanceof Array) {                                                             // 244
    if (!(b instanceof Array))                                                          // 245
      return false;                                                                     // 246
    if (a.length !== b.length)                                                          // 247
      return false;                                                                     // 248
    for (i = 0; i < a.length; i++) {                                                    // 249
      if (!EJSON.equals(a[i], b[i], options))                                           // 250
        return false;                                                                   // 251
    }                                                                                   // 252
    return true;                                                                        // 253
  }                                                                                     // 254
  // fall back to structural equality of objects                                        // 255
  var ret;                                                                              // 256
  if (keyOrderSensitive) {                                                              // 257
    var bKeys = [];                                                                     // 258
    _.each(b, function (val, x) {                                                       // 259
        bKeys.push(x);                                                                  // 260
    });                                                                                 // 261
    i = 0;                                                                              // 262
    ret = _.all(a, function (val, x) {                                                  // 263
      if (i >= bKeys.length) {                                                          // 264
        return false;                                                                   // 265
      }                                                                                 // 266
      if (x !== bKeys[i]) {                                                             // 267
        return false;                                                                   // 268
      }                                                                                 // 269
      if (!EJSON.equals(val, b[bKeys[i]], options)) {                                   // 270
        return false;                                                                   // 271
      }                                                                                 // 272
      i++;                                                                              // 273
      return true;                                                                      // 274
    });                                                                                 // 275
    return ret && i === bKeys.length;                                                   // 276
  } else {                                                                              // 277
    i = 0;                                                                              // 278
    ret = _.all(a, function (val, key) {                                                // 279
      if (!_.has(b, key)) {                                                             // 280
        return false;                                                                   // 281
      }                                                                                 // 282
      if (!EJSON.equals(val, b[key], options)) {                                        // 283
        return false;                                                                   // 284
      }                                                                                 // 285
      i++;                                                                              // 286
      return true;                                                                      // 287
    });                                                                                 // 288
    return ret && _.size(b) === i;                                                      // 289
  }                                                                                     // 290
};                                                                                      // 291
                                                                                        // 292
EJSON.clone = function (v) {                                                            // 293
  var ret;                                                                              // 294
  if (typeof v !== "object")                                                            // 295
    return v;                                                                           // 296
  if (v === null)                                                                       // 297
    return null; // null has typeof "object"                                            // 298
  if (v instanceof Date)                                                                // 299
    return new Date(v.getTime());                                                       // 300
  if (EJSON.isBinary(v)) {                                                              // 301
    ret = EJSON.newBinary(v.length);                                                    // 302
    for (var i = 0; i < v.length; i++) {                                                // 303
      ret[i] = v[i];                                                                    // 304
    }                                                                                   // 305
    return ret;                                                                         // 306
  }                                                                                     // 307
  if (_.isArray(v) || _.isArguments(v)) {                                               // 308
    // For some reason, _.map doesn't work in this context on Opera (weird test         // 309
    // failures).                                                                       // 310
    ret = [];                                                                           // 311
    for (i = 0; i < v.length; i++)                                                      // 312
      ret[i] = EJSON.clone(v[i]);                                                       // 313
    return ret;                                                                         // 314
  }                                                                                     // 315
  // handle general user-defined typed Objects if they have a clone method              // 316
  if (typeof v.clone === 'function') {                                                  // 317
    return v.clone();                                                                   // 318
  }                                                                                     // 319
  // handle other objects                                                               // 320
  ret = {};                                                                             // 321
  _.each(v, function (value, key) {                                                     // 322
    ret[key] = EJSON.clone(value);                                                      // 323
  });                                                                                   // 324
  return ret;                                                                           // 325
};                                                                                      // 326
                                                                                        // 327
//////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// packages/ejson/base64.js                                                             //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
                                                                                        //
// Base 64 encoding                                                                     // 1
                                                                                        // 2
var BASE_64_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; // 3
                                                                                        // 4
var BASE_64_VALS = {};                                                                  // 5
                                                                                        // 6
for (var i = 0; i < BASE_64_CHARS.length; i++) {                                        // 7
  BASE_64_VALS[BASE_64_CHARS.charAt(i)] = i;                                            // 8
};                                                                                      // 9
                                                                                        // 10
base64Encode = function (array) {                                                       // 11
  var answer = [];                                                                      // 12
  var a = null;                                                                         // 13
  var b = null;                                                                         // 14
  var c = null;                                                                         // 15
  var d = null;                                                                         // 16
  for (var i = 0; i < array.length; i++) {                                              // 17
    switch (i % 3) {                                                                    // 18
    case 0:                                                                             // 19
      a = (array[i] >> 2) & 0x3F;                                                       // 20
      b = (array[i] & 0x03) << 4;                                                       // 21
      break;                                                                            // 22
    case 1:                                                                             // 23
      b = b | (array[i] >> 4) & 0xF;                                                    // 24
      c = (array[i] & 0xF) << 2;                                                        // 25
      break;                                                                            // 26
    case 2:                                                                             // 27
      c = c | (array[i] >> 6) & 0x03;                                                   // 28
      d = array[i] & 0x3F;                                                              // 29
      answer.push(getChar(a));                                                          // 30
      answer.push(getChar(b));                                                          // 31
      answer.push(getChar(c));                                                          // 32
      answer.push(getChar(d));                                                          // 33
      a = null;                                                                         // 34
      b = null;                                                                         // 35
      c = null;                                                                         // 36
      d = null;                                                                         // 37
      break;                                                                            // 38
    }                                                                                   // 39
  }                                                                                     // 40
  if (a != null) {                                                                      // 41
    answer.push(getChar(a));                                                            // 42
    answer.push(getChar(b));                                                            // 43
    if (c == null)                                                                      // 44
      answer.push('=');                                                                 // 45
    else                                                                                // 46
      answer.push(getChar(c));                                                          // 47
    if (d == null)                                                                      // 48
      answer.push('=');                                                                 // 49
  }                                                                                     // 50
  return answer.join("");                                                               // 51
};                                                                                      // 52
                                                                                        // 53
var getChar = function (val) {                                                          // 54
  return BASE_64_CHARS.charAt(val);                                                     // 55
};                                                                                      // 56
                                                                                        // 57
var getVal = function (ch) {                                                            // 58
  if (ch === '=') {                                                                     // 59
    return -1;                                                                          // 60
  }                                                                                     // 61
  return BASE_64_VALS[ch];                                                              // 62
};                                                                                      // 63
                                                                                        // 64
EJSON.newBinary = function (len) {                                                      // 65
  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {        // 66
    var ret = [];                                                                       // 67
    for (var i = 0; i < len; i++) {                                                     // 68
      ret.push(0);                                                                      // 69
    }                                                                                   // 70
    ret.$Uint8ArrayPolyfill = true;                                                     // 71
    return ret;                                                                         // 72
  }                                                                                     // 73
  return new Uint8Array(new ArrayBuffer(len));                                          // 74
};                                                                                      // 75
                                                                                        // 76
base64Decode = function (str) {                                                         // 77
  var len = Math.floor((str.length*3)/4);                                               // 78
  if (str.charAt(str.length - 1) == '=') {                                              // 79
    len--;                                                                              // 80
    if (str.charAt(str.length - 2) == '=')                                              // 81
      len--;                                                                            // 82
  }                                                                                     // 83
  var arr = EJSON.newBinary(len);                                                       // 84
                                                                                        // 85
  var one = null;                                                                       // 86
  var two = null;                                                                       // 87
  var three = null;                                                                     // 88
                                                                                        // 89
  var j = 0;                                                                            // 90
                                                                                        // 91
  for (var i = 0; i < str.length; i++) {                                                // 92
    var c = str.charAt(i);                                                              // 93
    var v = getVal(c);                                                                  // 94
    switch (i % 4) {                                                                    // 95
    case 0:                                                                             // 96
      if (v < 0)                                                                        // 97
        throw new Error('invalid base64 string');                                       // 98
      one = v << 2;                                                                     // 99
      break;                                                                            // 100
    case 1:                                                                             // 101
      if (v < 0)                                                                        // 102
        throw new Error('invalid base64 string');                                       // 103
      one = one | (v >> 4);                                                             // 104
      arr[j++] = one;                                                                   // 105
      two = (v & 0x0F) << 4;                                                            // 106
      break;                                                                            // 107
    case 2:                                                                             // 108
      if (v >= 0) {                                                                     // 109
        two = two | (v >> 2);                                                           // 110
        arr[j++] = two;                                                                 // 111
        three = (v & 0x03) << 6;                                                        // 112
      }                                                                                 // 113
      break;                                                                            // 114
    case 3:                                                                             // 115
      if (v >= 0) {                                                                     // 116
        arr[j++] = three | v;                                                           // 117
      }                                                                                 // 118
      break;                                                                            // 119
    }                                                                                   // 120
  }                                                                                     // 121
  return arr;                                                                           // 122
};                                                                                      // 123
                                                                                        // 124
EJSONTest.base64Encode = base64Encode;                                                  // 125
                                                                                        // 126
EJSONTest.base64Decode = base64Decode;                                                  // 127
                                                                                        // 128
//////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.ejson = {
  EJSON: EJSON,
  EJSONTest: EJSONTest
};

})();

//# sourceMappingURL=6798aba30085d088a96e75a363ca1a100b990bfd.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var __coffeescriptShare;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////
//                                                                                     //
// packages/logging/logging.coffee.js                                                  //
//                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////
                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var Log, str, time, zeropad,
  __slice = [].slice;

str = function(x) {
  if (typeof x === 'string') {
    return x;
  } else {
    return JSON.stringify(x);
  }
};

zeropad = function(n, s) {
  while (s.length < n) {
    s = '0' + s;
  }
  return s;
};

time = function() {
  var d;
  d = new Date();
  return zeropad(2, '' + d.getSeconds()) + '.' + zeropad(3, '' + d.getMilliseconds());
};

Meteor._debug = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return WebWorker.log(time() + ': ' + _.map(args, str).join(' '));
};

Log = {};
/////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.logging = {};

})();

//# sourceMappingURL=504b41a1d24f619d58572bd467809cf5ecfdc40b.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var JSON = Package.json.JSON;

/* Package-scope variables */
var Reload;

(function () {

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// packages/reload/reload.js                                                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////
                                                                              //
var providers = [];                                                           // 1
                                                                              // 2
////////// External API //////////                                            // 3
                                                                              // 4
Reload = {};                                                                  // 5
                                                                              // 6
// Packages that support migration should register themselves by              // 7
// calling this function. When it's time to migrate, callback will            // 8
// be called with one argument, the "retry function." If the package          // 9
// is ready to migrate, it should return [true, data], where data is          // 10
// its migration data, an arbitrary JSON value (or [true] if it has           // 11
// no migration data this time). If the package needs more time               // 12
// before it is ready to migrate, it should return false. Then, once          // 13
// it is ready to migrating again, it should call the retry                   // 14
// function. The retry function will return immediately, but will             // 15
// schedule the migration to be retried, meaning that every package           // 16
// will be polled once again for its migration data. If they are all          // 17
// ready this time, then the migration will happen. name must be set if there // 18
// is migration data.                                                         // 19
//                                                                            // 20
Reload._onMigrate = function (name, callback) {                               // 21
  if (!callback) {                                                            // 22
    // name not provided, so first arg is callback.                           // 23
    callback = name;                                                          // 24
    name = undefined;                                                         // 25
  }                                                                           // 26
  providers.push({name: name, callback: callback});                           // 27
};                                                                            // 28
                                                                              // 29
// Called by packages when they start up.                                     // 30
// Returns the object that was saved, or undefined if none saved.             // 31
//                                                                            // 32
Reload._migrationData = function (name) {                                     // 33
  return undefined;                                                           // 34
};                                                                            // 35
                                                                              // 36
// Migrating reload: reload this page (presumably to pick up a new            // 37
// version of the code or assets), but save the program state and             // 38
// migrate it over. This function returns immediately. The reload             // 39
// will happen at some point in the future once all of the packages           // 40
// are ready to migrate.                                                      // 41
//                                                                            // 42
var reloading = false;                                                        // 43
Reload._reload = function () {                                                // 44
  if (reloading)                                                              // 45
    return;                                                                   // 46
  reloading = true;                                                           // 47
                                                                              // 48
  Meteor._debug('reload requested');                                          // 49
};                                                                            // 50
                                                                              // 51
////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.reload = {
  Reload: Reload
};

})();

//# sourceMappingURL=fc7147dfa8b06fce8f49b54d71f89f48f8717dbf.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var check, Match;

(function () {

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// packages/check/match.js                                                       //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////
                                                                                 //
// XXX docs                                                                      // 1
                                                                                 // 2
// Things we explicitly do NOT support:                                          // 3
//    - heterogenous arrays                                                      // 4
                                                                                 // 5
var currentArgumentChecker = new Meteor.EnvironmentVariable;                     // 6
                                                                                 // 7
check = function (value, pattern) {                                              // 8
  // Record that check got called, if somebody cared.                            // 9
  var argChecker = currentArgumentChecker.get();                                 // 10
  if (argChecker)                                                                // 11
    argChecker.checking(value);                                                  // 12
  try {                                                                          // 13
    checkSubtree(value, pattern);                                                // 14
  } catch (err) {                                                                // 15
    if ((err instanceof Match.Error) && err.path)                                // 16
      err.message += " in field " + err.path;                                    // 17
    throw err;                                                                   // 18
  }                                                                              // 19
};                                                                               // 20
                                                                                 // 21
Match = {                                                                        // 22
  Optional: function (pattern) {                                                 // 23
    return new Optional(pattern);                                                // 24
  },                                                                             // 25
  OneOf: function (/*arguments*/) {                                              // 26
    return new OneOf(_.toArray(arguments));                                      // 27
  },                                                                             // 28
  Any: ['__any__'],                                                              // 29
  Where: function (condition) {                                                  // 30
    return new Where(condition);                                                 // 31
  },                                                                             // 32
  ObjectIncluding: function (pattern) {                                          // 33
    return new ObjectIncluding(pattern);                                         // 34
  },                                                                             // 35
  // Matches only signed 32-bit integers                                         // 36
  Integer: ['__integer__'],                                                      // 37
                                                                                 // 38
  // XXX matchers should know how to describe themselves for errors              // 39
  Error: Meteor.makeErrorType("Match.Error", function (msg) {                    // 40
    this.message = "Match error: " + msg;                                        // 41
    // The path of the value that failed to match. Initially empty, this gets    // 42
    // populated by catching and rethrowing the exception as it goes back up the // 43
    // stack.                                                                    // 44
    // E.g.: "vals[3].entity.created"                                            // 45
    this.path = "";                                                              // 46
    // If this gets sent over DDP, don't give full internal details but at least // 47
    // provide something better than 500 Internal server error.                  // 48
    this.sanitizedError = new Meteor.Error(400, "Match failed");                 // 49
  }),                                                                            // 50
                                                                                 // 51
  // Tests to see if value matches pattern. Unlike check, it merely returns true // 52
  // or false (unless an error other than Match.Error was thrown). It does not   // 53
  // interact with _failIfArgumentsAreNotAllChecked.                             // 54
  // XXX maybe also implement a Match.match which returns more information about // 55
  //     failures but without using exception handling or doing what check()     // 56
  //     does with _failIfArgumentsAreNotAllChecked and Meteor.Error conversion  // 57
  test: function (value, pattern) {                                              // 58
    try {                                                                        // 59
      checkSubtree(value, pattern);                                              // 60
      return true;                                                               // 61
    } catch (e) {                                                                // 62
      if (e instanceof Match.Error)                                              // 63
        return false;                                                            // 64
      // Rethrow other errors.                                                   // 65
      throw e;                                                                   // 66
    }                                                                            // 67
  },                                                                             // 68
                                                                                 // 69
  // Runs `f.apply(context, args)`. If check() is not called on every element of // 70
  // `args` (either directly or in the first level of an array), throws an error // 71
  // (using `description` in the message).                                       // 72
  //                                                                             // 73
  _failIfArgumentsAreNotAllChecked: function (f, context, args, description) {   // 74
    var argChecker = new ArgumentChecker(args, description);                     // 75
    var result = currentArgumentChecker.withValue(argChecker, function () {      // 76
      return f.apply(context, args);                                             // 77
    });                                                                          // 78
    // If f didn't itself throw, make sure it checked all of its arguments.      // 79
    argChecker.throwUnlessAllArgumentsHaveBeenChecked();                         // 80
    return result;                                                               // 81
  }                                                                              // 82
};                                                                               // 83
                                                                                 // 84
var Optional = function (pattern) {                                              // 85
  this.pattern = pattern;                                                        // 86
};                                                                               // 87
                                                                                 // 88
var OneOf = function (choices) {                                                 // 89
  if (_.isEmpty(choices))                                                        // 90
    throw new Error("Must provide at least one choice to Match.OneOf");          // 91
  this.choices = choices;                                                        // 92
};                                                                               // 93
                                                                                 // 94
var Where = function (condition) {                                               // 95
  this.condition = condition;                                                    // 96
};                                                                               // 97
                                                                                 // 98
var ObjectIncluding = function (pattern) {                                       // 99
  this.pattern = pattern;                                                        // 100
};                                                                               // 101
                                                                                 // 102
var typeofChecks = [                                                             // 103
  [String, "string"],                                                            // 104
  [Number, "number"],                                                            // 105
  [Boolean, "boolean"],                                                          // 106
  // While we don't allow undefined in EJSON, this is good for optional          // 107
  // arguments with OneOf.                                                       // 108
  [undefined, "undefined"]                                                       // 109
];                                                                               // 110
                                                                                 // 111
var checkSubtree = function (value, pattern) {                                   // 112
  // Match anything!                                                             // 113
  if (pattern === Match.Any)                                                     // 114
    return;                                                                      // 115
                                                                                 // 116
  // Basic atomic types.                                                         // 117
  // Do not match boxed objects (e.g. String, Boolean)                           // 118
  for (var i = 0; i < typeofChecks.length; ++i) {                                // 119
    if (pattern === typeofChecks[i][0]) {                                        // 120
      if (typeof value === typeofChecks[i][1])                                   // 121
        return;                                                                  // 122
      throw new Match.Error("Expected " + typeofChecks[i][1] + ", got " +        // 123
                            typeof value);                                       // 124
    }                                                                            // 125
  }                                                                              // 126
  if (pattern === null) {                                                        // 127
    if (value === null)                                                          // 128
      return;                                                                    // 129
    throw new Match.Error("Expected null, got " + EJSON.stringify(value));       // 130
  }                                                                              // 131
                                                                                 // 132
  // Match.Integer is special type encoded with array                            // 133
  if (pattern === Match.Integer) {                                               // 134
    // There is no consistent and reliable way to check if variable is a 64-bit  // 135
    // integer. One of the popular solutions is to get reminder of division by 1 // 136
    // but this method fails on really large floats with big precision.          // 137
    // E.g.: 1.348192308491824e+23 % 1 === 0 in V8                               // 138
    // Bitwise operators work consistantly but always cast variable to 32-bit    // 139
    // signed integer according to JavaScript specs.                             // 140
    if (typeof value === "number" && (value | 0) === value)                      // 141
      return                                                                     // 142
    throw new Match.Error("Expected Integer, got "                               // 143
                + (value instanceof Object ? EJSON.stringify(value) : value));   // 144
  }                                                                              // 145
                                                                                 // 146
  // "Object" is shorthand for Match.ObjectIncluding({});                        // 147
  if (pattern === Object)                                                        // 148
    pattern = Match.ObjectIncluding({});                                         // 149
                                                                                 // 150
  // Array (checked AFTER Any, which is implemented as an Array).                // 151
  if (pattern instanceof Array) {                                                // 152
    if (pattern.length !== 1)                                                    // 153
      throw Error("Bad pattern: arrays must have one type element" +             // 154
                  EJSON.stringify(pattern));                                     // 155
    if (!_.isArray(value) && !_.isArguments(value)) {                            // 156
      throw new Match.Error("Expected array, got " + EJSON.stringify(value));    // 157
    }                                                                            // 158
                                                                                 // 159
    _.each(value, function (valueElement, index) {                               // 160
      try {                                                                      // 161
        checkSubtree(valueElement, pattern[0]);                                  // 162
      } catch (err) {                                                            // 163
        if (err instanceof Match.Error) {                                        // 164
          err.path = _prependPath(index, err.path);                              // 165
        }                                                                        // 166
        throw err;                                                               // 167
      }                                                                          // 168
    });                                                                          // 169
    return;                                                                      // 170
  }                                                                              // 171
                                                                                 // 172
  // Arbitrary validation checks. The condition can return false or throw a      // 173
  // Match.Error (ie, it can internally use check()) to fail.                    // 174
  if (pattern instanceof Where) {                                                // 175
    if (pattern.condition(value))                                                // 176
      return;                                                                    // 177
    // XXX this error is terrible                                                // 178
    throw new Match.Error("Failed Match.Where validation");                      // 179
  }                                                                              // 180
                                                                                 // 181
                                                                                 // 182
  if (pattern instanceof Optional)                                               // 183
    pattern = Match.OneOf(undefined, pattern.pattern);                           // 184
                                                                                 // 185
  if (pattern instanceof OneOf) {                                                // 186
    for (var i = 0; i < pattern.choices.length; ++i) {                           // 187
      try {                                                                      // 188
        checkSubtree(value, pattern.choices[i]);                                 // 189
        // No error? Yay, return.                                                // 190
        return;                                                                  // 191
      } catch (err) {                                                            // 192
        // Other errors should be thrown. Match errors just mean try another     // 193
        // choice.                                                               // 194
        if (!(err instanceof Match.Error))                                       // 195
          throw err;                                                             // 196
      }                                                                          // 197
    }                                                                            // 198
    // XXX this error is terrible                                                // 199
    throw new Match.Error("Failed Match.OneOf or Match.Optional validation");    // 200
  }                                                                              // 201
                                                                                 // 202
  // A function that isn't something we special-case is assumed to be a          // 203
  // constructor.                                                                // 204
  if (pattern instanceof Function) {                                             // 205
    if (value instanceof pattern)                                                // 206
      return;                                                                    // 207
    // XXX what if .name isn't defined                                           // 208
    throw new Match.Error("Expected " + pattern.name);                           // 209
  }                                                                              // 210
                                                                                 // 211
  var unknownKeysAllowed = false;                                                // 212
  if (pattern instanceof ObjectIncluding) {                                      // 213
    unknownKeysAllowed = true;                                                   // 214
    pattern = pattern.pattern;                                                   // 215
  }                                                                              // 216
                                                                                 // 217
  if (typeof pattern !== "object")                                               // 218
    throw Error("Bad pattern: unknown pattern type");                            // 219
                                                                                 // 220
  // An object, with required and optional keys. Note that this does NOT do      // 221
  // structural matches against objects of special types that happen to match    // 222
  // the pattern: this really needs to be a plain old {Object}!                  // 223
  if (typeof value !== 'object')                                                 // 224
    throw new Match.Error("Expected object, got " + typeof value);               // 225
  if (value === null)                                                            // 226
    throw new Match.Error("Expected object, got null");                          // 227
  if (value.constructor !== Object)                                              // 228
    throw new Match.Error("Expected plain object");                              // 229
                                                                                 // 230
  var requiredPatterns = {};                                                     // 231
  var optionalPatterns = {};                                                     // 232
  _.each(pattern, function (subPattern, key) {                                   // 233
    if (subPattern instanceof Optional)                                          // 234
      optionalPatterns[key] = subPattern.pattern;                                // 235
    else                                                                         // 236
      requiredPatterns[key] = subPattern;                                        // 237
  });                                                                            // 238
                                                                                 // 239
  _.each(value, function (subValue, key) {                                       // 240
    try {                                                                        // 241
      if (_.has(requiredPatterns, key)) {                                        // 242
        checkSubtree(subValue, requiredPatterns[key]);                           // 243
        delete requiredPatterns[key];                                            // 244
      } else if (_.has(optionalPatterns, key)) {                                 // 245
        checkSubtree(subValue, optionalPatterns[key]);                           // 246
      } else {                                                                   // 247
        if (!unknownKeysAllowed)                                                 // 248
          throw new Match.Error("Unknown key");                                  // 249
      }                                                                          // 250
    } catch (err) {                                                              // 251
      if (err instanceof Match.Error)                                            // 252
        err.path = _prependPath(key, err.path);                                  // 253
      throw err;                                                                 // 254
    }                                                                            // 255
  });                                                                            // 256
                                                                                 // 257
  _.each(requiredPatterns, function (subPattern, key) {                          // 258
    throw new Match.Error("Missing key '" + key + "'");                          // 259
  });                                                                            // 260
};                                                                               // 261
                                                                                 // 262
var ArgumentChecker = function (args, description) {                             // 263
  var self = this;                                                               // 264
  // Make a SHALLOW copy of the arguments. (We'll be doing identity checks       // 265
  // against its contents.)                                                      // 266
  self.args = _.clone(args);                                                     // 267
  // Since the common case will be to check arguments in order, and we splice    // 268
  // out arguments when we check them, make it so we splice out from the end     // 269
  // rather than the beginning.                                                  // 270
  self.args.reverse();                                                           // 271
  self.description = description;                                                // 272
};                                                                               // 273
                                                                                 // 274
_.extend(ArgumentChecker.prototype, {                                            // 275
  checking: function (value) {                                                   // 276
    var self = this;                                                             // 277
    if (self._checkingOneValue(value))                                           // 278
      return;                                                                    // 279
    // Allow check(arguments, [String]) or check(arguments.slice(1), [String])   // 280
    // or check([foo, bar], [String]) to count... but only if value wasn't       // 281
    // itself an argument.                                                       // 282
    if (_.isArray(value) || _.isArguments(value)) {                              // 283
      _.each(value, _.bind(self._checkingOneValue, self));                       // 284
    }                                                                            // 285
  },                                                                             // 286
  _checkingOneValue: function (value) {                                          // 287
    var self = this;                                                             // 288
    for (var i = 0; i < self.args.length; ++i) {                                 // 289
      // Is this value one of the arguments? (This can have a false positive if  // 290
      // the argument is an interned primitive, but it's still a good enough     // 291
      // check.)                                                                 // 292
      if (value === self.args[i]) {                                              // 293
        self.args.splice(i, 1);                                                  // 294
        return true;                                                             // 295
      }                                                                          // 296
    }                                                                            // 297
    return false;                                                                // 298
  },                                                                             // 299
  throwUnlessAllArgumentsHaveBeenChecked: function () {                          // 300
    var self = this;                                                             // 301
    if (!_.isEmpty(self.args))                                                   // 302
      throw new Error("Did not check() all arguments during " +                  // 303
                      self.description);                                         // 304
  }                                                                              // 305
});                                                                              // 306
                                                                                 // 307
var _jsKeywords = ["do", "if", "in", "for", "let", "new", "try", "var", "case",  // 308
  "else", "enum", "eval", "false", "null", "this", "true", "void", "with",       // 309
  "break", "catch", "class", "const", "super", "throw", "while", "yield",        // 310
  "delete", "export", "import", "public", "return", "static", "switch",          // 311
  "typeof", "default", "extends", "finally", "package", "private", "continue",   // 312
  "debugger", "function", "arguments", "interface", "protected", "implements",   // 313
  "instanceof"];                                                                 // 314
                                                                                 // 315
// Assumes the base of path is already escaped properly                          // 316
// returns key + base                                                            // 317
var _prependPath = function (key, base) {                                        // 318
  if ((typeof key) === "number" || key.match(/^[0-9]+$/))                        // 319
    key = "[" + key + "]";                                                       // 320
  else if (!key.match(/^[a-z_$][0-9a-z_$]*$/i) || _.contains(_jsKeywords, key))  // 321
    key = JSON.stringify([key]);                                                 // 322
                                                                                 // 323
  if (base && base[0] !== "[")                                                   // 324
    return key + '.' + base;                                                     // 325
  return key + base;                                                             // 326
};                                                                               // 327
                                                                                 // 328
                                                                                 // 329
///////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.check = {
  check: check,
  Match: Match
};

})();

//# sourceMappingURL=a54cf3c7b3abe9208d064621eb80a3ecaf2f4add.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var Random;

(function () {

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// packages/random/random.js                                                        //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
                                                                                    //
// see http://baagoe.org/en/wiki/Better_random_numbers_for_javascript               // 1
// for a full discussion and Alea implementation.                                   // 2
var Alea = function () {                                                            // 3
  function Mash() {                                                                 // 4
    var n = 0xefc8249d;                                                             // 5
                                                                                    // 6
    var mash = function(data) {                                                     // 7
      data = data.toString();                                                       // 8
      for (var i = 0; i < data.length; i++) {                                       // 9
        n += data.charCodeAt(i);                                                    // 10
        var h = 0.02519603282416938 * n;                                            // 11
        n = h >>> 0;                                                                // 12
        h -= n;                                                                     // 13
        h *= n;                                                                     // 14
        n = h >>> 0;                                                                // 15
        h -= n;                                                                     // 16
        n += h * 0x100000000; // 2^32                                               // 17
      }                                                                             // 18
      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32                           // 19
    };                                                                              // 20
                                                                                    // 21
    mash.version = 'Mash 0.9';                                                      // 22
    return mash;                                                                    // 23
  }                                                                                 // 24
                                                                                    // 25
  return (function (args) {                                                         // 26
    var s0 = 0;                                                                     // 27
    var s1 = 0;                                                                     // 28
    var s2 = 0;                                                                     // 29
    var c = 1;                                                                      // 30
                                                                                    // 31
    if (args.length == 0) {                                                         // 32
      args = [+new Date];                                                           // 33
    }                                                                               // 34
    var mash = Mash();                                                              // 35
    s0 = mash(' ');                                                                 // 36
    s1 = mash(' ');                                                                 // 37
    s2 = mash(' ');                                                                 // 38
                                                                                    // 39
    for (var i = 0; i < args.length; i++) {                                         // 40
      s0 -= mash(args[i]);                                                          // 41
      if (s0 < 0) {                                                                 // 42
        s0 += 1;                                                                    // 43
      }                                                                             // 44
      s1 -= mash(args[i]);                                                          // 45
      if (s1 < 0) {                                                                 // 46
        s1 += 1;                                                                    // 47
      }                                                                             // 48
      s2 -= mash(args[i]);                                                          // 49
      if (s2 < 0) {                                                                 // 50
        s2 += 1;                                                                    // 51
      }                                                                             // 52
    }                                                                               // 53
    mash = null;                                                                    // 54
                                                                                    // 55
    var random = function() {                                                       // 56
      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32                   // 57
      s0 = s1;                                                                      // 58
      s1 = s2;                                                                      // 59
      return s2 = t - (c = t | 0);                                                  // 60
    };                                                                              // 61
    random.uint32 = function() {                                                    // 62
      return random() * 0x100000000; // 2^32                                        // 63
    };                                                                              // 64
    random.fract53 = function() {                                                   // 65
      return random() +                                                             // 66
        (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53                // 67
    };                                                                              // 68
    random.version = 'Alea 0.9';                                                    // 69
    random.args = args;                                                             // 70
    return random;                                                                  // 71
                                                                                    // 72
  } (Array.prototype.slice.call(arguments)));                                       // 73
};                                                                                  // 74
                                                                                    // 75
var UNMISTAKABLE_CHARS = "23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz"; // 76
                                                                                    // 77
var create = function (/* arguments */) {                                           // 78
                                                                                    // 79
  var random = Alea.apply(null, arguments);                                         // 80
                                                                                    // 81
  var self = {};                                                                    // 82
                                                                                    // 83
  var bind = function (fn) {                                                        // 84
    return _.bind(fn, self);                                                        // 85
  };                                                                                // 86
                                                                                    // 87
  return _.extend(self, {                                                           // 88
    _Alea: Alea,                                                                    // 89
                                                                                    // 90
    create: create,                                                                 // 91
                                                                                    // 92
    fraction: random,                                                               // 93
                                                                                    // 94
    choice: bind(function (arrayOrString) {                                         // 95
      var index = Math.floor(this.fraction() * arrayOrString.length);               // 96
      if (typeof arrayOrString === "string")                                        // 97
        return arrayOrString.substr(index, 1);                                      // 98
      else                                                                          // 99
        return arrayOrString[index];                                                // 100
    }),                                                                             // 101
                                                                                    // 102
    id: bind(function() {                                                           // 103
      var digits = [];                                                              // 104
      // Length of 17 preserves around 96 bits of entropy, which is the             // 105
      // amount of state in our PRNG                                                // 106
      for (var i = 0; i < 17; i++) {                                                // 107
        digits[i] = this.choice(UNMISTAKABLE_CHARS);                                // 108
      }                                                                             // 109
      return digits.join("");                                                       // 110
    }),                                                                             // 111
                                                                                    // 112
    hexString: bind(function (digits) {                                             // 113
      var hexDigits = [];                                                           // 114
      for (var i = 0; i < digits; ++i) {                                            // 115
        hexDigits.push(this.choice("0123456789abcdef"));                            // 116
      }                                                                             // 117
      return hexDigits.join('');                                                    // 118
    })                                                                              // 119
  });                                                                               // 120
};                                                                                  // 121
                                                                                    // 122
// instantiate RNG.  Heuristically collect entropy from various sources             // 123
                                                                                    // 124
// client sources                                                                   // 125
var height = (typeof window !== 'undefined' && window.innerHeight) ||               // 126
      (typeof document !== 'undefined'                                              // 127
       && document.documentElement                                                  // 128
       && document.documentElement.clientHeight) ||                                 // 129
      (typeof document !== 'undefined'                                              // 130
       && document.body                                                             // 131
       && document.body.clientHeight) ||                                            // 132
      1;                                                                            // 133
                                                                                    // 134
var width = (typeof window !== 'undefined' && window.innerWidth) ||                 // 135
      (typeof document !== 'undefined'                                              // 136
       && document.documentElement                                                  // 137
       && document.documentElement.clientWidth) ||                                  // 138
      (typeof document !== 'undefined'                                              // 139
       && document.body                                                             // 140
       && document.body.clientWidth) ||                                             // 141
      1;                                                                            // 142
                                                                                    // 143
var agent = (typeof navigator !== 'undefined' && navigator.userAgent) || "";        // 144
                                                                                    // 145
// server sources                                                                   // 146
var pid = (typeof process !== 'undefined' && process.pid) || 1;                     // 147
                                                                                    // 148
// XXX On the server, use the crypto module (OpenSSL) instead of this PRNG.         // 149
//     (Make Random.fraction be generated from Random.hexString instead of the      // 150
//     other way around, and generate Random.hexString from crypto.randomBytes.)    // 151
Random = create([                                                                   // 152
  new Date(), height, width, agent, pid, Math.random()                              // 153
]);                                                                                 // 154
                                                                                    // 155
//////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

//////////////////////////////////////////////////////////////////////////////////////
//                                                                                  //
// packages/random/deprecated.js                                                    //
//                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////
                                                                                    //
// Before this package existed, we used to use this Meteor.uuid()                   // 1
// implementing the RFC 4122 v4 UUID. It is no longer documented                    // 2
// and will go away.                                                                // 3
// XXX COMPAT WITH 0.5.6                                                            // 4
Meteor.uuid = function () {                                                         // 5
  var HEX_DIGITS = "0123456789abcdef";                                              // 6
  var s = [];                                                                       // 7
  for (var i = 0; i < 36; i++) {                                                    // 8
    s[i] = Random.choice(HEX_DIGITS);                                               // 9
  }                                                                                 // 10
  s[14] = "4";                                                                      // 11
  s[19] = HEX_DIGITS.substr((parseInt(s[19],16) & 0x3) | 0x8, 1);                   // 12
  s[8] = s[13] = s[18] = s[23] = "-";                                               // 13
                                                                                    // 14
  var uuid = s.join("");                                                            // 15
  return uuid;                                                                      // 16
};                                                                                  // 17
                                                                                    // 18
//////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.random = {
  Random: Random
};

})();

//# sourceMappingURL=a592658942f32ab31e84c4e67768f13f07a8e4b4.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var OrderedDict;

(function () {

///////////////////////////////////////////////////////////////////////////////////
//                                                                               //
// packages/ordered-dict/ordered_dict.js                                         //
//                                                                               //
///////////////////////////////////////////////////////////////////////////////////
                                                                                 //
// This file defines an ordered dictionary abstraction that is useful for        // 1
// maintaining a dataset backed by observeChanges.  It supports ordering items   // 2
// by specifying the item they now come before.                                  // 3
                                                                                 // 4
// The implementation is a dictionary that contains nodes of a doubly-linked     // 5
// list as its values.                                                           // 6
                                                                                 // 7
// constructs a new element struct                                               // 8
// next and prev are whole elements, not keys.                                   // 9
var element = function (key, value, next, prev) {                                // 10
  return {                                                                       // 11
    key: key,                                                                    // 12
    value: value,                                                                // 13
    next: next,                                                                  // 14
    prev: prev                                                                   // 15
  };                                                                             // 16
};                                                                               // 17
OrderedDict = function (/* ... */) {                                             // 18
  var self = this;                                                               // 19
  self._dict = {};                                                               // 20
  self._first = null;                                                            // 21
  self._last = null;                                                             // 22
  self._size = 0;                                                                // 23
  var args = _.toArray(arguments);                                               // 24
  self._stringify = function (x) { return x; };                                  // 25
  if (typeof args[0] === 'function')                                             // 26
    self._stringify = args.shift();                                              // 27
  _.each(args, function (kv) {                                                   // 28
    self.putBefore(kv[0], kv[1], null);                                          // 29
  });                                                                            // 30
};                                                                               // 31
                                                                                 // 32
_.extend(OrderedDict.prototype, {                                                // 33
  // the "prefix keys with a space" thing comes from here                        // 34
  // https://github.com/documentcloud/underscore/issues/376#issuecomment-2815649 // 35
  _k: function (key) { return " " + this._stringify(key); },                     // 36
                                                                                 // 37
  empty: function () {                                                           // 38
    var self = this;                                                             // 39
    return !self._first;                                                         // 40
  },                                                                             // 41
  size: function () {                                                            // 42
    var self = this;                                                             // 43
    return self._size;                                                           // 44
  },                                                                             // 45
  _linkEltIn: function (elt) {                                                   // 46
    var self = this;                                                             // 47
    if (!elt.next) {                                                             // 48
      elt.prev = self._last;                                                     // 49
      if (self._last)                                                            // 50
        self._last.next = elt;                                                   // 51
      self._last = elt;                                                          // 52
    } else {                                                                     // 53
      elt.prev = elt.next.prev;                                                  // 54
      elt.next.prev = elt;                                                       // 55
      if (elt.prev)                                                              // 56
        elt.prev.next = elt;                                                     // 57
    }                                                                            // 58
    if (self._first === null || self._first === elt.next)                        // 59
      self._first = elt;                                                         // 60
  },                                                                             // 61
  _linkEltOut: function (elt) {                                                  // 62
    var self = this;                                                             // 63
    if (elt.next)                                                                // 64
      elt.next.prev = elt.prev;                                                  // 65
    if (elt.prev)                                                                // 66
      elt.prev.next = elt.next;                                                  // 67
    if (elt === self._last)                                                      // 68
      self._last = elt.prev;                                                     // 69
    if (elt === self._first)                                                     // 70
      self._first = elt.next;                                                    // 71
  },                                                                             // 72
  putBefore: function (key, item, before) {                                      // 73
    var self = this;                                                             // 74
    if (self._dict[self._k(key)])                                                // 75
      throw new Error("Item " + key + " already present in OrderedDict");        // 76
    var elt = before ?                                                           // 77
          element(key, item, self._dict[self._k(before)]) :                      // 78
          element(key, item, null);                                              // 79
    if (elt.next === undefined)                                                  // 80
      throw new Error("could not find item to put this one before");             // 81
    self._linkEltIn(elt);                                                        // 82
    self._dict[self._k(key)] = elt;                                              // 83
    self._size++;                                                                // 84
  },                                                                             // 85
  append: function (key, item) {                                                 // 86
    var self = this;                                                             // 87
    self.putBefore(key, item, null);                                             // 88
  },                                                                             // 89
  remove: function (key) {                                                       // 90
    var self = this;                                                             // 91
    var elt = self._dict[self._k(key)];                                          // 92
    if (elt === undefined)                                                       // 93
      throw new Error("Item " + key + " not present in OrderedDict");            // 94
    self._linkEltOut(elt);                                                       // 95
    self._size--;                                                                // 96
    delete self._dict[self._k(key)];                                             // 97
    return elt.value;                                                            // 98
  },                                                                             // 99
  get: function (key) {                                                          // 100
    var self = this;                                                             // 101
    if (self.has(key))                                                           // 102
        return self._dict[self._k(key)].value;                                   // 103
    return undefined;                                                            // 104
  },                                                                             // 105
  has: function (key) {                                                          // 106
    var self = this;                                                             // 107
    return _.has(self._dict, self._k(key));                                      // 108
  },                                                                             // 109
  // Iterate through the items in this dictionary in order, calling              // 110
  // iter(value, key, index) on each one.                                        // 111
                                                                                 // 112
  // Stops whenever iter returns OrderedDict.BREAK, or after the last element.   // 113
  forEach: function (iter) {                                                     // 114
    var self = this;                                                             // 115
    var i = 0;                                                                   // 116
    var elt = self._first;                                                       // 117
    while (elt !== null) {                                                       // 118
      var b = iter(elt.value, elt.key, i);                                       // 119
      if (b === OrderedDict.BREAK)                                               // 120
        return;                                                                  // 121
      elt = elt.next;                                                            // 122
      i++;                                                                       // 123
    }                                                                            // 124
  },                                                                             // 125
  first: function () {                                                           // 126
    var self = this;                                                             // 127
    if (self.empty())                                                            // 128
      return undefined;                                                          // 129
    return self._first.key;                                                      // 130
  },                                                                             // 131
  firstValue: function () {                                                      // 132
    var self = this;                                                             // 133
    if (self.empty())                                                            // 134
      return undefined;                                                          // 135
    return self._first.value;                                                    // 136
  },                                                                             // 137
  last: function () {                                                            // 138
    var self = this;                                                             // 139
    if (self.empty())                                                            // 140
      return undefined;                                                          // 141
    return self._last.key;                                                       // 142
  },                                                                             // 143
  lastValue: function () {                                                       // 144
    var self = this;                                                             // 145
    if (self.empty())                                                            // 146
      return undefined;                                                          // 147
    return self._last.value;                                                     // 148
  },                                                                             // 149
  prev: function (key) {                                                         // 150
    var self = this;                                                             // 151
    if (self.has(key)) {                                                         // 152
      var elt = self._dict[self._k(key)];                                        // 153
      if (elt.prev)                                                              // 154
        return elt.prev.key;                                                     // 155
    }                                                                            // 156
    return null;                                                                 // 157
  },                                                                             // 158
  next: function (key) {                                                         // 159
    var self = this;                                                             // 160
    if (self.has(key)) {                                                         // 161
      var elt = self._dict[self._k(key)];                                        // 162
      if (elt.next)                                                              // 163
        return elt.next.key;                                                     // 164
    }                                                                            // 165
    return null;                                                                 // 166
  },                                                                             // 167
  moveBefore: function (key, before) {                                           // 168
    var self = this;                                                             // 169
    var elt = self._dict[self._k(key)];                                          // 170
    var eltBefore = before ? self._dict[self._k(before)] : null;                 // 171
    if (elt === undefined)                                                       // 172
      throw new Error("Item to move is not present");                            // 173
    if (eltBefore === undefined) {                                               // 174
      throw new Error("Could not find element to move this one before");         // 175
    }                                                                            // 176
    if (eltBefore === elt.next) // no moving necessary                           // 177
      return;                                                                    // 178
    // remove from its old place                                                 // 179
    self._linkEltOut(elt);                                                       // 180
    // patch into its new place                                                  // 181
    elt.next = eltBefore;                                                        // 182
    self._linkEltIn(elt);                                                        // 183
  },                                                                             // 184
  // Linear, sadly.                                                              // 185
  indexOf: function (key) {                                                      // 186
    var self = this;                                                             // 187
    var ret = null;                                                              // 188
    self.forEach(function (v, k, i) {                                            // 189
      if (self._k(k) === self._k(key)) {                                         // 190
        ret = i;                                                                 // 191
        return OrderedDict.BREAK;                                                // 192
      }                                                                          // 193
      return undefined;                                                          // 194
    });                                                                          // 195
    return ret;                                                                  // 196
  },                                                                             // 197
  _checkRep: function () {                                                       // 198
    var self = this;                                                             // 199
    _.each(self._dict, function (k, v) {                                         // 200
      if (v.next === v)                                                          // 201
        throw new Error("Next is a loop");                                       // 202
      if (v.prev === v)                                                          // 203
        throw new Error("Prev is a loop");                                       // 204
    });                                                                          // 205
  }                                                                              // 206
                                                                                 // 207
});                                                                              // 208
OrderedDict.BREAK = {"break": true};                                             // 209
                                                                                 // 210
///////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['ordered-dict'] = {
  OrderedDict: OrderedDict
};

})();

//# sourceMappingURL=bf8af2f26c8d96bf8b2e6b407d3ed69f23c2cd37.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;
var JSON = Package.json.JSON;
var EJSON = Package.ejson.EJSON;
var OrderedDict = Package['ordered-dict'].OrderedDict;
var Deps = Package.deps.Deps;
var Random = Package.random.Random;

/* Package-scope variables */
var LocalCollection;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/minimongo.js                                                                    //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// XXX type checking on selectors (graceful error if malformed)                                       // 1
                                                                                                      // 2
// LocalCollection: a set of documents that supports queries and modifiers.                           // 3
                                                                                                      // 4
// Cursor: a specification for a particular subset of documents, w/                                   // 5
// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),                // 6
                                                                                                      // 7
// LiveResultsSet: the return value of a live query.                                                  // 8
                                                                                                      // 9
LocalCollection = function (name) {                                                                   // 10
  this.name = name;                                                                                   // 11
  this.docs = {}; // _id -> document (also containing id)                                             // 12
                                                                                                      // 13
  this._observeQueue = new Meteor._SynchronousQueue();                                                // 14
                                                                                                      // 15
  this.next_qid = 1; // live query id generator                                                       // 16
                                                                                                      // 17
  // qid -> live query object. keys:                                                                  // 18
  //  ordered: bool. ordered queries have moved callbacks and callbacks                               // 19
  //           take indices.                                                                          // 20
  //  results: array (ordered) or object (unordered) of current results                               // 21
  //  results_snapshot: snapshot of results. null if not paused.                                      // 22
  //  cursor: Cursor object for the query.                                                            // 23
  //  selector_f, sort_f, (callbacks): functions                                                      // 24
  this.queries = {};                                                                                  // 25
                                                                                                      // 26
  // null if not saving originals; a map from id to original document value if                        // 27
  // saving originals. See comments before saveOriginals().                                           // 28
  this._savedOriginals = null;                                                                        // 29
                                                                                                      // 30
  // True when observers are paused and we should not send callbacks.                                 // 31
  this.paused = false;                                                                                // 32
};                                                                                                    // 33
                                                                                                      // 34
                                                                                                      // 35
LocalCollection._applyChanges = function (doc, changeFields) {                                        // 36
  _.each(changeFields, function (value, key) {                                                        // 37
    if (value === undefined)                                                                          // 38
      delete doc[key];                                                                                // 39
    else                                                                                              // 40
      doc[key] = value;                                                                               // 41
  });                                                                                                 // 42
};                                                                                                    // 43
                                                                                                      // 44
var MinimongoError = function (message) {                                                             // 45
  var e = new Error(message);                                                                         // 46
  e.name = "MinimongoError";                                                                          // 47
  return e;                                                                                           // 48
};                                                                                                    // 49
                                                                                                      // 50
                                                                                                      // 51
// options may include sort, skip, limit, reactive                                                    // 52
// sort may be any of these forms:                                                                    // 53
//     {a: 1, b: -1}                                                                                  // 54
//     [["a", "asc"], ["b", "desc"]]                                                                  // 55
//     ["a", ["b", "desc"]]                                                                           // 56
//   (in the first form you're beholden to key enumeration order in                                   // 57
//   your javascript VM)                                                                              // 58
//                                                                                                    // 59
// reactive: if given, and false, don't register with Deps (default                                   // 60
// is true)                                                                                           // 61
//                                                                                                    // 62
// XXX possibly should support retrieving a subset of fields? and                                     // 63
// have it be a hint (ignored on the client, when not copying the                                     // 64
// doc?)                                                                                              // 65
//                                                                                                    // 66
// XXX sort does not yet support subkeys ('a.b') .. fix that!                                         // 67
// XXX add one more sort form: "key"                                                                  // 68
// XXX tests                                                                                          // 69
LocalCollection.prototype.find = function (selector, options) {                                       // 70
  // default syntax for everything is to omit the selector argument.                                  // 71
  // but if selector is explicitly passed in as false or undefined, we                                // 72
  // want a selector that matches nothing.                                                            // 73
  if (arguments.length === 0)                                                                         // 74
    selector = {};                                                                                    // 75
                                                                                                      // 76
  return new LocalCollection.Cursor(this, selector, options);                                         // 77
};                                                                                                    // 78
                                                                                                      // 79
// don't call this ctor directly.  use LocalCollection.find().                                        // 80
LocalCollection.Cursor = function (collection, selector, options) {                                   // 81
  var self = this;                                                                                    // 82
  if (!options) options = {};                                                                         // 83
                                                                                                      // 84
  this.collection = collection;                                                                       // 85
                                                                                                      // 86
  if (LocalCollection._selectorIsId(selector)) {                                                      // 87
    // stash for fast path                                                                            // 88
    self.selector_id = LocalCollection._idStringify(selector);                                        // 89
    self.selector_f = LocalCollection._compileSelector(selector);                                     // 90
    self.sort_f = undefined;                                                                          // 91
  } else {                                                                                            // 92
    self.selector_id = undefined;                                                                     // 93
    self.selector_f = LocalCollection._compileSelector(selector);                                     // 94
    self.sort_f = options.sort ? LocalCollection._compileSort(options.sort) : null;                   // 95
  }                                                                                                   // 96
  self.skip = options.skip;                                                                           // 97
  self.limit = options.limit;                                                                         // 98
  if (options.transform && typeof Deps !== "undefined")                                               // 99
    self._transform = Deps._makeNonreactive(options.transform);                                       // 100
  else                                                                                                // 101
    self._transform = options.transform;                                                              // 102
                                                                                                      // 103
  // db_objects is a list of the objects that match the cursor. (It's always a                        // 104
  // list, never an object: LocalCollection.Cursor is always ordered.)                                // 105
  self.db_objects = null;                                                                             // 106
  self.cursor_pos = 0;                                                                                // 107
                                                                                                      // 108
  // by default, queries register w/ Deps when it is available.                                       // 109
  if (typeof Deps !== "undefined")                                                                    // 110
    self.reactive = (options.reactive === undefined) ? true : options.reactive;                       // 111
};                                                                                                    // 112
                                                                                                      // 113
LocalCollection.Cursor.prototype.rewind = function () {                                               // 114
  var self = this;                                                                                    // 115
  self.db_objects = null;                                                                             // 116
  self.cursor_pos = 0;                                                                                // 117
};                                                                                                    // 118
                                                                                                      // 119
LocalCollection.prototype.findOne = function (selector, options) {                                    // 120
  if (arguments.length === 0)                                                                         // 121
    selector = {};                                                                                    // 122
                                                                                                      // 123
  // NOTE: by setting limit 1 here, we end up using very inefficient                                  // 124
  // code that recomputes the whole query on each update. The upside is                               // 125
  // that when you reactively depend on a findOne you only get                                        // 126
  // invalidated when the found object changes, not any object in the                                 // 127
  // collection. Most findOne will be by id, which has a fast path, so                                // 128
  // this might not be a big deal. In most cases, invalidation causes                                 // 129
  // the called to re-query anyway, so this should be a net performance                               // 130
  // improvement.                                                                                     // 131
  options = options || {};                                                                            // 132
  options.limit = 1;                                                                                  // 133
                                                                                                      // 134
  return this.find(selector, options).fetch()[0];                                                     // 135
};                                                                                                    // 136
                                                                                                      // 137
LocalCollection.Cursor.prototype.forEach = function (callback) {                                      // 138
  var self = this;                                                                                    // 139
  var doc;                                                                                            // 140
                                                                                                      // 141
  if (self.db_objects === null)                                                                       // 142
    self.db_objects = self._getRawObjects(true);                                                      // 143
                                                                                                      // 144
  if (self.reactive)                                                                                  // 145
    self._depend({                                                                                    // 146
      addedBefore: true,                                                                              // 147
      removed: true,                                                                                  // 148
      changed: true,                                                                                  // 149
      movedBefore: true});                                                                            // 150
                                                                                                      // 151
  while (self.cursor_pos < self.db_objects.length) {                                                  // 152
    var elt = EJSON.clone(self.db_objects[self.cursor_pos++]);                                        // 153
    if (self._transform)                                                                              // 154
      elt = self._transform(elt);                                                                     // 155
    callback(elt);                                                                                    // 156
  }                                                                                                   // 157
};                                                                                                    // 158
                                                                                                      // 159
LocalCollection.Cursor.prototype.getTransform = function () {                                         // 160
  var self = this;                                                                                    // 161
  return self._transform;                                                                             // 162
};                                                                                                    // 163
                                                                                                      // 164
LocalCollection.Cursor.prototype.map = function (callback) {                                          // 165
  var self = this;                                                                                    // 166
  var res = [];                                                                                       // 167
  self.forEach(function (doc) {                                                                       // 168
    res.push(callback(doc));                                                                          // 169
  });                                                                                                 // 170
  return res;                                                                                         // 171
};                                                                                                    // 172
                                                                                                      // 173
LocalCollection.Cursor.prototype.fetch = function () {                                                // 174
  var self = this;                                                                                    // 175
  var res = [];                                                                                       // 176
  self.forEach(function (doc) {                                                                       // 177
    res.push(doc);                                                                                    // 178
  });                                                                                                 // 179
  return res;                                                                                         // 180
};                                                                                                    // 181
                                                                                                      // 182
LocalCollection.Cursor.prototype.count = function () {                                                // 183
  var self = this;                                                                                    // 184
                                                                                                      // 185
  if (self.reactive)                                                                                  // 186
    self._depend({added: true, removed: true});                                                       // 187
                                                                                                      // 188
  if (self.db_objects === null)                                                                       // 189
    self.db_objects = self._getRawObjects(true);                                                      // 190
                                                                                                      // 191
  return self.db_objects.length;                                                                      // 192
};                                                                                                    // 193
                                                                                                      // 194
LocalCollection.Cursor.prototype._publishCursor = function (sub) {                                    // 195
  var self = this;                                                                                    // 196
  if (! self.collection.name)                                                                         // 197
    throw new Error("Can't publish a cursor from a collection without a name.");                      // 198
  var collection = self.collection.name;                                                              // 199
                                                                                                      // 200
  // XXX minimongo should not depend on mongo-livedata!                                               // 201
  return Meteor.Collection._publishCursor(self, sub, collection);                                     // 202
};                                                                                                    // 203
                                                                                                      // 204
LocalCollection._isOrderedChanges = function (callbacks) {                                            // 205
  if (callbacks.added && callbacks.addedBefore)                                                       // 206
    throw new Error("Please specify only one of added() and addedBefore()");                          // 207
  return typeof callbacks.addedBefore == 'function' ||                                                // 208
    typeof callbacks.movedBefore === 'function';                                                      // 209
};                                                                                                    // 210
                                                                                                      // 211
// the handle that comes back from observe.                                                           // 212
LocalCollection.LiveResultsSet = function () {};                                                      // 213
                                                                                                      // 214
// options to contain:                                                                                // 215
//  * callbacks for observe():                                                                        // 216
//    - addedAt (document, atIndex)                                                                   // 217
//    - added (document)                                                                              // 218
//    - changedAt (newDocument, oldDocument, atIndex)                                                 // 219
//    - changed (newDocument, oldDocument)                                                            // 220
//    - removedAt (document, atIndex)                                                                 // 221
//    - removed (document)                                                                            // 222
//    - movedTo (document, oldIndex, newIndex)                                                        // 223
//                                                                                                    // 224
// attributes available on returned query handle:                                                     // 225
//  * stop(): end updates                                                                             // 226
//  * collection: the collection this query is querying                                               // 227
//                                                                                                    // 228
// iff x is a returned query handle, (x instanceof                                                    // 229
// LocalCollection.LiveResultsSet) is true                                                            // 230
//                                                                                                    // 231
// initial results delivered through added callback                                                   // 232
// XXX maybe callbacks should take a list of objects, to expose transactions?                         // 233
// XXX maybe support field limiting (to limit what you're notified on)                                // 234
                                                                                                      // 235
_.extend(LocalCollection.Cursor.prototype, {                                                          // 236
  observe: function (options) {                                                                       // 237
    var self = this;                                                                                  // 238
    return LocalCollection._observeFromObserveChanges(self, options);                                 // 239
  },                                                                                                  // 240
  observeChanges: function (options) {                                                                // 241
    var self = this;                                                                                  // 242
                                                                                                      // 243
    var ordered = LocalCollection._isOrderedChanges(options);                                         // 244
                                                                                                      // 245
    if (!ordered && (self.skip || self.limit))                                                        // 246
      throw new Error("must use ordered observe with skip or limit");                                 // 247
                                                                                                      // 248
    // XXX merge this object w/ "this" Cursor.  they're the same.                                     // 249
    var query = {                                                                                     // 250
      selector_f: self.selector_f, // not fast pathed                                                 // 251
      sort_f: ordered && self.sort_f,                                                                 // 252
      results_snapshot: null,                                                                         // 253
      ordered: ordered,                                                                               // 254
      cursor: this,                                                                                   // 255
      observeChanges: options.observeChanges                                                          // 256
    };                                                                                                // 257
    var qid;                                                                                          // 258
                                                                                                      // 259
    // Non-reactive queries call added[Before] and then never call anything                           // 260
    // else.                                                                                          // 261
    if (self.reactive) {                                                                              // 262
      qid = self.collection.next_qid++;                                                               // 263
      self.collection.queries[qid] = query;                                                           // 264
    }                                                                                                 // 265
    query.results = self._getRawObjects(ordered);                                                     // 266
    if (self.collection.paused)                                                                       // 267
      query.results_snapshot = (ordered ? [] : {});                                                   // 268
                                                                                                      // 269
    // wrap callbacks we were passed. callbacks only fire when not paused and                         // 270
    // are never undefined (except that query.moved is undefined for unordered                        // 271
    // callbacks).                                                                                    // 272
                                                                                                      // 273
    // furthermore, callbacks enqueue until the operation we're working on is                         // 274
    // done.                                                                                          // 275
    var wrapCallback = function (f) {                                                                 // 276
      if (!f)                                                                                         // 277
        return function () {};                                                                        // 278
      return function (/*args*/) {                                                                    // 279
        var context = this;                                                                           // 280
        var args = arguments;                                                                         // 281
        if (!self.collection.paused) {                                                                // 282
          self.collection._observeQueue.queueTask(function () {                                       // 283
            f.apply(context, args);                                                                   // 284
          });                                                                                         // 285
        }                                                                                             // 286
      };                                                                                              // 287
    };                                                                                                // 288
    query.added = wrapCallback(options.added);                                                        // 289
    query.changed = wrapCallback(options.changed);                                                    // 290
    query.removed = wrapCallback(options.removed);                                                    // 291
    if (ordered) {                                                                                    // 292
      query.moved = wrapCallback(options.moved);                                                      // 293
      query.addedBefore = wrapCallback(options.addedBefore);                                          // 294
      query.movedBefore = wrapCallback(options.movedBefore);                                          // 295
    }                                                                                                 // 296
                                                                                                      // 297
    if (!options._suppress_initial && !self.collection.paused) {                                      // 298
      _.each(query.results, function (doc, i) {                                                       // 299
        var fields = EJSON.clone(doc);                                                                // 300
        delete fields._id;                                                                            // 301
        if (ordered)                                                                                  // 302
          query.addedBefore(doc._id, fields, null);                                                   // 303
        query.added(doc._id, fields);                                                                 // 304
      });                                                                                             // 305
    }                                                                                                 // 306
                                                                                                      // 307
    var handle = new LocalCollection.LiveResultsSet;                                                  // 308
    _.extend(handle, {                                                                                // 309
      collection: self.collection,                                                                    // 310
      stop: function () {                                                                             // 311
        if (self.reactive)                                                                            // 312
          delete self.collection.queries[qid];                                                        // 313
      }                                                                                               // 314
    });                                                                                               // 315
                                                                                                      // 316
    if (self.reactive && Deps.active) {                                                               // 317
      // XXX in many cases, the same observe will be recreated when                                   // 318
      // the current autorun is rerun.  we could save work by                                         // 319
      // letting it linger across rerun and potentially get                                           // 320
      // repurposed if the same observe is performed, using logic                                     // 321
      // similar to that of Meteor.subscribe.                                                         // 322
      Deps.onInvalidate(function () {                                                                 // 323
        handle.stop();                                                                                // 324
      });                                                                                             // 325
    }                                                                                                 // 326
    // run the observe callbacks resulting from the initial contents                                  // 327
    // before we leave the observe.                                                                   // 328
    self.collection._observeQueue.drain();                                                            // 329
                                                                                                      // 330
    return handle;                                                                                    // 331
  }                                                                                                   // 332
});                                                                                                   // 333
                                                                                                      // 334
// Returns a collection of matching objects, but doesn't deep copy them.                              // 335
//                                                                                                    // 336
// If ordered is set, returns a sorted array, respecting sort_f, skip, and limit                      // 337
// properties of the query.  if sort_f is falsey, no sort -- you get the natural                      // 338
// order.                                                                                             // 339
//                                                                                                    // 340
// If ordered is not set, returns an object mapping from ID to doc (sort_f, skip                      // 341
// and limit should not be set).                                                                      // 342
LocalCollection.Cursor.prototype._getRawObjects = function (ordered) {                                // 343
  var self = this;                                                                                    // 344
                                                                                                      // 345
  var results = ordered ? [] : {};                                                                    // 346
                                                                                                      // 347
  // fast path for single ID value                                                                    // 348
  if (self.selector_id) {                                                                             // 349
    // If you have non-zero skip and ask for a single id, you get                                     // 350
    // nothing. This is so it matches the behavior of the '{_id: foo}'                                // 351
    // path.                                                                                          // 352
    if (self.skip)                                                                                    // 353
      return results;                                                                                 // 354
                                                                                                      // 355
    if (_.has(self.collection.docs, self.selector_id)) {                                              // 356
      var selectedDoc = self.collection.docs[self.selector_id];                                       // 357
      if (ordered)                                                                                    // 358
        results.push(selectedDoc);                                                                    // 359
      else                                                                                            // 360
        results[self.selector_id] = selectedDoc;                                                      // 361
    }                                                                                                 // 362
    return results;                                                                                   // 363
  }                                                                                                   // 364
                                                                                                      // 365
  // slow path for arbitrary selector, sort, skip, limit                                              // 366
  for (var id in self.collection.docs) {                                                              // 367
    var doc = self.collection.docs[id];                                                               // 368
    if (self.selector_f(doc)) {                                                                       // 369
      if (ordered)                                                                                    // 370
        results.push(doc);                                                                            // 371
      else                                                                                            // 372
        results[id] = doc;                                                                            // 373
    }                                                                                                 // 374
    // Fast path for limited unsorted queries.                                                        // 375
    if (self.limit && !self.skip && !self.sort_f &&                                                   // 376
        results.length === self.limit)                                                                // 377
      return results;                                                                                 // 378
  }                                                                                                   // 379
                                                                                                      // 380
  if (!ordered)                                                                                       // 381
    return results;                                                                                   // 382
                                                                                                      // 383
  if (self.sort_f)                                                                                    // 384
    results.sort(self.sort_f);                                                                        // 385
                                                                                                      // 386
  var idx_start = self.skip || 0;                                                                     // 387
  var idx_end = self.limit ? (self.limit + idx_start) : results.length;                               // 388
  return results.slice(idx_start, idx_end);                                                           // 389
};                                                                                                    // 390
                                                                                                      // 391
// XXX Maybe we need a version of observe that just calls a callback if                               // 392
// anything changed.                                                                                  // 393
LocalCollection.Cursor.prototype._depend = function (changers) {                                      // 394
  var self = this;                                                                                    // 395
                                                                                                      // 396
  if (Deps.active) {                                                                                  // 397
    var v = new Deps.Dependency;                                                                      // 398
    v.depend();                                                                                       // 399
    var notifyChange = _.bind(v.changed, v);                                                          // 400
                                                                                                      // 401
    var options = {_suppress_initial: true};                                                          // 402
    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],                             // 403
           function (fnName) {                                                                        // 404
             if (changers[fnName])                                                                    // 405
               options[fnName] = notifyChange;                                                        // 406
           });                                                                                        // 407
                                                                                                      // 408
    // observeChanges will stop() when this computation is invalidated                                // 409
    self.observeChanges(options);                                                                     // 410
  }                                                                                                   // 411
};                                                                                                    // 412
                                                                                                      // 413
// XXX enforce rule that field names can't start with '$' or contain '.'                              // 414
// (real mongodb does in fact enforce this)                                                           // 415
// XXX possibly enforce that 'undefined' does not appear (we assume                                   // 416
// this in our handling of null and $exists)                                                          // 417
LocalCollection.prototype.insert = function (doc, callback) {                                         // 418
  var self = this;                                                                                    // 419
  doc = EJSON.clone(doc);                                                                             // 420
                                                                                                      // 421
  if (!_.has(doc, '_id')) {                                                                           // 422
    // if you really want to use ObjectIDs, set this global.                                          // 423
    // Meteor.Collection specifies its own ids and does not use this code.                            // 424
    doc._id = LocalCollection._useOID ? new LocalCollection._ObjectID()                               // 425
                                      : Random.id();                                                  // 426
  }                                                                                                   // 427
  var id = LocalCollection._idStringify(doc._id);                                                     // 428
                                                                                                      // 429
  if (_.has(self.docs, doc._id))                                                                      // 430
    throw MinimongoError("Duplicate _id '" + doc._id + "'");                                          // 431
                                                                                                      // 432
  self._saveOriginal(id, undefined);                                                                  // 433
  self.docs[id] = doc;                                                                                // 434
                                                                                                      // 435
  var queriesToRecompute = [];                                                                        // 436
  // trigger live queries that match                                                                  // 437
  for (var qid in self.queries) {                                                                     // 438
    var query = self.queries[qid];                                                                    // 439
    if (query.selector_f(doc)) {                                                                      // 440
      if (query.cursor.skip || query.cursor.limit)                                                    // 441
        queriesToRecompute.push(qid);                                                                 // 442
      else                                                                                            // 443
        LocalCollection._insertInResults(query, doc);                                                 // 444
    }                                                                                                 // 445
  }                                                                                                   // 446
                                                                                                      // 447
  _.each(queriesToRecompute, function (qid) {                                                         // 448
    if (self.queries[qid])                                                                            // 449
      LocalCollection._recomputeResults(self.queries[qid]);                                           // 450
  });                                                                                                 // 451
  self._observeQueue.drain();                                                                         // 452
  // Defer in case the callback returns on a future; gives the caller time to                         // 453
  // wait on the future.                                                                              // 454
  if (callback) Meteor.defer(function () { callback(null, doc._id); });                               // 455
  return doc._id;                                                                                     // 456
};                                                                                                    // 457
                                                                                                      // 458
LocalCollection.prototype.remove = function (selector, callback) {                                    // 459
  var self = this;                                                                                    // 460
  var remove = [];                                                                                    // 461
                                                                                                      // 462
  var queriesToRecompute = [];                                                                        // 463
  var selector_f = LocalCollection._compileSelector(selector);                                        // 464
                                                                                                      // 465
  // Avoid O(n) for "remove a single doc by ID".                                                      // 466
  var specificIds = LocalCollection._idsMatchedBySelector(selector);                                  // 467
  if (specificIds) {                                                                                  // 468
    _.each(specificIds, function (id) {                                                               // 469
      var strId = LocalCollection._idStringify(id);                                                   // 470
      // We still have to run selector_f, in case it's something like                                 // 471
      //   {_id: "X", a: 42}                                                                          // 472
      if (_.has(self.docs, strId) && selector_f(self.docs[strId]))                                    // 473
        remove.push(strId);                                                                           // 474
    });                                                                                               // 475
  } else {                                                                                            // 476
    for (var id in self.docs) {                                                                       // 477
      var doc = self.docs[id];                                                                        // 478
      if (selector_f(doc)) {                                                                          // 479
        remove.push(id);                                                                              // 480
      }                                                                                               // 481
    }                                                                                                 // 482
  }                                                                                                   // 483
                                                                                                      // 484
  var queryRemove = [];                                                                               // 485
  for (var i = 0; i < remove.length; i++) {                                                           // 486
    var removeId = remove[i];                                                                         // 487
    var removeDoc = self.docs[removeId];                                                              // 488
    _.each(self.queries, function (query, qid) {                                                      // 489
      if (query.selector_f(removeDoc)) {                                                              // 490
        if (query.cursor.skip || query.cursor.limit)                                                  // 491
          queriesToRecompute.push(qid);                                                               // 492
        else                                                                                          // 493
          queryRemove.push({qid: qid, doc: removeDoc});                                               // 494
      }                                                                                               // 495
    });                                                                                               // 496
    self._saveOriginal(removeId, removeDoc);                                                          // 497
    delete self.docs[removeId];                                                                       // 498
  }                                                                                                   // 499
                                                                                                      // 500
  // run live query callbacks _after_ we've removed the documents.                                    // 501
  _.each(queryRemove, function (remove) {                                                             // 502
    var query = self.queries[remove.qid];                                                             // 503
    if (query)                                                                                        // 504
      LocalCollection._removeFromResults(query, remove.doc);                                          // 505
  });                                                                                                 // 506
  _.each(queriesToRecompute, function (qid) {                                                         // 507
    var query = self.queries[qid];                                                                    // 508
    if (query)                                                                                        // 509
      LocalCollection._recomputeResults(query);                                                       // 510
  });                                                                                                 // 511
  self._observeQueue.drain();                                                                         // 512
  // Defer in case the callback returns on a future; gives the caller time to                         // 513
  // wait on the future.                                                                              // 514
  if (callback) Meteor.defer(callback);                                                               // 515
};                                                                                                    // 516
                                                                                                      // 517
// XXX atomicity: if multi is true, and one modification fails, do                                    // 518
// we rollback the whole operation, or what?                                                          // 519
LocalCollection.prototype.update = function (selector, mod, options, callback) {                      // 520
  var self = this;                                                                                    // 521
  if (! callback && options instanceof Function) {                                                    // 522
    callback = options;                                                                               // 523
    options = null;                                                                                   // 524
  }                                                                                                   // 525
  if (!options) options = {};                                                                         // 526
                                                                                                      // 527
  if (options.upsert)                                                                                 // 528
    throw new Error("upsert not yet implemented");                                                    // 529
                                                                                                      // 530
  var selector_f = LocalCollection._compileSelector(selector);                                        // 531
                                                                                                      // 532
  // Save the original results of any query that we might need to                                     // 533
  // _recomputeResults on, because _modifyAndNotify will mutate the objects in                        // 534
  // it. (We don't need to save the original results of paused queries because                        // 535
  // they already have a results_snapshot and we won't be diffing in                                  // 536
  // _recomputeResults.)                                                                              // 537
  var qidToOriginalResults = {};                                                                      // 538
  _.each(self.queries, function (query, qid) {                                                        // 539
    if ((query.cursor.skip || query.cursor.limit) && !query.paused)                                   // 540
      qidToOriginalResults[qid] = EJSON.clone(query.results);                                         // 541
  });                                                                                                 // 542
  var recomputeQids = {};                                                                             // 543
                                                                                                      // 544
  for (var id in self.docs) {                                                                         // 545
    var doc = self.docs[id];                                                                          // 546
    if (selector_f(doc)) {                                                                            // 547
      // XXX Should we save the original even if mod ends up being a no-op?                           // 548
      self._saveOriginal(id, doc);                                                                    // 549
      self._modifyAndNotify(doc, mod, recomputeQids);                                                 // 550
      if (!options.multi)                                                                             // 551
        break;                                                                                        // 552
    }                                                                                                 // 553
  }                                                                                                   // 554
                                                                                                      // 555
  _.each(recomputeQids, function (dummy, qid) {                                                       // 556
    var query = self.queries[qid];                                                                    // 557
    if (query)                                                                                        // 558
      LocalCollection._recomputeResults(query,                                                        // 559
                                        qidToOriginalResults[qid]);                                   // 560
  });                                                                                                 // 561
  self._observeQueue.drain();                                                                         // 562
  // Defer in case the callback returns on a future; gives the caller time to                         // 563
  // wait on the future.                                                                              // 564
  if (callback) Meteor.defer(callback);                                                               // 565
};                                                                                                    // 566
                                                                                                      // 567
LocalCollection.prototype._modifyAndNotify = function (                                               // 568
    doc, mod, recomputeQids) {                                                                        // 569
  var self = this;                                                                                    // 570
                                                                                                      // 571
  var matched_before = {};                                                                            // 572
  for (var qid in self.queries) {                                                                     // 573
    var query = self.queries[qid];                                                                    // 574
    if (query.ordered) {                                                                              // 575
      matched_before[qid] = query.selector_f(doc);                                                    // 576
    } else {                                                                                          // 577
      // Because we don't support skip or limit (yet) in unordered queries, we                        // 578
      // can just do a direct lookup.                                                                 // 579
      matched_before[qid] = _.has(query.results,                                                      // 580
                                  LocalCollection._idStringify(doc._id));                             // 581
    }                                                                                                 // 582
  }                                                                                                   // 583
                                                                                                      // 584
  var old_doc = EJSON.clone(doc);                                                                     // 585
                                                                                                      // 586
  LocalCollection._modify(doc, mod);                                                                  // 587
                                                                                                      // 588
  for (qid in self.queries) {                                                                         // 589
    query = self.queries[qid];                                                                        // 590
    var before = matched_before[qid];                                                                 // 591
    var after = query.selector_f(doc);                                                                // 592
                                                                                                      // 593
    if (query.cursor.skip || query.cursor.limit) {                                                    // 594
      // We need to recompute any query where the doc may have been in the                            // 595
      // cursor's window either before or after the update. (Note that if skip                        // 596
      // or limit is set, "before" and "after" being true do not necessarily                          // 597
      // mean that the document is in the cursor's output after skip/limit is                         // 598
      // applied... but if they are false, then the document definitely is NOT                        // 599
      // in the output. So it's safe to skip recompute if neither before or                           // 600
      // after are true.)                                                                             // 601
      if (before || after)                                                                            // 602
	recomputeQids[qid] = true;                                                                           // 603
    } else if (before && !after) {                                                                    // 604
      LocalCollection._removeFromResults(query, doc);                                                 // 605
    } else if (!before && after) {                                                                    // 606
      LocalCollection._insertInResults(query, doc);                                                   // 607
    } else if (before && after) {                                                                     // 608
      LocalCollection._updateInResults(query, doc, old_doc);                                          // 609
    }                                                                                                 // 610
  }                                                                                                   // 611
};                                                                                                    // 612
                                                                                                      // 613
// XXX the sorted-query logic below is laughably inefficient. we'll                                   // 614
// need to come up with a better datastructure for this.                                              // 615
//                                                                                                    // 616
// XXX the logic for observing with a skip or a limit is even more                                    // 617
// laughably inefficient. we recompute the whole results every time!                                  // 618
                                                                                                      // 619
LocalCollection._insertInResults = function (query, doc) {                                            // 620
  var fields = EJSON.clone(doc);                                                                      // 621
  delete fields._id;                                                                                  // 622
  if (query.ordered) {                                                                                // 623
    if (!query.sort_f) {                                                                              // 624
      query.addedBefore(doc._id, fields, null);                                                       // 625
      query.results.push(doc);                                                                        // 626
    } else {                                                                                          // 627
      var i = LocalCollection._insertInSortedList(                                                    // 628
        query.sort_f, query.results, doc);                                                            // 629
      var next = query.results[i+1];                                                                  // 630
      if (next)                                                                                       // 631
        next = next._id;                                                                              // 632
      else                                                                                            // 633
        next = null;                                                                                  // 634
      query.addedBefore(doc._id, fields, next);                                                       // 635
    }                                                                                                 // 636
    query.added(doc._id, fields);                                                                     // 637
  } else {                                                                                            // 638
    query.added(doc._id, fields);                                                                     // 639
    query.results[LocalCollection._idStringify(doc._id)] = doc;                                       // 640
  }                                                                                                   // 641
};                                                                                                    // 642
                                                                                                      // 643
LocalCollection._removeFromResults = function (query, doc) {                                          // 644
  if (query.ordered) {                                                                                // 645
    var i = LocalCollection._findInOrderedResults(query, doc);                                        // 646
    query.removed(doc._id);                                                                           // 647
    query.results.splice(i, 1);                                                                       // 648
  } else {                                                                                            // 649
    var id = LocalCollection._idStringify(doc._id);  // in case callback mutates doc                  // 650
    query.removed(doc._id);                                                                           // 651
    delete query.results[id];                                                                         // 652
  }                                                                                                   // 653
};                                                                                                    // 654
                                                                                                      // 655
LocalCollection._updateInResults = function (query, doc, old_doc) {                                   // 656
  if (!EJSON.equals(doc._id, old_doc._id))                                                            // 657
    throw new Error("Can't change a doc's _id while updating");                                       // 658
  var changedFields = LocalCollection._makeChangedFields(doc, old_doc);                               // 659
  if (!query.ordered) {                                                                               // 660
    if (!_.isEmpty(changedFields)) {                                                                  // 661
      query.changed(doc._id, changedFields);                                                          // 662
      query.results[LocalCollection._idStringify(doc._id)] = doc;                                     // 663
    }                                                                                                 // 664
    return;                                                                                           // 665
  }                                                                                                   // 666
                                                                                                      // 667
  var orig_idx = LocalCollection._findInOrderedResults(query, doc);                                   // 668
                                                                                                      // 669
  if (!_.isEmpty(changedFields))                                                                      // 670
    query.changed(doc._id, changedFields);                                                            // 671
  if (!query.sort_f)                                                                                  // 672
    return;                                                                                           // 673
                                                                                                      // 674
  // just take it out and put it back in again, and see if the index                                  // 675
  // changes                                                                                          // 676
  query.results.splice(orig_idx, 1);                                                                  // 677
  var new_idx = LocalCollection._insertInSortedList(                                                  // 678
    query.sort_f, query.results, doc);                                                                // 679
  if (orig_idx !== new_idx) {                                                                         // 680
    var next = query.results[new_idx+1];                                                              // 681
    if (next)                                                                                         // 682
      next = next._id;                                                                                // 683
    else                                                                                              // 684
      next = null;                                                                                    // 685
    query.movedBefore && query.movedBefore(doc._id, next);                                            // 686
  }                                                                                                   // 687
};                                                                                                    // 688
                                                                                                      // 689
// Recomputes the results of a query and runs observe callbacks for the                               // 690
// difference between the previous results and the current results (unless                            // 691
// paused). Used for skip/limit queries.                                                              // 692
//                                                                                                    // 693
// When this is used by insert or remove, it can just use query.results for the                       // 694
// old results (and there's no need to pass in oldResults), because these                             // 695
// operations don't mutate the documents in the collection. Update needs to pass                      // 696
// in an oldResults which was deep-copied before the modifier was applied.                            // 697
LocalCollection._recomputeResults = function (query, oldResults) {                                    // 698
  if (!oldResults)                                                                                    // 699
    oldResults = query.results;                                                                       // 700
  query.results = query.cursor._getRawObjects(query.ordered);                                         // 701
                                                                                                      // 702
  if (!query.paused) {                                                                                // 703
    LocalCollection._diffQueryChanges(                                                                // 704
      query.ordered, oldResults, query.results, query);                                               // 705
  }                                                                                                   // 706
};                                                                                                    // 707
                                                                                                      // 708
                                                                                                      // 709
LocalCollection._findInOrderedResults = function (query, doc) {                                       // 710
  if (!query.ordered)                                                                                 // 711
    throw new Error("Can't call _findInOrderedResults on unordered query");                           // 712
  for (var i = 0; i < query.results.length; i++)                                                      // 713
    if (query.results[i] === doc)                                                                     // 714
      return i;                                                                                       // 715
  throw Error("object missing from query");                                                           // 716
};                                                                                                    // 717
                                                                                                      // 718
// This binary search puts a value between any equal values, and the first                            // 719
// lesser value.                                                                                      // 720
LocalCollection._binarySearch = function (cmp, array, value) {                                        // 721
  var first = 0, rangeLength = array.length;                                                          // 722
                                                                                                      // 723
  while (rangeLength > 0) {                                                                           // 724
    var halfRange = Math.floor(rangeLength/2);                                                        // 725
    if (cmp(value, array[first + halfRange]) >= 0) {                                                  // 726
      first += halfRange + 1;                                                                         // 727
      rangeLength -= halfRange + 1;                                                                   // 728
    } else {                                                                                          // 729
      rangeLength = halfRange;                                                                        // 730
    }                                                                                                 // 731
  }                                                                                                   // 732
  return first;                                                                                       // 733
};                                                                                                    // 734
                                                                                                      // 735
LocalCollection._insertInSortedList = function (cmp, array, value) {                                  // 736
  if (array.length === 0) {                                                                           // 737
    array.push(value);                                                                                // 738
    return 0;                                                                                         // 739
  }                                                                                                   // 740
                                                                                                      // 741
  var idx = LocalCollection._binarySearch(cmp, array, value);                                         // 742
  array.splice(idx, 0, value);                                                                        // 743
  return idx;                                                                                         // 744
};                                                                                                    // 745
                                                                                                      // 746
// To track what documents are affected by a piece of code, call saveOriginals()                      // 747
// before it and retrieveOriginals() after it. retrieveOriginals returns an                           // 748
// object whose keys are the ids of the documents that were affected since the                        // 749
// call to saveOriginals(), and the values are equal to the document's contents                       // 750
// at the time of saveOriginals. (In the case of an inserted document, undefined                      // 751
// is the value.) You must alternate between calls to saveOriginals() and                             // 752
// retrieveOriginals().                                                                               // 753
LocalCollection.prototype.saveOriginals = function () {                                               // 754
  var self = this;                                                                                    // 755
  if (self._savedOriginals)                                                                           // 756
    throw new Error("Called saveOriginals twice without retrieveOriginals");                          // 757
  self._savedOriginals = {};                                                                          // 758
};                                                                                                    // 759
LocalCollection.prototype.retrieveOriginals = function () {                                           // 760
  var self = this;                                                                                    // 761
  if (!self._savedOriginals)                                                                          // 762
    throw new Error("Called retrieveOriginals without saveOriginals");                                // 763
                                                                                                      // 764
  var originals = self._savedOriginals;                                                               // 765
  self._savedOriginals = null;                                                                        // 766
  return originals;                                                                                   // 767
};                                                                                                    // 768
                                                                                                      // 769
LocalCollection.prototype._saveOriginal = function (id, doc) {                                        // 770
  var self = this;                                                                                    // 771
  // Are we even trying to save originals?                                                            // 772
  if (!self._savedOriginals)                                                                          // 773
    return;                                                                                           // 774
  // Have we previously mutated the original (and so 'doc' is not actually                            // 775
  // original)?  (Note the 'has' check rather than truth: we store undefined                          // 776
  // here for inserted docs!)                                                                         // 777
  if (_.has(self._savedOriginals, id))                                                                // 778
    return;                                                                                           // 779
  self._savedOriginals[id] = EJSON.clone(doc);                                                        // 780
};                                                                                                    // 781
                                                                                                      // 782
// Pause the observers. No callbacks from observers will fire until                                   // 783
// 'resumeObservers' is called.                                                                       // 784
LocalCollection.prototype.pauseObservers = function () {                                              // 785
  // No-op if already paused.                                                                         // 786
  if (this.paused)                                                                                    // 787
    return;                                                                                           // 788
                                                                                                      // 789
  // Set the 'paused' flag such that new observer messages don't fire.                                // 790
  this.paused = true;                                                                                 // 791
                                                                                                      // 792
  // Take a snapshot of the query results for each query.                                             // 793
  for (var qid in this.queries) {                                                                     // 794
    var query = this.queries[qid];                                                                    // 795
                                                                                                      // 796
    query.results_snapshot = EJSON.clone(query.results);                                              // 797
  }                                                                                                   // 798
};                                                                                                    // 799
                                                                                                      // 800
// Resume the observers. Observers immediately receive change                                         // 801
// notifications to bring them to the current state of the                                            // 802
// database. Note that this is not just replaying all the changes that                                // 803
// happened during the pause, it is a smarter 'coalesced' diff.                                       // 804
LocalCollection.prototype.resumeObservers = function () {                                             // 805
  var self = this;                                                                                    // 806
  // No-op if not paused.                                                                             // 807
  if (!this.paused)                                                                                   // 808
    return;                                                                                           // 809
                                                                                                      // 810
  // Unset the 'paused' flag. Make sure to do this first, otherwise                                   // 811
  // observer methods won't actually fire when we trigger them.                                       // 812
  this.paused = false;                                                                                // 813
                                                                                                      // 814
  for (var qid in this.queries) {                                                                     // 815
    var query = self.queries[qid];                                                                    // 816
    // Diff the current results against the snapshot and send to observers.                           // 817
    // pass the query object for its observer callbacks.                                              // 818
    LocalCollection._diffQueryChanges(                                                                // 819
      query.ordered, query.results_snapshot, query.results, query);                                   // 820
    query.results_snapshot = null;                                                                    // 821
  }                                                                                                   // 822
  self._observeQueue.drain();                                                                         // 823
};                                                                                                    // 824
                                                                                                      // 825
                                                                                                      // 826
// NB: used by livedata                                                                               // 827
LocalCollection._idStringify = function (id) {                                                        // 828
  if (id instanceof LocalCollection._ObjectID) {                                                      // 829
    return id.valueOf();                                                                              // 830
  } else if (typeof id === 'string') {                                                                // 831
    if (id === "") {                                                                                  // 832
      return id;                                                                                      // 833
    } else if (id.substr(0, 1) === "-" || // escape previously dashed strings                         // 834
               id.substr(0, 1) === "~" || // escape escaped numbers, true, false                      // 835
               LocalCollection._looksLikeObjectID(id) || // escape object-id-form strings             // 836
               id.substr(0, 1) === '{') { // escape object-form strings, for maybe implementing later // 837
      return "-" + id;                                                                                // 838
    } else {                                                                                          // 839
      return id; // other strings go through unchanged.                                               // 840
    }                                                                                                 // 841
  } else if (id === undefined) {                                                                      // 842
    return '-';                                                                                       // 843
  } else if (typeof id === 'object' && id !== null) {                                                 // 844
    throw new Error("Meteor does not currently support objects other than ObjectID as ids");          // 845
  } else { // Numbers, true, false, null                                                              // 846
    return "~" + JSON.stringify(id);                                                                  // 847
  }                                                                                                   // 848
};                                                                                                    // 849
                                                                                                      // 850
                                                                                                      // 851
// NB: used by livedata                                                                               // 852
LocalCollection._idParse = function (id) {                                                            // 853
  if (id === "") {                                                                                    // 854
    return id;                                                                                        // 855
  } else if (id === '-') {                                                                            // 856
    return undefined;                                                                                 // 857
  } else if (id.substr(0, 1) === '-') {                                                               // 858
    return id.substr(1);                                                                              // 859
  } else if (id.substr(0, 1) === '~') {                                                               // 860
    return JSON.parse(id.substr(1));                                                                  // 861
  } else if (LocalCollection._looksLikeObjectID(id)) {                                                // 862
    return new LocalCollection._ObjectID(id);                                                         // 863
  } else {                                                                                            // 864
    return id;                                                                                        // 865
  }                                                                                                   // 866
};                                                                                                    // 867
                                                                                                      // 868
LocalCollection._makeChangedFields = function (newDoc, oldDoc) {                                      // 869
  var fields = {};                                                                                    // 870
  LocalCollection._diffObjects(oldDoc, newDoc, {                                                      // 871
    leftOnly: function (key, value) {                                                                 // 872
      fields[key] = undefined;                                                                        // 873
    },                                                                                                // 874
    rightOnly: function (key, value) {                                                                // 875
      fields[key] = value;                                                                            // 876
    },                                                                                                // 877
    both: function (key, leftValue, rightValue) {                                                     // 878
      if (!EJSON.equals(leftValue, rightValue))                                                       // 879
        fields[key] = rightValue;                                                                     // 880
    }                                                                                                 // 881
  });                                                                                                 // 882
  return fields;                                                                                      // 883
};                                                                                                    // 884
                                                                                                      // 885
LocalCollection._observeFromObserveChanges = function (cursor, callbacks) {                           // 886
  var transform = cursor.getTransform();                                                              // 887
  if (!transform)                                                                                     // 888
    transform = function (doc) {return doc;};                                                         // 889
  if (callbacks.addedAt && callbacks.added)                                                           // 890
    throw new Error("Please specify only one of added() and addedAt()");                              // 891
  if (callbacks.changedAt && callbacks.changed)                                                       // 892
    throw new Error("Please specify only one of changed() and changedAt()");                          // 893
  if (callbacks.removed && callbacks.removedAt)                                                       // 894
    throw new Error("Please specify only one of removed() and removedAt()");                          // 895
  if (callbacks.addedAt || callbacks.movedTo ||                                                       // 896
      callbacks.changedAt || callbacks.removedAt)                                                     // 897
    return LocalCollection._observeOrderedFromObserveChanges(cursor, callbacks, transform);           // 898
  else                                                                                                // 899
    return LocalCollection._observeUnorderedFromObserveChanges(cursor, callbacks, transform);         // 900
};                                                                                                    // 901
                                                                                                      // 902
LocalCollection._observeUnorderedFromObserveChanges =                                                 // 903
    function (cursor, callbacks, transform) {                                                         // 904
  var docs = {};                                                                                      // 905
  var suppressed = !!callbacks._suppress_initial;                                                     // 906
  var handle = cursor.observeChanges({                                                                // 907
    added: function (id, fields) {                                                                    // 908
      var strId = LocalCollection._idStringify(id);                                                   // 909
      var doc = EJSON.clone(fields);                                                                  // 910
      doc._id = id;                                                                                   // 911
      docs[strId] = doc;                                                                              // 912
      suppressed || callbacks.added && callbacks.added(transform(doc));                               // 913
    },                                                                                                // 914
    changed: function (id, fields) {                                                                  // 915
      var strId = LocalCollection._idStringify(id);                                                   // 916
      var doc = docs[strId];                                                                          // 917
      var oldDoc = EJSON.clone(doc);                                                                  // 918
      // writes through to the doc set                                                                // 919
      LocalCollection._applyChanges(doc, fields);                                                     // 920
      suppressed || callbacks.changed && callbacks.changed(transform(doc), transform(oldDoc));        // 921
    },                                                                                                // 922
    removed: function (id) {                                                                          // 923
      var strId = LocalCollection._idStringify(id);                                                   // 924
      var doc = docs[strId];                                                                          // 925
      delete docs[strId];                                                                             // 926
      suppressed || callbacks.removed && callbacks.removed(transform(doc));                           // 927
    }                                                                                                 // 928
  });                                                                                                 // 929
  suppressed = false;                                                                                 // 930
  return handle;                                                                                      // 931
};                                                                                                    // 932
                                                                                                      // 933
LocalCollection._observeOrderedFromObserveChanges =                                                   // 934
    function (cursor, callbacks, transform) {                                                         // 935
  var docs = new OrderedDict(LocalCollection._idStringify);                                           // 936
  var suppressed = !!callbacks._suppress_initial;                                                     // 937
  // The "_no_indices" option sets all index arguments to -1                                          // 938
  // and skips the linear scans required to generate them.                                            // 939
  // This lets observers that don't need absolute indices                                             // 940
  // benefit from the other features of this API --                                                   // 941
  // relative order, transforms, and applyChanges -- without                                          // 942
  // the speed hit.                                                                                   // 943
  var indices = !callbacks._no_indices;                                                               // 944
  var handle = cursor.observeChanges({                                                                // 945
    addedBefore: function (id, fields, before) {                                                      // 946
      var doc = EJSON.clone(fields);                                                                  // 947
      doc._id = id;                                                                                   // 948
      // XXX could `before` be a falsy ID?  Technically                                               // 949
      // idStringify seems to allow for them -- though                                                // 950
      // OrderedDict won't call stringify on a falsy arg.                                             // 951
      docs.putBefore(id, doc, before || null);                                                        // 952
      if (!suppressed) {                                                                              // 953
        if (callbacks.addedAt) {                                                                      // 954
          var index = indices ? docs.indexOf(id) : -1;                                                // 955
          callbacks.addedAt(transform(EJSON.clone(doc)),                                              // 956
                            index, before);                                                           // 957
        } else if (callbacks.added) {                                                                 // 958
          callbacks.added(transform(EJSON.clone(doc)));                                               // 959
        }                                                                                             // 960
      }                                                                                               // 961
    },                                                                                                // 962
    changed: function (id, fields) {                                                                  // 963
      var doc = docs.get(id);                                                                         // 964
      if (!doc)                                                                                       // 965
        throw new Error("Unknown id for changed: " + id);                                             // 966
      var oldDoc = EJSON.clone(doc);                                                                  // 967
      // writes through to the doc set                                                                // 968
      LocalCollection._applyChanges(doc, fields);                                                     // 969
      if (callbacks.changedAt) {                                                                      // 970
        var index = indices ? docs.indexOf(id) : -1;                                                  // 971
        callbacks.changedAt(transform(EJSON.clone(doc)),                                              // 972
                            transform(oldDoc), index);                                                // 973
      } else if (callbacks.changed) {                                                                 // 974
        callbacks.changed(transform(EJSON.clone(doc)),                                                // 975
                          transform(oldDoc));                                                         // 976
      }                                                                                               // 977
    },                                                                                                // 978
    movedBefore: function (id, before) {                                                              // 979
      var doc = docs.get(id);                                                                         // 980
      var from;                                                                                       // 981
      // only capture indexes if we're going to call the callback that needs them.                    // 982
      if (callbacks.movedTo)                                                                          // 983
        from = indices ? docs.indexOf(id) : -1;                                                       // 984
      docs.moveBefore(id, before || null);                                                            // 985
      if (callbacks.movedTo) {                                                                        // 986
        var to = indices ? docs.indexOf(id) : -1;                                                     // 987
        callbacks.movedTo(transform(EJSON.clone(doc)), from, to,                                      // 988
                          before || null);                                                            // 989
      } else if (callbacks.moved) {                                                                   // 990
        callbacks.moved(transform(EJSON.clone(doc)));                                                 // 991
      }                                                                                               // 992
                                                                                                      // 993
    },                                                                                                // 994
    removed: function (id) {                                                                          // 995
      var doc = docs.get(id);                                                                         // 996
      var index;                                                                                      // 997
      if (callbacks.removedAt)                                                                        // 998
        index = indices ? docs.indexOf(id) : -1;                                                      // 999
      docs.remove(id);                                                                                // 1000
      callbacks.removedAt && callbacks.removedAt(transform(doc), index);                              // 1001
      callbacks.removed && callbacks.removed(transform(doc));                                         // 1002
    }                                                                                                 // 1003
  });                                                                                                 // 1004
  suppressed = false;                                                                                 // 1005
  return handle;                                                                                      // 1006
};                                                                                                    // 1007
                                                                                                      // 1008
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/selector.js                                                                     //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// Like _.isArray, but doesn't regard polyfilled Uint8Arrays on old browsers as                       // 1
// arrays.                                                                                            // 2
var isArray = function (x) {                                                                          // 3
  return _.isArray(x) && !EJSON.isBinary(x);                                                          // 4
};                                                                                                    // 5
                                                                                                      // 6
var _anyIfArray = function (x, f) {                                                                   // 7
  if (isArray(x))                                                                                     // 8
    return _.any(x, f);                                                                               // 9
  return f(x);                                                                                        // 10
};                                                                                                    // 11
                                                                                                      // 12
var _anyIfArrayPlus = function (x, f) {                                                               // 13
  if (f(x))                                                                                           // 14
    return true;                                                                                      // 15
  return isArray(x) && _.any(x, f);                                                                   // 16
};                                                                                                    // 17
                                                                                                      // 18
var hasOperators = function(valueSelector) {                                                          // 19
  var theseAreOperators = undefined;                                                                  // 20
  for (var selKey in valueSelector) {                                                                 // 21
    var thisIsOperator = selKey.substr(0, 1) === '$';                                                 // 22
    if (theseAreOperators === undefined) {                                                            // 23
      theseAreOperators = thisIsOperator;                                                             // 24
    } else if (theseAreOperators !== thisIsOperator) {                                                // 25
      throw new Error("Inconsistent selector: " + valueSelector);                                     // 26
    }                                                                                                 // 27
  }                                                                                                   // 28
  return !!theseAreOperators;  // {} has no operators                                                 // 29
};                                                                                                    // 30
                                                                                                      // 31
var compileValueSelector = function (valueSelector) {                                                 // 32
  if (valueSelector == null) {  // undefined or null                                                  // 33
    return function (value) {                                                                         // 34
      return _anyIfArray(value, function (x) {                                                        // 35
        return x == null;  // undefined or null                                                       // 36
      });                                                                                             // 37
    };                                                                                                // 38
  }                                                                                                   // 39
                                                                                                      // 40
  // Selector is a non-null primitive (and not an array or RegExp either).                            // 41
  if (!_.isObject(valueSelector)) {                                                                   // 42
    return function (value) {                                                                         // 43
      return _anyIfArray(value, function (x) {                                                        // 44
        return x === valueSelector;                                                                   // 45
      });                                                                                             // 46
    };                                                                                                // 47
  }                                                                                                   // 48
                                                                                                      // 49
  if (valueSelector instanceof RegExp) {                                                              // 50
    return function (value) {                                                                         // 51
      if (value === undefined)                                                                        // 52
        return false;                                                                                 // 53
      return _anyIfArray(value, function (x) {                                                        // 54
        return valueSelector.test(x);                                                                 // 55
      });                                                                                             // 56
    };                                                                                                // 57
  }                                                                                                   // 58
                                                                                                      // 59
  // Arrays match either identical arrays or arrays that contain it as a value.                       // 60
  if (isArray(valueSelector)) {                                                                       // 61
    return function (value) {                                                                         // 62
      if (!isArray(value))                                                                            // 63
        return false;                                                                                 // 64
      return _anyIfArrayPlus(value, function (x) {                                                    // 65
        return LocalCollection._f._equal(valueSelector, x);                                           // 66
      });                                                                                             // 67
    };                                                                                                // 68
  }                                                                                                   // 69
                                                                                                      // 70
  // It's an object, but not an array or regexp.                                                      // 71
  if (hasOperators(valueSelector)) {                                                                  // 72
    var operatorFunctions = [];                                                                       // 73
    _.each(valueSelector, function (operand, operator) {                                              // 74
      if (!_.has(VALUE_OPERATORS, operator))                                                          // 75
        throw new Error("Unrecognized operator: " + operator);                                        // 76
      operatorFunctions.push(VALUE_OPERATORS[operator](                                               // 77
        operand, valueSelector.$options));                                                            // 78
    });                                                                                               // 79
    return function (value) {                                                                         // 80
      return _.all(operatorFunctions, function (f) {                                                  // 81
        return f(value);                                                                              // 82
      });                                                                                             // 83
    };                                                                                                // 84
  }                                                                                                   // 85
                                                                                                      // 86
  // It's a literal; compare value (or element of value array) directly to the                        // 87
  // selector.                                                                                        // 88
  return function (value) {                                                                           // 89
    return _anyIfArray(value, function (x) {                                                          // 90
      return LocalCollection._f._equal(valueSelector, x);                                             // 91
    });                                                                                               // 92
  };                                                                                                  // 93
};                                                                                                    // 94
                                                                                                      // 95
// XXX can factor out common logic below                                                              // 96
var LOGICAL_OPERATORS = {                                                                             // 97
  "$and": function(subSelector) {                                                                     // 98
    if (!isArray(subSelector) || _.isEmpty(subSelector))                                              // 99
      throw Error("$and/$or/$nor must be nonempty array");                                            // 100
    var subSelectorFunctions = _.map(                                                                 // 101
      subSelector, compileDocumentSelector);                                                          // 102
    return function (doc) {                                                                           // 103
      return _.all(subSelectorFunctions, function (f) {                                               // 104
        return f(doc);                                                                                // 105
      });                                                                                             // 106
    };                                                                                                // 107
  },                                                                                                  // 108
                                                                                                      // 109
  "$or": function(subSelector) {                                                                      // 110
    if (!isArray(subSelector) || _.isEmpty(subSelector))                                              // 111
      throw Error("$and/$or/$nor must be nonempty array");                                            // 112
    var subSelectorFunctions = _.map(                                                                 // 113
      subSelector, compileDocumentSelector);                                                          // 114
    return function (doc) {                                                                           // 115
      return _.any(subSelectorFunctions, function (f) {                                               // 116
        return f(doc);                                                                                // 117
      });                                                                                             // 118
    };                                                                                                // 119
  },                                                                                                  // 120
                                                                                                      // 121
  "$nor": function(subSelector) {                                                                     // 122
    if (!isArray(subSelector) || _.isEmpty(subSelector))                                              // 123
      throw Error("$and/$or/$nor must be nonempty array");                                            // 124
    var subSelectorFunctions = _.map(                                                                 // 125
      subSelector, compileDocumentSelector);                                                          // 126
    return function (doc) {                                                                           // 127
      return _.all(subSelectorFunctions, function (f) {                                               // 128
        return !f(doc);                                                                               // 129
      });                                                                                             // 130
    };                                                                                                // 131
  },                                                                                                  // 132
                                                                                                      // 133
  "$where": function(selectorValue) {                                                                 // 134
    if (!(selectorValue instanceof Function)) {                                                       // 135
      selectorValue = Function("return " + selectorValue);                                            // 136
    }                                                                                                 // 137
    return function (doc) {                                                                           // 138
      return selectorValue.call(doc);                                                                 // 139
    };                                                                                                // 140
  }                                                                                                   // 141
};                                                                                                    // 142
                                                                                                      // 143
var VALUE_OPERATORS = {                                                                               // 144
  "$in": function (operand) {                                                                         // 145
    if (!isArray(operand))                                                                            // 146
      throw new Error("Argument to $in must be array");                                               // 147
    return function (value) {                                                                         // 148
      return _anyIfArrayPlus(value, function (x) {                                                    // 149
        return _.any(operand, function (operandElt) {                                                 // 150
          return LocalCollection._f._equal(operandElt, x);                                            // 151
        });                                                                                           // 152
      });                                                                                             // 153
    };                                                                                                // 154
  },                                                                                                  // 155
                                                                                                      // 156
  "$all": function (operand) {                                                                        // 157
    if (!isArray(operand))                                                                            // 158
      throw new Error("Argument to $all must be array");                                              // 159
    return function (value) {                                                                         // 160
      if (!isArray(value))                                                                            // 161
        return false;                                                                                 // 162
      return _.all(operand, function (operandElt) {                                                   // 163
        return _.any(value, function (valueElt) {                                                     // 164
          return LocalCollection._f._equal(operandElt, valueElt);                                     // 165
        });                                                                                           // 166
      });                                                                                             // 167
    };                                                                                                // 168
  },                                                                                                  // 169
                                                                                                      // 170
  "$lt": function (operand) {                                                                         // 171
    return function (value) {                                                                         // 172
      return _anyIfArray(value, function (x) {                                                        // 173
        return LocalCollection._f._cmp(x, operand) < 0;                                               // 174
      });                                                                                             // 175
    };                                                                                                // 176
  },                                                                                                  // 177
                                                                                                      // 178
  "$lte": function (operand) {                                                                        // 179
    return function (value) {                                                                         // 180
      return _anyIfArray(value, function (x) {                                                        // 181
        return LocalCollection._f._cmp(x, operand) <= 0;                                              // 182
      });                                                                                             // 183
    };                                                                                                // 184
  },                                                                                                  // 185
                                                                                                      // 186
  "$gt": function (operand) {                                                                         // 187
    return function (value) {                                                                         // 188
      return _anyIfArray(value, function (x) {                                                        // 189
        return LocalCollection._f._cmp(x, operand) > 0;                                               // 190
      });                                                                                             // 191
    };                                                                                                // 192
  },                                                                                                  // 193
                                                                                                      // 194
  "$gte": function (operand) {                                                                        // 195
    return function (value) {                                                                         // 196
      return _anyIfArray(value, function (x) {                                                        // 197
        return LocalCollection._f._cmp(x, operand) >= 0;                                              // 198
      });                                                                                             // 199
    };                                                                                                // 200
  },                                                                                                  // 201
                                                                                                      // 202
  "$ne": function (operand) {                                                                         // 203
    return function (value) {                                                                         // 204
      return ! _anyIfArrayPlus(value, function (x) {                                                  // 205
        return LocalCollection._f._equal(x, operand);                                                 // 206
      });                                                                                             // 207
    };                                                                                                // 208
  },                                                                                                  // 209
                                                                                                      // 210
  "$nin": function (operand) {                                                                        // 211
    if (!isArray(operand))                                                                            // 212
      throw new Error("Argument to $nin must be array");                                              // 213
    var inFunction = VALUE_OPERATORS.$in(operand);                                                    // 214
    return function (value) {                                                                         // 215
      // Field doesn't exist, so it's not-in operand                                                  // 216
      if (value === undefined)                                                                        // 217
        return true;                                                                                  // 218
      return !inFunction(value);                                                                      // 219
    };                                                                                                // 220
  },                                                                                                  // 221
                                                                                                      // 222
  "$exists": function (operand) {                                                                     // 223
    return function (value) {                                                                         // 224
      return operand === (value !== undefined);                                                       // 225
    };                                                                                                // 226
  },                                                                                                  // 227
                                                                                                      // 228
  "$mod": function (operand) {                                                                        // 229
    var divisor = operand[0],                                                                         // 230
        remainder = operand[1];                                                                       // 231
    return function (value) {                                                                         // 232
      return _anyIfArray(value, function (x) {                                                        // 233
        return x % divisor === remainder;                                                             // 234
      });                                                                                             // 235
    };                                                                                                // 236
  },                                                                                                  // 237
                                                                                                      // 238
  "$size": function (operand) {                                                                       // 239
    return function (value) {                                                                         // 240
      return isArray(value) && operand === value.length;                                              // 241
    };                                                                                                // 242
  },                                                                                                  // 243
                                                                                                      // 244
  "$type": function (operand) {                                                                       // 245
    return function (value) {                                                                         // 246
      // A nonexistent field is of no type.                                                           // 247
      if (value === undefined)                                                                        // 248
        return false;                                                                                 // 249
      // Definitely not _anyIfArrayPlus: $type: 4 only matches arrays that have                       // 250
      // arrays as elements according to the Mongo docs.                                              // 251
      return _anyIfArray(value, function (x) {                                                        // 252
        return LocalCollection._f._type(x) === operand;                                               // 253
      });                                                                                             // 254
    };                                                                                                // 255
  },                                                                                                  // 256
                                                                                                      // 257
  "$regex": function (operand, options) {                                                             // 258
    if (options !== undefined) {                                                                      // 259
      // Options passed in $options (even the empty string) always overrides                          // 260
      // options in the RegExp object itself. (See also                                               // 261
      // Meteor.Collection._rewriteSelector.)                                                         // 262
                                                                                                      // 263
      // Be clear that we only support the JS-supported options, not extended                         // 264
      // ones (eg, Mongo supports x and s). Ideally we would implement x and s                        // 265
      // by transforming the regexp, but not today...                                                 // 266
      if (/[^gim]/.test(options))                                                                     // 267
        throw new Error("Only the i, m, and g regexp options are supported");                         // 268
                                                                                                      // 269
      var regexSource = operand instanceof RegExp ? operand.source : operand;                         // 270
      operand = new RegExp(regexSource, options);                                                     // 271
    } else if (!(operand instanceof RegExp)) {                                                        // 272
      operand = new RegExp(operand);                                                                  // 273
    }                                                                                                 // 274
                                                                                                      // 275
    return function (value) {                                                                         // 276
      if (value === undefined)                                                                        // 277
        return false;                                                                                 // 278
      return _anyIfArray(value, function (x) {                                                        // 279
        return operand.test(x);                                                                       // 280
      });                                                                                             // 281
    };                                                                                                // 282
  },                                                                                                  // 283
                                                                                                      // 284
  "$options": function (operand) {                                                                    // 285
    // evaluation happens at the $regex function above                                                // 286
    return function (value) { return true; };                                                         // 287
  },                                                                                                  // 288
                                                                                                      // 289
  "$elemMatch": function (operand) {                                                                  // 290
    var matcher = compileDocumentSelector(operand);                                                   // 291
    return function (value) {                                                                         // 292
      if (!isArray(value))                                                                            // 293
        return false;                                                                                 // 294
      return _.any(value, function (x) {                                                              // 295
        return matcher(x);                                                                            // 296
      });                                                                                             // 297
    };                                                                                                // 298
  },                                                                                                  // 299
                                                                                                      // 300
  "$not": function (operand) {                                                                        // 301
    var matcher = compileValueSelector(operand);                                                      // 302
    return function (value) {                                                                         // 303
      return !matcher(value);                                                                         // 304
    };                                                                                                // 305
  }                                                                                                   // 306
};                                                                                                    // 307
                                                                                                      // 308
// helpers used by compiled selector code                                                             // 309
LocalCollection._f = {                                                                                // 310
  // XXX for _all and _in, consider building 'inquery' at compile time..                              // 311
                                                                                                      // 312
  _type: function (v) {                                                                               // 313
    if (typeof v === "number")                                                                        // 314
      return 1;                                                                                       // 315
    if (typeof v === "string")                                                                        // 316
      return 2;                                                                                       // 317
    if (typeof v === "boolean")                                                                       // 318
      return 8;                                                                                       // 319
    if (isArray(v))                                                                                   // 320
      return 4;                                                                                       // 321
    if (v === null)                                                                                   // 322
      return 10;                                                                                      // 323
    if (v instanceof RegExp)                                                                          // 324
      return 11;                                                                                      // 325
    if (typeof v === "function")                                                                      // 326
      // note that typeof(/x/) === "function"                                                         // 327
      return 13;                                                                                      // 328
    if (v instanceof Date)                                                                            // 329
      return 9;                                                                                       // 330
    if (EJSON.isBinary(v))                                                                            // 331
      return 5;                                                                                       // 332
    if (v instanceof LocalCollection._ObjectID)                                                       // 333
      return 7;                                                                                       // 334
    return 3; // object                                                                               // 335
                                                                                                      // 336
    // XXX support some/all of these:                                                                 // 337
    // 14, symbol                                                                                     // 338
    // 15, javascript code with scope                                                                 // 339
    // 16, 18: 32-bit/64-bit integer                                                                  // 340
    // 17, timestamp                                                                                  // 341
    // 255, minkey                                                                                    // 342
    // 127, maxkey                                                                                    // 343
  },                                                                                                  // 344
                                                                                                      // 345
  // deep equality test: use for literal document and array matches                                   // 346
  _equal: function (a, b) {                                                                           // 347
    return EJSON.equals(a, b, {keyOrderSensitive: true});                                             // 348
  },                                                                                                  // 349
                                                                                                      // 350
  // maps a type code to a value that can be used to sort values of                                   // 351
  // different types                                                                                  // 352
  _typeorder: function (t) {                                                                          // 353
    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types                   // 354
    // XXX what is the correct sort position for Javascript code?                                     // 355
    // ('100' in the matrix below)                                                                    // 356
    // XXX minkey/maxkey                                                                              // 357
    return [-1,  // (not a type)                                                                      // 358
            1,   // number                                                                            // 359
            2,   // string                                                                            // 360
            3,   // object                                                                            // 361
            4,   // array                                                                             // 362
            5,   // binary                                                                            // 363
            -1,  // deprecated                                                                        // 364
            6,   // ObjectID                                                                          // 365
            7,   // bool                                                                              // 366
            8,   // Date                                                                              // 367
            0,   // null                                                                              // 368
            9,   // RegExp                                                                            // 369
            -1,  // deprecated                                                                        // 370
            100, // JS code                                                                           // 371
            2,   // deprecated (symbol)                                                               // 372
            100, // JS code                                                                           // 373
            1,   // 32-bit int                                                                        // 374
            8,   // Mongo timestamp                                                                   // 375
            1    // 64-bit int                                                                        // 376
           ][t];                                                                                      // 377
  },                                                                                                  // 378
                                                                                                      // 379
  // compare two values of unknown type according to BSON ordering                                    // 380
  // semantics. (as an extension, consider 'undefined' to be less than                                // 381
  // any other value.) return negative if a is less, positive if b is                                 // 382
  // less, or 0 if equal                                                                              // 383
  _cmp: function (a, b) {                                                                             // 384
    if (a === undefined)                                                                              // 385
      return b === undefined ? 0 : -1;                                                                // 386
    if (b === undefined)                                                                              // 387
      return 1;                                                                                       // 388
    var ta = LocalCollection._f._type(a);                                                             // 389
    var tb = LocalCollection._f._type(b);                                                             // 390
    var oa = LocalCollection._f._typeorder(ta);                                                       // 391
    var ob = LocalCollection._f._typeorder(tb);                                                       // 392
    if (oa !== ob)                                                                                    // 393
      return oa < ob ? -1 : 1;                                                                        // 394
    if (ta !== tb)                                                                                    // 395
      // XXX need to implement this if we implement Symbol or integers, or                            // 396
      // Timestamp                                                                                    // 397
      throw Error("Missing type coercion logic in _cmp");                                             // 398
    if (ta === 7) { // ObjectID                                                                       // 399
      // Convert to string.                                                                           // 400
      ta = tb = 2;                                                                                    // 401
      a = a.toHexString();                                                                            // 402
      b = b.toHexString();                                                                            // 403
    }                                                                                                 // 404
    if (ta === 9) { // Date                                                                           // 405
      // Convert to millis.                                                                           // 406
      ta = tb = 1;                                                                                    // 407
      a = a.getTime();                                                                                // 408
      b = b.getTime();                                                                                // 409
    }                                                                                                 // 410
                                                                                                      // 411
    if (ta === 1) // double                                                                           // 412
      return a - b;                                                                                   // 413
    if (tb === 2) // string                                                                           // 414
      return a < b ? -1 : (a === b ? 0 : 1);                                                          // 415
    if (ta === 3) { // Object                                                                         // 416
      // this could be much more efficient in the expected case ...                                   // 417
      var to_array = function (obj) {                                                                 // 418
        var ret = [];                                                                                 // 419
        for (var key in obj) {                                                                        // 420
          ret.push(key);                                                                              // 421
          ret.push(obj[key]);                                                                         // 422
        }                                                                                             // 423
        return ret;                                                                                   // 424
      };                                                                                              // 425
      return LocalCollection._f._cmp(to_array(a), to_array(b));                                       // 426
    }                                                                                                 // 427
    if (ta === 4) { // Array                                                                          // 428
      for (var i = 0; ; i++) {                                                                        // 429
        if (i === a.length)                                                                           // 430
          return (i === b.length) ? 0 : -1;                                                           // 431
        if (i === b.length)                                                                           // 432
          return 1;                                                                                   // 433
        var s = LocalCollection._f._cmp(a[i], b[i]);                                                  // 434
        if (s !== 0)                                                                                  // 435
          return s;                                                                                   // 436
      }                                                                                               // 437
    }                                                                                                 // 438
    if (ta === 5) { // binary                                                                         // 439
      // Surprisingly, a small binary blob is always less than a large one in                         // 440
      // Mongo.                                                                                       // 441
      if (a.length !== b.length)                                                                      // 442
        return a.length - b.length;                                                                   // 443
      for (i = 0; i < a.length; i++) {                                                                // 444
        if (a[i] < b[i])                                                                              // 445
          return -1;                                                                                  // 446
        if (a[i] > b[i])                                                                              // 447
          return 1;                                                                                   // 448
      }                                                                                               // 449
      return 0;                                                                                       // 450
    }                                                                                                 // 451
    if (ta === 8) { // boolean                                                                        // 452
      if (a) return b ? 0 : 1;                                                                        // 453
      return b ? -1 : 0;                                                                              // 454
    }                                                                                                 // 455
    if (ta === 10) // null                                                                            // 456
      return 0;                                                                                       // 457
    if (ta === 11) // regexp                                                                          // 458
      throw Error("Sorting not supported on regular expression"); // XXX                              // 459
    // 13: javascript code                                                                            // 460
    // 14: symbol                                                                                     // 461
    // 15: javascript code with scope                                                                 // 462
    // 16: 32-bit integer                                                                             // 463
    // 17: timestamp                                                                                  // 464
    // 18: 64-bit integer                                                                             // 465
    // 255: minkey                                                                                    // 466
    // 127: maxkey                                                                                    // 467
    if (ta === 13) // javascript code                                                                 // 468
      throw Error("Sorting not supported on Javascript code"); // XXX                                 // 469
    throw Error("Unknown type to sort");                                                              // 470
  }                                                                                                   // 471
};                                                                                                    // 472
                                                                                                      // 473
// For unit tests. True if the given document matches the given                                       // 474
// selector.                                                                                          // 475
LocalCollection._matches = function (selector, doc) {                                                 // 476
  return (LocalCollection._compileSelector(selector))(doc);                                           // 477
};                                                                                                    // 478
                                                                                                      // 479
// _makeLookupFunction(key) returns a lookup function.                                                // 480
//                                                                                                    // 481
// A lookup function takes in a document and returns an array of matching                             // 482
// values.  This array has more than one element if any segment of the key other                      // 483
// than the last one is an array.  ie, any arrays found when doing non-final                          // 484
// lookups result in this function "branching"; each element in the returned                          // 485
// array represents the value found at this branch. If any branch doesn't have a                      // 486
// final value for the full key, its element in the returned list will be                             // 487
// undefined. It always returns a non-empty array.                                                    // 488
//                                                                                                    // 489
// _makeLookupFunction('a.x')({a: {x: 1}}) returns [1]                                                // 490
// _makeLookupFunction('a.x')({a: {x: [1]}}) returns [[1]]                                            // 491
// _makeLookupFunction('a.x')({a: 5})  returns [undefined]                                            // 492
// _makeLookupFunction('a.x')({a: [{x: 1},                                                            // 493
//                                 {x: [2]},                                                          // 494
//                                 {y: 3}]})                                                          // 495
//   returns [1, [2], undefined]                                                                      // 496
LocalCollection._makeLookupFunction = function (key) {                                                // 497
  var dotLocation = key.indexOf('.');                                                                 // 498
  var first, lookupRest, nextIsNumeric;                                                               // 499
  if (dotLocation === -1) {                                                                           // 500
    first = key;                                                                                      // 501
  } else {                                                                                            // 502
    first = key.substr(0, dotLocation);                                                               // 503
    var rest = key.substr(dotLocation + 1);                                                           // 504
    lookupRest = LocalCollection._makeLookupFunction(rest);                                           // 505
    // Is the next (perhaps final) piece numeric (ie, an array lookup?)                               // 506
    nextIsNumeric = /^\d+(\.|$)/.test(rest);                                                          // 507
  }                                                                                                   // 508
                                                                                                      // 509
  return function (doc) {                                                                             // 510
    if (doc == null)  // null or undefined                                                            // 511
      return [undefined];                                                                             // 512
    var firstLevel = doc[first];                                                                      // 513
                                                                                                      // 514
    // We don't "branch" at the final level.                                                          // 515
    if (!lookupRest)                                                                                  // 516
      return [firstLevel];                                                                            // 517
                                                                                                      // 518
    // It's an empty array, and we're not done: we won't find anything.                               // 519
    if (isArray(firstLevel) && firstLevel.length === 0)                                               // 520
      return [undefined];                                                                             // 521
                                                                                                      // 522
    // For each result at this level, finish the lookup on the rest of the key,                       // 523
    // and return everything we find. Also, if the next result is a number,                           // 524
    // don't branch here.                                                                             // 525
    //                                                                                                // 526
    // Technically, in MongoDB, we should be able to handle the case where                            // 527
    // objects have numeric keys, but Mongo doesn't actually handle this                              // 528
    // consistently yet itself, see eg                                                                // 529
    // https://jira.mongodb.org/browse/SERVER-2898                                                    // 530
    // https://github.com/mongodb/mongo/blob/master/jstests/array_match2.js                           // 531
    if (!isArray(firstLevel) || nextIsNumeric)                                                        // 532
      firstLevel = [firstLevel];                                                                      // 533
    return Array.prototype.concat.apply([], _.map(firstLevel, lookupRest));                           // 534
  };                                                                                                  // 535
};                                                                                                    // 536
                                                                                                      // 537
// The main compilation function for a given selector.                                                // 538
var compileDocumentSelector = function (docSelector) {                                                // 539
  var perKeySelectors = [];                                                                           // 540
  _.each(docSelector, function (subSelector, key) {                                                   // 541
    if (key.substr(0, 1) === '$') {                                                                   // 542
      // Outer operators are either logical operators (they recurse back into                         // 543
      // this function), or $where.                                                                   // 544
      if (!_.has(LOGICAL_OPERATORS, key))                                                             // 545
        throw new Error("Unrecognized logical operator: " + key);                                     // 546
      perKeySelectors.push(LOGICAL_OPERATORS[key](subSelector));                                      // 547
    } else {                                                                                          // 548
      var lookUpByIndex = LocalCollection._makeLookupFunction(key);                                   // 549
      var valueSelectorFunc = compileValueSelector(subSelector);                                      // 550
      perKeySelectors.push(function (doc) {                                                           // 551
        var branchValues = lookUpByIndex(doc);                                                        // 552
        // We apply the selector to each "branched" value and return true if any                      // 553
        // match. This isn't 100% consistent with MongoDB; eg, see:                                   // 554
        // https://jira.mongodb.org/browse/SERVER-8585                                                // 555
        return _.any(branchValues, valueSelectorFunc);                                                // 556
      });                                                                                             // 557
    }                                                                                                 // 558
  });                                                                                                 // 559
                                                                                                      // 560
                                                                                                      // 561
  return function (doc) {                                                                             // 562
    return _.all(perKeySelectors, function (f) {                                                      // 563
      return f(doc);                                                                                  // 564
    });                                                                                               // 565
  };                                                                                                  // 566
};                                                                                                    // 567
                                                                                                      // 568
// Given a selector, return a function that takes one argument, a                                     // 569
// document, and returns true if the document matches the selector,                                   // 570
// else false.                                                                                        // 571
LocalCollection._compileSelector = function (selector) {                                              // 572
  // you can pass a literal function instead of a selector                                            // 573
  if (selector instanceof Function)                                                                   // 574
    return function (doc) {return selector.call(doc);};                                               // 575
                                                                                                      // 576
  // shorthand -- scalars match _id                                                                   // 577
  if (LocalCollection._selectorIsId(selector)) {                                                      // 578
    return function (doc) {                                                                           // 579
      return EJSON.equals(doc._id, selector);                                                         // 580
    };                                                                                                // 581
  }                                                                                                   // 582
                                                                                                      // 583
  // protect against dangerous selectors.  falsey and {_id: falsey} are both                          // 584
  // likely programmer error, and not what you want, particularly for                                 // 585
  // destructive operations.                                                                          // 586
  if (!selector || (('_id' in selector) && !selector._id))                                            // 587
    return function (doc) {return false;};                                                            // 588
                                                                                                      // 589
  // Top level can't be an array or true or binary.                                                   // 590
  if (typeof(selector) === 'boolean' || isArray(selector) ||                                          // 591
      EJSON.isBinary(selector))                                                                       // 592
    throw new Error("Invalid selector: " + selector);                                                 // 593
                                                                                                      // 594
  return compileDocumentSelector(selector);                                                           // 595
};                                                                                                    // 596
                                                                                                      // 597
// Give a sort spec, which can be in any of these forms:                                              // 598
//   {"key1": 1, "key2": -1}                                                                          // 599
//   [["key1", "asc"], ["key2", "desc"]]                                                              // 600
//   ["key1", ["key2", "desc"]]                                                                       // 601
//                                                                                                    // 602
// (.. with the first form being dependent on the key enumeration                                     // 603
// behavior of your javascript VM, which usually does what you mean in                                // 604
// this case if the key names don't look like integers ..)                                            // 605
//                                                                                                    // 606
// return a function that takes two objects, and returns -1 if the                                    // 607
// first object comes first in order, 1 if the second object comes                                    // 608
// first, or 0 if neither object comes before the other.                                              // 609
                                                                                                      // 610
LocalCollection._compileSort = function (spec) {                                                      // 611
  var sortSpecParts = [];                                                                             // 612
                                                                                                      // 613
  if (spec instanceof Array) {                                                                        // 614
    for (var i = 0; i < spec.length; i++) {                                                           // 615
      if (typeof spec[i] === "string") {                                                              // 616
        sortSpecParts.push({                                                                          // 617
          lookup: LocalCollection._makeLookupFunction(spec[i]),                                       // 618
          ascending: true                                                                             // 619
        });                                                                                           // 620
      } else {                                                                                        // 621
        sortSpecParts.push({                                                                          // 622
          lookup: LocalCollection._makeLookupFunction(spec[i][0]),                                    // 623
          ascending: spec[i][1] !== "desc"                                                            // 624
        });                                                                                           // 625
      }                                                                                               // 626
    }                                                                                                 // 627
  } else if (typeof spec === "object") {                                                              // 628
    for (var key in spec) {                                                                           // 629
      sortSpecParts.push({                                                                            // 630
        lookup: LocalCollection._makeLookupFunction(key),                                             // 631
        ascending: spec[key] >= 0                                                                     // 632
      });                                                                                             // 633
    }                                                                                                 // 634
  } else {                                                                                            // 635
    throw Error("Bad sort specification: ", JSON.stringify(spec));                                    // 636
  }                                                                                                   // 637
                                                                                                      // 638
  if (sortSpecParts.length === 0)                                                                     // 639
    return function () {return 0;};                                                                   // 640
                                                                                                      // 641
  // reduceValue takes in all the possible values for the sort key along various                      // 642
  // branches, and returns the min or max value (according to the bool                                // 643
  // findMin). Each value can itself be an array, and we look at its values                           // 644
  // too. (ie, we do a single level of flattening on branchValues, then find the                      // 645
  // min/max.)                                                                                        // 646
  var reduceValue = function (branchValues, findMin) {                                                // 647
    var reduced;                                                                                      // 648
    var first = true;                                                                                 // 649
    // Iterate over all the values found in all the branches, and if a value is                       // 650
    // an array itself, iterate over the values in the array separately.                              // 651
    _.each(branchValues, function (branchValue) {                                                     // 652
      // Value not an array? Pretend it is.                                                           // 653
      if (!isArray(branchValue))                                                                      // 654
        branchValue = [branchValue];                                                                  // 655
      // Value is an empty array? Pretend it was missing, since that's where it                       // 656
      // should be sorted.                                                                            // 657
      if (isArray(branchValue) && branchValue.length === 0)                                           // 658
        branchValue = [undefined];                                                                    // 659
      _.each(branchValue, function (value) {                                                          // 660
        // We should get here at least once: lookup functions return non-empty                        // 661
        // arrays, so the outer loop runs at least once, and we prevented                             // 662
        // branchValue from being an empty array.                                                     // 663
        if (first) {                                                                                  // 664
          reduced = value;                                                                            // 665
          first = false;                                                                              // 666
        } else {                                                                                      // 667
          // Compare the value we found to the value we found so far, saving it                       // 668
          // if it's less (for an ascending sort) or more (for a descending                           // 669
          // sort).                                                                                   // 670
          var cmp = LocalCollection._f._cmp(reduced, value);                                          // 671
          if ((findMin && cmp > 0) || (!findMin && cmp < 0))                                          // 672
            reduced = value;                                                                          // 673
        }                                                                                             // 674
      });                                                                                             // 675
    });                                                                                               // 676
    return reduced;                                                                                   // 677
  };                                                                                                  // 678
                                                                                                      // 679
  return function (a, b) {                                                                            // 680
    for (var i = 0; i < sortSpecParts.length; ++i) {                                                  // 681
      var specPart = sortSpecParts[i];                                                                // 682
      var aValue = reduceValue(specPart.lookup(a), specPart.ascending);                               // 683
      var bValue = reduceValue(specPart.lookup(b), specPart.ascending);                               // 684
      var compare = LocalCollection._f._cmp(aValue, bValue);                                          // 685
      if (compare !== 0)                                                                              // 686
        return specPart.ascending ? compare : -compare;                                               // 687
    };                                                                                                // 688
    return 0;                                                                                         // 689
  };                                                                                                  // 690
};                                                                                                    // 691
                                                                                                      // 692
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/modify.js                                                                       //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
// XXX need a strategy for passing the binding of $ into this                                         // 1
// function, from the compiled selector                                                               // 2
//                                                                                                    // 3
// maybe just {key.up.to.just.before.dollarsign: array_index}                                         // 4
//                                                                                                    // 5
// XXX atomicity: if one modification fails, do we roll back the whole                                // 6
// change?                                                                                            // 7
LocalCollection._modify = function (doc, mod) {                                                       // 8
  var is_modifier = false;                                                                            // 9
  for (var k in mod) {                                                                                // 10
    // IE7 doesn't support indexing into strings (eg, k[0]), so use substr.                           // 11
    // Too bad -- it's far slower:                                                                    // 12
    // http://jsperf.com/testing-the-first-character-of-a-string                                      // 13
    is_modifier = k.substr(0, 1) === '$';                                                             // 14
    break; // just check the first key.                                                               // 15
  }                                                                                                   // 16
                                                                                                      // 17
  var new_doc;                                                                                        // 18
                                                                                                      // 19
  if (!is_modifier) {                                                                                 // 20
    if (mod._id && !EJSON.equals(doc._id, mod._id))                                                   // 21
      throw Error("Cannot change the _id of a document");                                             // 22
                                                                                                      // 23
    // replace the whole document                                                                     // 24
    for (var k in mod) {                                                                              // 25
      if (k.substr(0, 1) === '$')                                                                     // 26
        throw Error("When replacing document, field name may not start with '$'");                    // 27
      if (/\./.test(k))                                                                               // 28
        throw Error("When replacing document, field name may not contain '.'");                       // 29
    }                                                                                                 // 30
    new_doc = mod;                                                                                    // 31
  } else {                                                                                            // 32
    // apply modifiers                                                                                // 33
    var new_doc = EJSON.clone(doc);                                                                   // 34
                                                                                                      // 35
    for (var op in mod) {                                                                             // 36
      var mod_func = LocalCollection._modifiers[op];                                                  // 37
      if (!mod_func)                                                                                  // 38
        throw Error("Invalid modifier specified " + op);                                              // 39
      for (var keypath in mod[op]) {                                                                  // 40
        // XXX mongo doesn't allow mod field names to end in a period,                                // 41
        // but I don't see why.. it allows '' as a key, as does JS                                    // 42
        if (keypath.length && keypath[keypath.length-1] === '.')                                      // 43
          throw Error("Invalid mod field name, may not end in a period");                             // 44
                                                                                                      // 45
        var arg = mod[op][keypath];                                                                   // 46
        var keyparts = keypath.split('.');                                                            // 47
        var no_create = !!LocalCollection._noCreateModifiers[op];                                     // 48
        var forbid_array = (op === "$rename");                                                        // 49
        var target = LocalCollection._findModTarget(new_doc, keyparts,                                // 50
                                                    no_create, forbid_array);                         // 51
        var field = keyparts.pop();                                                                   // 52
        mod_func(target, field, arg, keypath, new_doc);                                               // 53
      }                                                                                               // 54
    }                                                                                                 // 55
  }                                                                                                   // 56
                                                                                                      // 57
  // move new document into place.                                                                    // 58
  _.each(_.keys(doc), function (k) {                                                                  // 59
    // Note: this used to be for (var k in doc) however, this does not                                // 60
    // work right in Opera. Deleting from a doc while iterating over it                               // 61
    // would sometimes cause opera to skip some keys.                                                 // 62
    if (k !== '_id')                                                                                  // 63
      delete doc[k];                                                                                  // 64
  });                                                                                                 // 65
  for (var k in new_doc) {                                                                            // 66
    doc[k] = new_doc[k];                                                                              // 67
  }                                                                                                   // 68
};                                                                                                    // 69
                                                                                                      // 70
// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],                                // 71
// and then you would operate on the 'e' property of the returned                                     // 72
// object. if no_create is falsey, creates intermediate levels of                                     // 73
// structure as necessary, like mkdir -p (and raises an exception if                                  // 74
// that would mean giving a non-numeric property to an array.) if                                     // 75
// no_create is true, return undefined instead. may modify the last                                   // 76
// element of keyparts to signal to the caller that it needs to use a                                 // 77
// different value to index into the returned object (for example,                                    // 78
// ['a', '01'] -> ['a', 1]). if forbid_array is true, return null if                                  // 79
// the keypath goes through an array.                                                                 // 80
LocalCollection._findModTarget = function (doc, keyparts, no_create,                                  // 81
                                      forbid_array) {                                                 // 82
  for (var i = 0; i < keyparts.length; i++) {                                                         // 83
    var last = (i === keyparts.length - 1);                                                           // 84
    var keypart = keyparts[i];                                                                        // 85
    var numeric = /^[0-9]+$/.test(keypart);                                                           // 86
    if (no_create && (!(typeof doc === "object") || !(keypart in doc)))                               // 87
      return undefined;                                                                               // 88
    if (doc instanceof Array) {                                                                       // 89
      if (forbid_array)                                                                               // 90
        return null;                                                                                  // 91
      if (!numeric)                                                                                   // 92
        throw Error("can't append to array using string field name ["                                 // 93
                    + keypart + "]");                                                                 // 94
      keypart = parseInt(keypart);                                                                    // 95
      if (last)                                                                                       // 96
        // handle 'a.01'                                                                              // 97
        keyparts[i] = keypart;                                                                        // 98
      while (doc.length < keypart)                                                                    // 99
        doc.push(null);                                                                               // 100
      if (!last) {                                                                                    // 101
        if (doc.length === keypart)                                                                   // 102
          doc.push({});                                                                               // 103
        else if (typeof doc[keypart] !== "object")                                                    // 104
          throw Error("can't modify field '" + keyparts[i + 1] +                                      // 105
                      "' of list value " + JSON.stringify(doc[keypart]));                             // 106
      }                                                                                               // 107
    } else {                                                                                          // 108
      // XXX check valid fieldname (no $ at start, no .)                                              // 109
      if (!last && !(keypart in doc))                                                                 // 110
        doc[keypart] = {};                                                                            // 111
    }                                                                                                 // 112
                                                                                                      // 113
    if (last)                                                                                         // 114
      return doc;                                                                                     // 115
    doc = doc[keypart];                                                                               // 116
  }                                                                                                   // 117
                                                                                                      // 118
  // notreached                                                                                       // 119
};                                                                                                    // 120
                                                                                                      // 121
LocalCollection._noCreateModifiers = {                                                                // 122
  $unset: true,                                                                                       // 123
  $pop: true,                                                                                         // 124
  $rename: true,                                                                                      // 125
  $pull: true,                                                                                        // 126
  $pullAll: true                                                                                      // 127
};                                                                                                    // 128
                                                                                                      // 129
LocalCollection._modifiers = {                                                                        // 130
  $inc: function (target, field, arg) {                                                               // 131
    if (typeof arg !== "number")                                                                      // 132
      throw Error("Modifier $inc allowed for numbers only");                                          // 133
    if (field in target) {                                                                            // 134
      if (typeof target[field] !== "number")                                                          // 135
        throw Error("Cannot apply $inc modifier to non-number");                                      // 136
      target[field] += arg;                                                                           // 137
    } else {                                                                                          // 138
      target[field] = arg;                                                                            // 139
    }                                                                                                 // 140
  },                                                                                                  // 141
  $set: function (target, field, arg) {                                                               // 142
    if (field === '_id' && !EJSON.equals(arg, target._id))                                            // 143
      throw Error("Cannot change the _id of a document");                                             // 144
                                                                                                      // 145
    target[field] = EJSON.clone(arg);                                                                 // 146
  },                                                                                                  // 147
  $unset: function (target, field, arg) {                                                             // 148
    if (target !== undefined) {                                                                       // 149
      if (target instanceof Array) {                                                                  // 150
        if (field in target)                                                                          // 151
          target[field] = null;                                                                       // 152
      } else                                                                                          // 153
        delete target[field];                                                                         // 154
    }                                                                                                 // 155
  },                                                                                                  // 156
  $push: function (target, field, arg) {                                                              // 157
    var x = target[field];                                                                            // 158
    if (x === undefined)                                                                              // 159
      target[field] = [arg];                                                                          // 160
    else if (!(x instanceof Array))                                                                   // 161
      throw Error("Cannot apply $push modifier to non-array");                                        // 162
    else                                                                                              // 163
      x.push(EJSON.clone(arg));                                                                       // 164
  },                                                                                                  // 165
  $pushAll: function (target, field, arg) {                                                           // 166
    if (!(typeof arg === "object" && arg instanceof Array))                                           // 167
      throw Error("Modifier $pushAll/pullAll allowed for arrays only");                               // 168
    var x = target[field];                                                                            // 169
    if (x === undefined)                                                                              // 170
      target[field] = arg;                                                                            // 171
    else if (!(x instanceof Array))                                                                   // 172
      throw Error("Cannot apply $pushAll modifier to non-array");                                     // 173
    else {                                                                                            // 174
      for (var i = 0; i < arg.length; i++)                                                            // 175
        x.push(arg[i]);                                                                               // 176
    }                                                                                                 // 177
  },                                                                                                  // 178
  $addToSet: function (target, field, arg) {                                                          // 179
    var x = target[field];                                                                            // 180
    if (x === undefined)                                                                              // 181
      target[field] = [arg];                                                                          // 182
    else if (!(x instanceof Array))                                                                   // 183
      throw Error("Cannot apply $addToSet modifier to non-array");                                    // 184
    else {                                                                                            // 185
      var isEach = false;                                                                             // 186
      if (typeof arg === "object") {                                                                  // 187
        for (var k in arg) {                                                                          // 188
          if (k === "$each")                                                                          // 189
            isEach = true;                                                                            // 190
          break;                                                                                      // 191
        }                                                                                             // 192
      }                                                                                               // 193
      var values = isEach ? arg["$each"] : [arg];                                                     // 194
      _.each(values, function (value) {                                                               // 195
        for (var i = 0; i < x.length; i++)                                                            // 196
          if (LocalCollection._f._equal(value, x[i]))                                                 // 197
            return;                                                                                   // 198
        x.push(value);                                                                                // 199
      });                                                                                             // 200
    }                                                                                                 // 201
  },                                                                                                  // 202
  $pop: function (target, field, arg) {                                                               // 203
    if (target === undefined)                                                                         // 204
      return;                                                                                         // 205
    var x = target[field];                                                                            // 206
    if (x === undefined)                                                                              // 207
      return;                                                                                         // 208
    else if (!(x instanceof Array))                                                                   // 209
      throw Error("Cannot apply $pop modifier to non-array");                                         // 210
    else {                                                                                            // 211
      if (typeof arg === 'number' && arg < 0)                                                         // 212
        x.splice(0, 1);                                                                               // 213
      else                                                                                            // 214
        x.pop();                                                                                      // 215
    }                                                                                                 // 216
  },                                                                                                  // 217
  $pull: function (target, field, arg) {                                                              // 218
    if (target === undefined)                                                                         // 219
      return;                                                                                         // 220
    var x = target[field];                                                                            // 221
    if (x === undefined)                                                                              // 222
      return;                                                                                         // 223
    else if (!(x instanceof Array))                                                                   // 224
      throw Error("Cannot apply $pull/pullAll modifier to non-array");                                // 225
    else {                                                                                            // 226
      var out = []                                                                                    // 227
      if (typeof arg === "object" && !(arg instanceof Array)) {                                       // 228
        // XXX would be much nicer to compile this once, rather than                                  // 229
        // for each document we modify.. but usually we're not                                        // 230
        // modifying that many documents, so we'll let it slide for                                   // 231
        // now                                                                                        // 232
                                                                                                      // 233
        // XXX _compileSelector isn't up for the job, because we need                                 // 234
        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something                                    // 235
        // like {$gt: 4} is not normally a complete selector.                                         // 236
        // same issue as $elemMatch possibly?                                                         // 237
        var match = LocalCollection._compileSelector(arg);                                            // 238
        for (var i = 0; i < x.length; i++)                                                            // 239
          if (!match(x[i]))                                                                           // 240
            out.push(x[i])                                                                            // 241
      } else {                                                                                        // 242
        for (var i = 0; i < x.length; i++)                                                            // 243
          if (!LocalCollection._f._equal(x[i], arg))                                                  // 244
            out.push(x[i]);                                                                           // 245
      }                                                                                               // 246
      target[field] = out;                                                                            // 247
    }                                                                                                 // 248
  },                                                                                                  // 249
  $pullAll: function (target, field, arg) {                                                           // 250
    if (!(typeof arg === "object" && arg instanceof Array))                                           // 251
      throw Error("Modifier $pushAll/pullAll allowed for arrays only");                               // 252
    if (target === undefined)                                                                         // 253
      return;                                                                                         // 254
    var x = target[field];                                                                            // 255
    if (x === undefined)                                                                              // 256
      return;                                                                                         // 257
    else if (!(x instanceof Array))                                                                   // 258
      throw Error("Cannot apply $pull/pullAll modifier to non-array");                                // 259
    else {                                                                                            // 260
      var out = []                                                                                    // 261
      for (var i = 0; i < x.length; i++) {                                                            // 262
        var exclude = false;                                                                          // 263
        for (var j = 0; j < arg.length; j++) {                                                        // 264
          if (LocalCollection._f._equal(x[i], arg[j])) {                                              // 265
            exclude = true;                                                                           // 266
            break;                                                                                    // 267
          }                                                                                           // 268
        }                                                                                             // 269
        if (!exclude)                                                                                 // 270
          out.push(x[i]);                                                                             // 271
      }                                                                                               // 272
      target[field] = out;                                                                            // 273
    }                                                                                                 // 274
  },                                                                                                  // 275
  $rename: function (target, field, arg, keypath, doc) {                                              // 276
    if (keypath === arg)                                                                              // 277
      // no idea why mongo has this restriction..                                                     // 278
      throw Error("$rename source must differ from target");                                          // 279
    if (target === null)                                                                              // 280
      throw Error("$rename source field invalid");                                                    // 281
    if (typeof arg !== "string")                                                                      // 282
      throw Error("$rename target must be a string");                                                 // 283
    if (target === undefined)                                                                         // 284
      return;                                                                                         // 285
    var v = target[field];                                                                            // 286
    delete target[field];                                                                             // 287
                                                                                                      // 288
    var keyparts = arg.split('.');                                                                    // 289
    var target2 = LocalCollection._findModTarget(doc, keyparts, false, true);                         // 290
    if (target2 === null)                                                                             // 291
      throw Error("$rename target field invalid");                                                    // 292
    var field2 = keyparts.pop();                                                                      // 293
    target2[field2] = v;                                                                              // 294
  },                                                                                                  // 295
  $bit: function (target, field, arg) {                                                               // 296
    // XXX mongo only supports $bit on integers, and we only support                                  // 297
    // native javascript numbers (doubles) so far, so we can't support $bit                           // 298
    throw Error("$bit is not supported");                                                             // 299
  }                                                                                                   // 300
};                                                                                                    // 301
                                                                                                      // 302
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/diff.js                                                                         //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
                                                                                                      // 1
// ordered: bool.                                                                                     // 2
// old_results and new_results: collections of documents.                                             // 3
//    if ordered, they are arrays.                                                                    // 4
//    if unordered, they are maps {_id: doc}.                                                         // 5
// observer: object with 'added', 'changed', 'removed',                                               // 6
//           and (if ordered) 'moved' functions (each optional)                                       // 7
LocalCollection._diffQueryChanges = function (ordered, oldResults, newResults,                        // 8
                                       observer) {                                                    // 9
  if (ordered)                                                                                        // 10
    LocalCollection._diffQueryOrderedChanges(                                                         // 11
      oldResults, newResults, observer);                                                              // 12
  else                                                                                                // 13
    LocalCollection._diffQueryUnorderedChanges(                                                       // 14
      oldResults, newResults, observer);                                                              // 15
};                                                                                                    // 16
                                                                                                      // 17
LocalCollection._diffQueryUnorderedChanges = function (oldResults, newResults,                        // 18
                                                observer) {                                           // 19
  if (observer.moved) {                                                                               // 20
    throw new Error("_diffQueryUnordered called with a moved observer!");                             // 21
  }                                                                                                   // 22
                                                                                                      // 23
  _.each(newResults, function (newDoc) {                                                              // 24
    if (_.has(oldResults, newDoc._id)) {                                                              // 25
      var oldDoc = oldResults[newDoc._id];                                                            // 26
      if (observer.changed && !EJSON.equals(oldDoc, newDoc)) {                                        // 27
        observer.changed(newDoc._id, LocalCollection._makeChangedFields(newDoc, oldDoc));             // 28
      }                                                                                               // 29
    } else {                                                                                          // 30
      var fields = EJSON.clone(newDoc);                                                               // 31
      delete fields._id;                                                                              // 32
      observer.added && observer.added(newDoc._id, fields);                                           // 33
    }                                                                                                 // 34
  });                                                                                                 // 35
                                                                                                      // 36
  if (observer.removed) {                                                                             // 37
    _.each(oldResults, function (oldDoc) {                                                            // 38
      if (!_.has(newResults, oldDoc._id))                                                             // 39
        observer.removed(oldDoc._id);                                                                 // 40
    });                                                                                               // 41
  }                                                                                                   // 42
};                                                                                                    // 43
                                                                                                      // 44
                                                                                                      // 45
LocalCollection._diffQueryOrderedChanges = function (old_results, new_results, observer) {            // 46
                                                                                                      // 47
  var new_presence_of_id = {};                                                                        // 48
  _.each(new_results, function (doc) {                                                                // 49
    if (new_presence_of_id[doc._id])                                                                  // 50
      Meteor._debug("Duplicate _id in new_results");                                                  // 51
    new_presence_of_id[doc._id] = true;                                                               // 52
  });                                                                                                 // 53
                                                                                                      // 54
  var old_index_of_id = {};                                                                           // 55
  _.each(old_results, function (doc, i) {                                                             // 56
    if (doc._id in old_index_of_id)                                                                   // 57
      Meteor._debug("Duplicate _id in old_results");                                                  // 58
    old_index_of_id[doc._id] = i;                                                                     // 59
  });                                                                                                 // 60
                                                                                                      // 61
  // ALGORITHM:                                                                                       // 62
  //                                                                                                  // 63
  // To determine which docs should be considered "moved" (and which                                  // 64
  // merely change position because of other docs moving) we run                                      // 65
  // a "longest common subsequence" (LCS) algorithm.  The LCS of the                                  // 66
  // old doc IDs and the new doc IDs gives the docs that should NOT be                                // 67
  // considered moved.                                                                                // 68
                                                                                                      // 69
  // To actually call the appropriate callbacks to get from the old state to the                      // 70
  // new state:                                                                                       // 71
                                                                                                      // 72
  // First, we call removed() on all the items that only appear in the old                            // 73
  // state.                                                                                           // 74
                                                                                                      // 75
  // Then, once we have the items that should not move, we walk through the new                       // 76
  // results array group-by-group, where a "group" is a set of items that have                        // 77
  // moved, anchored on the end by an item that should not move.  One by one, we                      // 78
  // move each of those elements into place "before" the anchoring end-of-group                       // 79
  // item, and fire changed events on them if necessary.  Then we fire a changed                      // 80
  // event on the anchor, and move on to the next group.  There is always at                          // 81
  // least one group; the last group is anchored by a virtual "null" id at the                        // 82
  // end.                                                                                             // 83
                                                                                                      // 84
  // Asymptotically: O(N k) where k is number of ops, or potentially                                  // 85
  // O(N log N) if inner loop of LCS were made to be binary search.                                   // 86
                                                                                                      // 87
                                                                                                      // 88
  //////// LCS (longest common sequence, with respect to _id)                                         // 89
  // (see Wikipedia article on Longest Increasing Subsequence,                                        // 90
  // where the LIS is taken of the sequence of old indices of the                                     // 91
  // docs in new_results)                                                                             // 92
  //                                                                                                  // 93
  // unmoved: the output of the algorithm; members of the LCS,                                        // 94
  // in the form of indices into new_results                                                          // 95
  var unmoved = [];                                                                                   // 96
  // max_seq_len: length of LCS found so far                                                          // 97
  var max_seq_len = 0;                                                                                // 98
  // seq_ends[i]: the index into new_results of the last doc in a                                     // 99
  // common subsequence of length of i+1 <= max_seq_len                                               // 100
  var N = new_results.length;                                                                         // 101
  var seq_ends = new Array(N);                                                                        // 102
  // ptrs:  the common subsequence ending with new_results[n] extends                                 // 103
  // a common subsequence ending with new_results[ptr[n]], unless                                     // 104
  // ptr[n] is -1.                                                                                    // 105
  var ptrs = new Array(N);                                                                            // 106
  // virtual sequence of old indices of new results                                                   // 107
  var old_idx_seq = function(i_new) {                                                                 // 108
    return old_index_of_id[new_results[i_new]._id];                                                   // 109
  };                                                                                                  // 110
  // for each item in new_results, use it to extend a common subsequence                              // 111
  // of length j <= max_seq_len                                                                       // 112
  for(var i=0; i<N; i++) {                                                                            // 113
    if (old_index_of_id[new_results[i]._id] !== undefined) {                                          // 114
      var j = max_seq_len;                                                                            // 115
      // this inner loop would traditionally be a binary search,                                      // 116
      // but scanning backwards we will likely find a subseq to extend                                // 117
      // pretty soon, bounded for example by the total number of ops.                                 // 118
      // If this were to be changed to a binary search, we'd still want                               // 119
      // to scan backwards a bit as an optimization.                                                  // 120
      while (j > 0) {                                                                                 // 121
        if (old_idx_seq(seq_ends[j-1]) < old_idx_seq(i))                                              // 122
          break;                                                                                      // 123
        j--;                                                                                          // 124
      }                                                                                               // 125
                                                                                                      // 126
      ptrs[i] = (j === 0 ? -1 : seq_ends[j-1]);                                                       // 127
      seq_ends[j] = i;                                                                                // 128
      if (j+1 > max_seq_len)                                                                          // 129
        max_seq_len = j+1;                                                                            // 130
    }                                                                                                 // 131
  }                                                                                                   // 132
                                                                                                      // 133
  // pull out the LCS/LIS into unmoved                                                                // 134
  var idx = (max_seq_len === 0 ? -1 : seq_ends[max_seq_len-1]);                                       // 135
  while (idx >= 0) {                                                                                  // 136
    unmoved.push(idx);                                                                                // 137
    idx = ptrs[idx];                                                                                  // 138
  }                                                                                                   // 139
  // the unmoved item list is built backwards, so fix that                                            // 140
  unmoved.reverse();                                                                                  // 141
                                                                                                      // 142
  // the last group is always anchored by the end of the result list, which is                        // 143
  // an id of "null"                                                                                  // 144
  unmoved.push(new_results.length);                                                                   // 145
                                                                                                      // 146
  _.each(old_results, function (doc) {                                                                // 147
    if (!new_presence_of_id[doc._id])                                                                 // 148
      observer.removed && observer.removed(doc._id);                                                  // 149
  });                                                                                                 // 150
  // for each group of things in the new_results that is anchored by an unmoved                       // 151
  // element, iterate through the things before it.                                                   // 152
  var startOfGroup = 0;                                                                               // 153
  _.each(unmoved, function (endOfGroup) {                                                             // 154
    var groupId = new_results[endOfGroup] ? new_results[endOfGroup]._id : null;                       // 155
    var oldDoc;                                                                                       // 156
    var newDoc;                                                                                       // 157
    var fields;                                                                                       // 158
    for (var i = startOfGroup; i < endOfGroup; i++) {                                                 // 159
      newDoc = new_results[i];                                                                        // 160
      if (!_.has(old_index_of_id, newDoc._id)) {                                                      // 161
        fields = EJSON.clone(newDoc);                                                                 // 162
        delete fields._id;                                                                            // 163
        observer.addedBefore && observer.addedBefore(newDoc._id, fields, groupId);                    // 164
        observer.added && observer.added(newDoc._id, fields);                                         // 165
      } else {                                                                                        // 166
        // moved                                                                                      // 167
        oldDoc = old_results[old_index_of_id[newDoc._id]];                                            // 168
        fields = LocalCollection._makeChangedFields(newDoc, oldDoc);                                  // 169
        if (!_.isEmpty(fields)) {                                                                     // 170
          observer.changed && observer.changed(newDoc._id, fields);                                   // 171
        }                                                                                             // 172
        observer.movedBefore && observer.movedBefore(newDoc._id, groupId);                            // 173
      }                                                                                               // 174
    }                                                                                                 // 175
    if (groupId) {                                                                                    // 176
      newDoc = new_results[endOfGroup];                                                               // 177
      oldDoc = old_results[old_index_of_id[newDoc._id]];                                              // 178
      fields = LocalCollection._makeChangedFields(newDoc, oldDoc);                                    // 179
      if (!_.isEmpty(fields)) {                                                                       // 180
        observer.changed && observer.changed(newDoc._id, fields);                                     // 181
      }                                                                                               // 182
    }                                                                                                 // 183
    startOfGroup = endOfGroup+1;                                                                      // 184
  });                                                                                                 // 185
                                                                                                      // 186
                                                                                                      // 187
};                                                                                                    // 188
                                                                                                      // 189
                                                                                                      // 190
// General helper for diff-ing two objects.                                                           // 191
// callbacks is an object like so:                                                                    // 192
// { leftOnly: function (key, leftValue) {...},                                                       // 193
//   rightOnly: function (key, rightValue) {...},                                                     // 194
//   both: function (key, leftValue, rightValue) {...},                                               // 195
// }                                                                                                  // 196
LocalCollection._diffObjects = function (left, right, callbacks) {                                    // 197
  _.each(left, function (leftValue, key) {                                                            // 198
    if (_.has(right, key))                                                                            // 199
      callbacks.both && callbacks.both(key, leftValue, right[key]);                                   // 200
    else                                                                                              // 201
      callbacks.leftOnly && callbacks.leftOnly(key, leftValue);                                       // 202
  });                                                                                                 // 203
  if (callbacks.rightOnly) {                                                                          // 204
    _.each(right, function(rightValue, key) {                                                         // 205
      if (!_.has(left, key))                                                                          // 206
        callbacks.rightOnly(key, rightValue);                                                         // 207
    });                                                                                               // 208
  }                                                                                                   // 209
};                                                                                                    // 210
                                                                                                      // 211
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                    //
// packages/minimongo/objectid.js                                                                     //
//                                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                      //
LocalCollection._looksLikeObjectID = function (str) {                                                 // 1
  return str.length === 24 && str.match(/^[0-9a-f]*$/);                                               // 2
};                                                                                                    // 3
                                                                                                      // 4
LocalCollection._ObjectID = function (hexString) {                                                    // 5
  //random-based impl of Mongo ObjectID                                                               // 6
  var self = this;                                                                                    // 7
  if (hexString) {                                                                                    // 8
    hexString = hexString.toLowerCase();                                                              // 9
    if (!LocalCollection._looksLikeObjectID(hexString)) {                                             // 10
      throw new Error("Invalid hexadecimal string for creating an ObjectID");                         // 11
    }                                                                                                 // 12
    // meant to work with _.isEqual(), which relies on structural equality                            // 13
    self._str = hexString;                                                                            // 14
  } else {                                                                                            // 15
    self._str = Random.hexString(24);                                                                 // 16
  }                                                                                                   // 17
};                                                                                                    // 18
                                                                                                      // 19
LocalCollection._ObjectID.prototype.toString = function () {                                          // 20
  var self = this;                                                                                    // 21
  return "ObjectID(\"" + self._str + "\")";                                                           // 22
};                                                                                                    // 23
                                                                                                      // 24
LocalCollection._ObjectID.prototype.equals = function (other) {                                       // 25
  var self = this;                                                                                    // 26
  return other instanceof LocalCollection._ObjectID &&                                                // 27
    self.valueOf() === other.valueOf();                                                               // 28
};                                                                                                    // 29
                                                                                                      // 30
LocalCollection._ObjectID.prototype.clone = function () {                                             // 31
  var self = this;                                                                                    // 32
  return new LocalCollection._ObjectID(self._str);                                                    // 33
};                                                                                                    // 34
                                                                                                      // 35
LocalCollection._ObjectID.prototype.typeName = function() {                                           // 36
  return "oid";                                                                                       // 37
};                                                                                                    // 38
                                                                                                      // 39
LocalCollection._ObjectID.prototype.getTimestamp = function() {                                       // 40
  var self = this;                                                                                    // 41
  return parseInt(self._str.substr(0, 8), 16);                                                        // 42
};                                                                                                    // 43
                                                                                                      // 44
LocalCollection._ObjectID.prototype.valueOf =                                                         // 45
    LocalCollection._ObjectID.prototype.toJSONValue =                                                 // 46
    LocalCollection._ObjectID.prototype.toHexString =                                                 // 47
    function () { return this._str; };                                                                // 48
                                                                                                      // 49
// Is this selector just shorthand for lookup by _id?                                                 // 50
LocalCollection._selectorIsId = function (selector) {                                                 // 51
  return (typeof selector === "string") ||                                                            // 52
    (typeof selector === "number") ||                                                                 // 53
    selector instanceof LocalCollection._ObjectID;                                                    // 54
};                                                                                                    // 55
                                                                                                      // 56
// Is the selector just lookup by _id (shorthand or not)?                                             // 57
LocalCollection._selectorIsIdPerhapsAsObject = function (selector) {                                  // 58
  return LocalCollection._selectorIsId(selector) ||                                                   // 59
    (selector && typeof selector === "object" &&                                                      // 60
     selector._id && LocalCollection._selectorIsId(selector._id) &&                                   // 61
     _.size(selector) === 1);                                                                         // 62
};                                                                                                    // 63
                                                                                                      // 64
// If this is a selector which explicitly constrains the match by ID to a finite                      // 65
// number of documents, returns a list of their IDs.  Otherwise returns                               // 66
// null. Note that the selector may have other restrictions so it may not even                        // 67
// match those document!  We care about $in and $and since those are generated                        // 68
// access-controlled update and remove.                                                               // 69
LocalCollection._idsMatchedBySelector = function (selector) {                                         // 70
  // Is the selector just an ID?                                                                      // 71
  if (LocalCollection._selectorIsId(selector))                                                        // 72
    return [selector];                                                                                // 73
  if (!selector)                                                                                      // 74
    return null;                                                                                      // 75
                                                                                                      // 76
  // Do we have an _id clause?                                                                        // 77
  if (_.has(selector, '_id')) {                                                                       // 78
    // Is the _id clause just an ID?                                                                  // 79
    if (LocalCollection._selectorIsId(selector._id))                                                  // 80
      return [selector._id];                                                                          // 81
    // Is the _id clause {_id: {$in: ["x", "y", "z"]}}?                                               // 82
    if (selector._id && selector._id.$in                                                              // 83
        && _.isArray(selector._id.$in)                                                                // 84
        && !_.isEmpty(selector._id.$in)                                                               // 85
        && _.all(selector._id.$in, LocalCollection._selectorIsId)) {                                  // 86
      return selector._id.$in;                                                                        // 87
    }                                                                                                 // 88
    return null;                                                                                      // 89
  }                                                                                                   // 90
                                                                                                      // 91
  // If this is a top-level $and, and any of the clauses constrain their                              // 92
  // documents, then the whole selector is constrained by any one clause's                            // 93
  // constraint. (Well, by their intersection, but that seems unlikely.)                              // 94
  if (selector.$and && _.isArray(selector.$and)) {                                                    // 95
    for (var i = 0; i < selector.$and.length; ++i) {                                                  // 96
      var subIds = LocalCollection._idsMatchedBySelector(selector.$and[i]);                           // 97
      if (subIds)                                                                                     // 98
        return subIds;                                                                                // 99
    }                                                                                                 // 100
  }                                                                                                   // 101
                                                                                                      // 102
  return null;                                                                                        // 103
};                                                                                                    // 104
                                                                                                      // 105
EJSON.addType("oid",  function (str) {                                                                // 106
  return new LocalCollection._ObjectID(str);                                                          // 107
});                                                                                                   // 108
                                                                                                      // 109
////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.minimongo = {
  LocalCollection: LocalCollection
};

})();

//# sourceMappingURL=610357a74e3b05ed6f79baa17793b0d26e9daf03.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var check = Package.check.check;
var Match = Package.check.Match;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var JSON = Package.json.JSON;
var _ = Package.underscore._;
var Deps = Package.deps.Deps;
var Reload = Package.reload.Reload;
var LocalCollection = Package.minimongo.LocalCollection;

/* Package-scope variables */
var DDP, LivedataTest, SockJS, toSockjsUrl, toWebsocketUrl, SUPPORTED_DDP_VERSIONS, MethodInvocation, parseDDP, stringifyDDP, allConnections;

(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/common.js                                                                                    //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
LivedataTest = {};                                                                                                // 1
                                                                                                                  // 2
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/sockjs-0.3.4.js                                                                              //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// XXX METEOR changes in <METEOR>                                                                                 // 1
                                                                                                                  // 2
/* SockJS client, version 0.3.4, http://sockjs.org, MIT License                                                   // 3
                                                                                                                  // 4
Copyright (c) 2011-2012 VMware, Inc.                                                                              // 5
                                                                                                                  // 6
Permission is hereby granted, free of charge, to any person obtaining a copy                                      // 7
of this software and associated documentation files (the "Software"), to deal                                     // 8
in the Software without restriction, including without limitation the rights                                      // 9
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                                         // 10
copies of the Software, and to permit persons to whom the Software is                                             // 11
furnished to do so, subject to the following conditions:                                                          // 12
                                                                                                                  // 13
The above copyright notice and this permission notice shall be included in                                        // 14
all copies or substantial portions of the Software.                                                               // 15
                                                                                                                  // 16
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                        // 17
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                          // 18
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                       // 19
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                            // 20
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                     // 21
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                                         // 22
THE SOFTWARE.                                                                                                     // 23
*/                                                                                                                // 24
                                                                                                                  // 25
// <METEOR> Commented out JSO implementation (use json package instead).                                          // 26
// JSON2 by Douglas Crockford (minified).                                                                         // 27
// var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()
// </METEOR>                                                                                                      // 29
                                                                                                                  // 30
//     [*] Including lib/index.js                                                                                 // 31
// Public object                                                                                                  // 32
                                                                                                                  // 33
var notImpl = function (name) {                                                                                   // 34
  return function () {                                                                                            // 35
    Meteor._debug(new Error('not implemented: ' + name).stack);                                                   // 36
  };                                                                                                              // 37
};                                                                                                                // 38
                                                                                                                  // 39
SockJS = (function(){                                                                                             // 40
              var _document = (typeof document !== 'undefined') ? document : {                                    // 41
  location: location,                                                                                             // 42
  attachEvent: notImpl('attachEvent'),                                                                            // 43
  detachEvent: notImpl('detachEvent'),                                                                            // 44
  createElement: notImpl('createElement'),                                                                        // 45
  domain: location.hostname                                                                                       // 46
};                                                                                                                // 47
              var _window = (typeof window !== 'undefined') ? window : {                                          // 48
  location: location,                                                                                             // 49
  WebSocket: WebSocket,                                                                                           // 50
  XMLHttpRequest: XMLHttpRequest                                                                                  // 51
};                                                                                                                // 52
              var utils = {};                                                                                     // 53
                                                                                                                  // 54
                                                                                                                  // 55
//         [*] Including lib/reventtarget.js                                                                      // 56
/*                                                                                                                // 57
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 58
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 59
 *                                                                                                                // 60
 * For the license see COPYING.                                                                                   // 61
 * ***** END LICENSE BLOCK *****                                                                                  // 62
 */                                                                                                               // 63
                                                                                                                  // 64
/* Simplified implementation of DOM2 EventTarget.                                                                 // 65
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget                                       // 66
 */                                                                                                               // 67
var REventTarget = function() {};                                                                                 // 68
REventTarget.prototype.addEventListener = function (eventType, listener) {                                        // 69
    if(!this._listeners) {                                                                                        // 70
         this._listeners = {};                                                                                    // 71
    }                                                                                                             // 72
    if(!(eventType in this._listeners)) {                                                                         // 73
        this._listeners[eventType] = [];                                                                          // 74
    }                                                                                                             // 75
    var arr = this._listeners[eventType];                                                                         // 76
    if(utils.arrIndexOf(arr, listener) === -1) {                                                                  // 77
        arr.push(listener);                                                                                       // 78
    }                                                                                                             // 79
    return;                                                                                                       // 80
};                                                                                                                // 81
                                                                                                                  // 82
REventTarget.prototype.removeEventListener = function (eventType, listener) {                                     // 83
    if(!(this._listeners && (eventType in this._listeners))) {                                                    // 84
        return;                                                                                                   // 85
    }                                                                                                             // 86
    var arr = this._listeners[eventType];                                                                         // 87
    var idx = utils.arrIndexOf(arr, listener);                                                                    // 88
    if (idx !== -1) {                                                                                             // 89
        if(arr.length > 1) {                                                                                      // 90
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );                            // 91
        } else {                                                                                                  // 92
            delete this._listeners[eventType];                                                                    // 93
        }                                                                                                         // 94
        return;                                                                                                   // 95
    }                                                                                                             // 96
    return;                                                                                                       // 97
};                                                                                                                // 98
                                                                                                                  // 99
REventTarget.prototype.dispatchEvent = function (event) {                                                         // 100
    var t = event.type;                                                                                           // 101
    var args = Array.prototype.slice.call(arguments, 0);                                                          // 102
    if (this['on'+t]) {                                                                                           // 103
        this['on'+t].apply(this, args);                                                                           // 104
    }                                                                                                             // 105
    if (this._listeners && t in this._listeners) {                                                                // 106
        for(var i=0; i < this._listeners[t].length; i++) {                                                        // 107
            this._listeners[t][i].apply(this, args);                                                              // 108
        }                                                                                                         // 109
    }                                                                                                             // 110
};                                                                                                                // 111
//         [*] End of lib/reventtarget.js                                                                         // 112
                                                                                                                  // 113
                                                                                                                  // 114
//         [*] Including lib/simpleevent.js                                                                       // 115
/*                                                                                                                // 116
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 117
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 118
 *                                                                                                                // 119
 * For the license see COPYING.                                                                                   // 120
 * ***** END LICENSE BLOCK *****                                                                                  // 121
 */                                                                                                               // 122
                                                                                                                  // 123
var SimpleEvent = function(type, obj) {                                                                           // 124
    this.type = type;                                                                                             // 125
    if (typeof obj !== 'undefined') {                                                                             // 126
        for(var k in obj) {                                                                                       // 127
            if (!obj.hasOwnProperty(k)) continue;                                                                 // 128
            this[k] = obj[k];                                                                                     // 129
        }                                                                                                         // 130
    }                                                                                                             // 131
};                                                                                                                // 132
                                                                                                                  // 133
SimpleEvent.prototype.toString = function() {                                                                     // 134
    var r = [];                                                                                                   // 135
    for(var k in this) {                                                                                          // 136
        if (!this.hasOwnProperty(k)) continue;                                                                    // 137
        var v = this[k];                                                                                          // 138
        if (typeof v === 'function') v = '[function]';                                                            // 139
        r.push(k + '=' + v);                                                                                      // 140
    }                                                                                                             // 141
    return 'SimpleEvent(' + r.join(', ') + ')';                                                                   // 142
};                                                                                                                // 143
//         [*] End of lib/simpleevent.js                                                                          // 144
                                                                                                                  // 145
                                                                                                                  // 146
//         [*] Including lib/eventemitter.js                                                                      // 147
/*                                                                                                                // 148
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 149
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 150
 *                                                                                                                // 151
 * For the license see COPYING.                                                                                   // 152
 * ***** END LICENSE BLOCK *****                                                                                  // 153
 */                                                                                                               // 154
                                                                                                                  // 155
var EventEmitter = function(events) {                                                                             // 156
    var that = this;                                                                                              // 157
    that._events = events || [];                                                                                  // 158
    that._listeners = {};                                                                                         // 159
};                                                                                                                // 160
EventEmitter.prototype.emit = function(type) {                                                                    // 161
    var that = this;                                                                                              // 162
    that._verifyType(type);                                                                                       // 163
    if (that._nuked) return;                                                                                      // 164
                                                                                                                  // 165
    var args = Array.prototype.slice.call(arguments, 1);                                                          // 166
    if (that['on'+type]) {                                                                                        // 167
        that['on'+type].apply(that, args);                                                                        // 168
    }                                                                                                             // 169
    if (type in that._listeners) {                                                                                // 170
        for(var i = 0; i < that._listeners[type].length; i++) {                                                   // 171
            that._listeners[type][i].apply(that, args);                                                           // 172
        }                                                                                                         // 173
    }                                                                                                             // 174
};                                                                                                                // 175
                                                                                                                  // 176
EventEmitter.prototype.on = function(type, callback) {                                                            // 177
    var that = this;                                                                                              // 178
    that._verifyType(type);                                                                                       // 179
    if (that._nuked) return;                                                                                      // 180
                                                                                                                  // 181
    if (!(type in that._listeners)) {                                                                             // 182
        that._listeners[type] = [];                                                                               // 183
    }                                                                                                             // 184
    that._listeners[type].push(callback);                                                                         // 185
};                                                                                                                // 186
                                                                                                                  // 187
EventEmitter.prototype._verifyType = function(type) {                                                             // 188
    var that = this;                                                                                              // 189
    if (utils.arrIndexOf(that._events, type) === -1) {                                                            // 190
        utils.log('Event ' + JSON.stringify(type) +                                                               // 191
                  ' not listed ' + JSON.stringify(that._events) +                                                 // 192
                  ' in ' + that);                                                                                 // 193
    }                                                                                                             // 194
};                                                                                                                // 195
                                                                                                                  // 196
EventEmitter.prototype.nuke = function() {                                                                        // 197
    var that = this;                                                                                              // 198
    that._nuked = true;                                                                                           // 199
    for(var i=0; i<that._events.length; i++) {                                                                    // 200
        delete that[that._events[i]];                                                                             // 201
    }                                                                                                             // 202
    that._listeners = {};                                                                                         // 203
};                                                                                                                // 204
//         [*] End of lib/eventemitter.js                                                                         // 205
                                                                                                                  // 206
                                                                                                                  // 207
//         [*] Including lib/utils.js                                                                             // 208
/*                                                                                                                // 209
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 210
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 211
 *                                                                                                                // 212
 * For the license see COPYING.                                                                                   // 213
 * ***** END LICENSE BLOCK *****                                                                                  // 214
 */                                                                                                               // 215
                                                                                                                  // 216
var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';                                                // 217
utils.random_string = function(length, max) {                                                                     // 218
    max = max || random_string_chars.length;                                                                      // 219
    var i, ret = [];                                                                                              // 220
    for(i=0; i < length; i++) {                                                                                   // 221
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );                                // 222
    }                                                                                                             // 223
    return ret.join('');                                                                                          // 224
};                                                                                                                // 225
utils.random_number = function(max) {                                                                             // 226
    return Math.floor(Math.random() * max);                                                                       // 227
};                                                                                                                // 228
utils.random_number_string = function(max) {                                                                      // 229
    var t = (''+(max - 1)).length;                                                                                // 230
    var p = Array(t+1).join('0');                                                                                 // 231
    return (p + utils.random_number(max)).slice(-t);                                                              // 232
};                                                                                                                // 233
                                                                                                                  // 234
// Assuming that url looks like: http://asdasd:111/asd                                                            // 235
utils.getOrigin = function(url) {                                                                                 // 236
    url += '/';                                                                                                   // 237
    var parts = url.split('/').slice(0, 3);                                                                       // 238
    return parts.join('/');                                                                                       // 239
};                                                                                                                // 240
                                                                                                                  // 241
utils.isSameOriginUrl = function(url_a, url_b) {                                                                  // 242
    // location.origin would do, but it's not always available.                                                   // 243
    if (!url_b) url_b = _window.location.href;                                                                    // 244
                                                                                                                  // 245
    return (url_a.split('/').slice(0,3).join('/')                                                                 // 246
                ===                                                                                               // 247
            url_b.split('/').slice(0,3).join('/'));                                                               // 248
};                                                                                                                // 249
                                                                                                                  // 250
// <METEOR>                                                                                                       // 251
// https://github.com/sockjs/sockjs-client/issues/79                                                              // 252
utils.isSameOriginScheme = function(url_a, url_b) {                                                               // 253
    if (!url_b) url_b = _window.location.href;                                                                    // 254
                                                                                                                  // 255
    return (url_a.split(':')[0]                                                                                   // 256
                ===                                                                                               // 257
            url_b.split(':')[0]);                                                                                 // 258
};                                                                                                                // 259
// </METEOR>                                                                                                      // 260
                                                                                                                  // 261
                                                                                                                  // 262
utils.getParentDomain = function(url) {                                                                           // 263
    // ipv4 ip address                                                                                            // 264
    if (/^[0-9.]*$/.test(url)) return url;                                                                        // 265
    // ipv6 ip address                                                                                            // 266
    if (/^\[/.test(url)) return url;                                                                              // 267
    // no dots                                                                                                    // 268
    if (!(/[.]/.test(url))) return url;                                                                           // 269
                                                                                                                  // 270
    var parts = url.split('.').slice(1);                                                                          // 271
    return parts.join('.');                                                                                       // 272
};                                                                                                                // 273
                                                                                                                  // 274
utils.objectExtend = function(dst, src) {                                                                         // 275
    for(var k in src) {                                                                                           // 276
        if (src.hasOwnProperty(k)) {                                                                              // 277
            dst[k] = src[k];                                                                                      // 278
        }                                                                                                         // 279
    }                                                                                                             // 280
    return dst;                                                                                                   // 281
};                                                                                                                // 282
                                                                                                                  // 283
var WPrefix = '_jp';                                                                                              // 284
                                                                                                                  // 285
utils.polluteGlobalNamespace = function() {                                                                       // 286
    if (!(WPrefix in _window)) {                                                                                  // 287
        _window[WPrefix] = {};                                                                                    // 288
    }                                                                                                             // 289
};                                                                                                                // 290
                                                                                                                  // 291
utils.closeFrame = function (code, reason) {                                                                      // 292
    return 'c'+JSON.stringify([code, reason]);                                                                    // 293
};                                                                                                                // 294
                                                                                                                  // 295
utils.userSetCode = function (code) {                                                                             // 296
    return code === 1000 || (code >= 3000 && code <= 4999);                                                       // 297
};                                                                                                                // 298
                                                                                                                  // 299
// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/                                         // 300
// and RFC 2988.                                                                                                  // 301
utils.countRTO = function (rtt) {                                                                                 // 302
    var rto;                                                                                                      // 303
    if (rtt > 100) {                                                                                              // 304
        rto = 3 * rtt; // rto > 300msec                                                                           // 305
    } else {                                                                                                      // 306
        rto = rtt + 200; // 200msec < rto <= 300msec                                                              // 307
    }                                                                                                             // 308
    return rto;                                                                                                   // 309
}                                                                                                                 // 310
                                                                                                                  // 311
utils.log = function() {                                                                                          // 312
    Meteor._debug.apply(null, arguments);                                                                         // 313
};                                                                                                                // 314
                                                                                                                  // 315
utils.bind = function(fun, that) {                                                                                // 316
    if (fun.bind) {                                                                                               // 317
        return fun.bind(that);                                                                                    // 318
    } else {                                                                                                      // 319
        return function() {                                                                                       // 320
            return fun.apply(that, arguments);                                                                    // 321
        };                                                                                                        // 322
    }                                                                                                             // 323
};                                                                                                                // 324
                                                                                                                  // 325
utils.flatUrl = function(url) {                                                                                   // 326
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;                                                    // 327
};                                                                                                                // 328
                                                                                                                  // 329
utils.amendUrl = function(url) {                                                                                  // 330
    var dl = _document.location;                                                                                  // 331
    if (!url) {                                                                                                   // 332
        throw new Error('Wrong url for SockJS');                                                                  // 333
    }                                                                                                             // 334
    if (!utils.flatUrl(url)) {                                                                                    // 335
        throw new Error('Only basic urls are supported in SockJS');                                               // 336
    }                                                                                                             // 337
                                                                                                                  // 338
    //  '//abc' --> 'http://abc'                                                                                  // 339
    if (url.indexOf('//') === 0) {                                                                                // 340
        url = dl.protocol + url;                                                                                  // 341
    }                                                                                                             // 342
    // '/abc' --> 'http://localhost:1234/abc'                                                                     // 343
    if (url.indexOf('/') === 0) {                                                                                 // 344
        url = dl.protocol + '//' + dl.host + url;                                                                 // 345
    }                                                                                                             // 346
    // strip trailing slashes                                                                                     // 347
    url = url.replace(/[/]+$/,'');                                                                                // 348
                                                                                                                  // 349
    // We have a full url here, with proto and host. For some browsers                                            // 350
    // http://localhost:80/ is not in the same origin as http://localhost/                                        // 351
	// Remove explicit :80 or :443 in such cases. See #74                                                            // 352
    var parts = url.split("/");                                                                                   // 353
    if ((parts[0] === "http:" && /:80$/.test(parts[2])) ||                                                        // 354
	    (parts[0] === "https:" && /:443$/.test(parts[2]))) {                                                         // 355
		parts[2] = parts[2].replace(/:(80|443)$/, "");                                                                  // 356
	}                                                                                                                // 357
    url = parts.join("/");                                                                                        // 358
    return url;                                                                                                   // 359
};                                                                                                                // 360
                                                                                                                  // 361
// IE doesn't support [].indexOf.                                                                                 // 362
utils.arrIndexOf = function(arr, obj){                                                                            // 363
    for(var i=0; i < arr.length; i++){                                                                            // 364
        if(arr[i] === obj){                                                                                       // 365
            return i;                                                                                             // 366
        }                                                                                                         // 367
    }                                                                                                             // 368
    return -1;                                                                                                    // 369
};                                                                                                                // 370
                                                                                                                  // 371
utils.arrSkip = function(arr, obj) {                                                                              // 372
    var idx = utils.arrIndexOf(arr, obj);                                                                         // 373
    if (idx === -1) {                                                                                             // 374
        return arr.slice();                                                                                       // 375
    } else {                                                                                                      // 376
        var dst = arr.slice(0, idx);                                                                              // 377
        return dst.concat(arr.slice(idx+1));                                                                      // 378
    }                                                                                                             // 379
};                                                                                                                // 380
                                                                                                                  // 381
// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df                                  // 382
utils.isArray = Array.isArray || function(value) {                                                                // 383
    return {}.toString.call(value).indexOf('Array') >= 0                                                          // 384
};                                                                                                                // 385
                                                                                                                  // 386
utils.delay = function(t, fun) {                                                                                  // 387
    if(typeof t === 'function') {                                                                                 // 388
        fun = t;                                                                                                  // 389
        t = 0;                                                                                                    // 390
    }                                                                                                             // 391
    return setTimeout(fun, t);                                                                                    // 392
};                                                                                                                // 393
                                                                                                                  // 394
                                                                                                                  // 395
// Chars worth escaping, as defined by Douglas Crockford:                                                         // 396
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196      // 397
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {                                                                                               // 399
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",                                      // 400
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",                                      // 401
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",                                        // 402
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",                                      // 403
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",                                      // 404
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",                                      // 405
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",                                      // 406
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",                                                    // 407
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",                                      // 408
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",                                      // 409
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",                                      // 410
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",                                      // 411
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",                                      // 412
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",                                      // 413
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",                                      // 414
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",                                      // 415
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",                                      // 416
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",                                      // 417
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",                                      // 418
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",                                      // 419
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",                                      // 420
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",                                      // 421
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",                                      // 422
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",                                      // 423
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",                                      // 424
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",                                      // 425
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",                                      // 426
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",                                      // 427
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",                                      // 428
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};                                                        // 429
                                                                                                                  // 430
// Some extra characters that Chrome gets wrong, and substitutes with                                             // 431
// something else on the wire.                                                                                    // 432
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;                                                                                                 // 434
                                                                                                                  // 435
// JSON Quote string. Use native implementation when possible.                                                    // 436
var JSONQuote = (JSON && JSON.stringify) || function(string) {                                                    // 437
    json_escapable.lastIndex = 0;                                                                                 // 438
    if (json_escapable.test(string)) {                                                                            // 439
        string = string.replace(json_escapable, function(a) {                                                     // 440
            return json_lookup[a];                                                                                // 441
        });                                                                                                       // 442
    }                                                                                                             // 443
    return '"' + string + '"';                                                                                    // 444
};                                                                                                                // 445
                                                                                                                  // 446
// This may be quite slow, so let's delay until user actually uses bad                                            // 447
// characters.                                                                                                    // 448
var unroll_lookup = function(escapable) {                                                                         // 449
    var i;                                                                                                        // 450
    var unrolled = {}                                                                                             // 451
    var c = []                                                                                                    // 452
    for(i=0; i<65536; i++) {                                                                                      // 453
        c.push( String.fromCharCode(i) );                                                                         // 454
    }                                                                                                             // 455
    escapable.lastIndex = 0;                                                                                      // 456
    c.join('').replace(escapable, function (a) {                                                                  // 457
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);                                // 458
        return '';                                                                                                // 459
    });                                                                                                           // 460
    escapable.lastIndex = 0;                                                                                      // 461
    return unrolled;                                                                                              // 462
};                                                                                                                // 463
                                                                                                                  // 464
// Quote string, also taking care of unicode characters that browsers                                             // 465
// often break. Especially, take care of unicode surrogates:                                                      // 466
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates                                       // 467
utils.quote = function(string) {                                                                                  // 468
    var quoted = JSONQuote(string);                                                                               // 469
                                                                                                                  // 470
    // In most cases this should be very fast and good enough.                                                    // 471
    extra_escapable.lastIndex = 0;                                                                                // 472
    if(!extra_escapable.test(quoted)) {                                                                           // 473
        return quoted;                                                                                            // 474
    }                                                                                                             // 475
                                                                                                                  // 476
    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);                                              // 477
                                                                                                                  // 478
    return quoted.replace(extra_escapable, function(a) {                                                          // 479
        return extra_lookup[a];                                                                                   // 480
    });                                                                                                           // 481
}                                                                                                                 // 482
                                                                                                                  // 483
var _all_protocols = ['websocket',                                                                                // 484
                      'xdr-streaming',                                                                            // 485
                      'xhr-streaming',                                                                            // 486
                      'iframe-eventsource',                                                                       // 487
                      'iframe-htmlfile',                                                                          // 488
                      'xdr-polling',                                                                              // 489
                      'xhr-polling',                                                                              // 490
                      'iframe-xhr-polling',                                                                       // 491
                      'jsonp-polling'];                                                                           // 492
                                                                                                                  // 493
utils.probeProtocols = function() {                                                                               // 494
    var probed = {};                                                                                              // 495
    for(var i=0; i<_all_protocols.length; i++) {                                                                  // 496
        var protocol = _all_protocols[i];                                                                         // 497
        // User can have a typo in protocol name.                                                                 // 498
        probed[protocol] = SockJS[protocol] &&                                                                    // 499
                           SockJS[protocol].enabled();                                                            // 500
    }                                                                                                             // 501
    return probed;                                                                                                // 502
};                                                                                                                // 503
                                                                                                                  // 504
utils.detectProtocols = function(probed, protocols_whitelist, info) {                                             // 505
    var pe = {},                                                                                                  // 506
        protocols = [];                                                                                           // 507
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;                                               // 508
    for(var i=0; i<protocols_whitelist.length; i++) {                                                             // 509
        var protocol = protocols_whitelist[i];                                                                    // 510
        pe[protocol] = probed[protocol];                                                                          // 511
    }                                                                                                             // 512
    var maybe_push = function(protos) {                                                                           // 513
        var proto = protos.shift();                                                                               // 514
        if (pe[proto]) {                                                                                          // 515
            protocols.push(proto);                                                                                // 516
        } else {                                                                                                  // 517
            if (protos.length > 0) {                                                                              // 518
                maybe_push(protos);                                                                               // 519
            }                                                                                                     // 520
        }                                                                                                         // 521
    }                                                                                                             // 522
                                                                                                                  // 523
    // 1. Websocket                                                                                               // 524
    if (info.websocket !== false) {                                                                               // 525
        maybe_push(['websocket']);                                                                                // 526
    }                                                                                                             // 527
                                                                                                                  // 528
    // 2. Streaming                                                                                               // 529
    if (pe['xhr-streaming'] && !info.null_origin) {                                                               // 530
        protocols.push('xhr-streaming');                                                                          // 531
    } else {                                                                                                      // 532
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {                                    // 533
            protocols.push('xdr-streaming');                                                                      // 534
        } else {                                                                                                  // 535
            maybe_push(['iframe-eventsource',                                                                     // 536
                        'iframe-htmlfile']);                                                                      // 537
        }                                                                                                         // 538
    }                                                                                                             // 539
                                                                                                                  // 540
    // 3. Polling                                                                                                 // 541
    if (pe['xhr-polling'] && !info.null_origin) {                                                                 // 542
        protocols.push('xhr-polling');                                                                            // 543
    } else {                                                                                                      // 544
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {                                      // 545
            protocols.push('xdr-polling');                                                                        // 546
        } else {                                                                                                  // 547
            maybe_push(['iframe-xhr-polling',                                                                     // 548
                        'jsonp-polling']);                                                                        // 549
        }                                                                                                         // 550
    }                                                                                                             // 551
    return protocols;                                                                                             // 552
}                                                                                                                 // 553
//         [*] End of lib/utils.js                                                                                // 554
                                                                                                                  // 555
                                                                                                                  // 556
//         [*] Including lib/dom.js                                                                               // 557
/*                                                                                                                // 558
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 559
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 560
 *                                                                                                                // 561
 * For the license see COPYING.                                                                                   // 562
 * ***** END LICENSE BLOCK *****                                                                                  // 563
 */                                                                                                               // 564
                                                                                                                  // 565
// May be used by htmlfile jsonp and transports.                                                                  // 566
var MPrefix = '_sockjs_global';                                                                                   // 567
utils.createHook = function() {                                                                                   // 568
    var window_id = 'a' + utils.random_string(8);                                                                 // 569
    if (!(MPrefix in _window)) {                                                                                  // 570
        var map = {};                                                                                             // 571
        _window[MPrefix] = function(window_id) {                                                                  // 572
            if (!(window_id in map)) {                                                                            // 573
                map[window_id] = {                                                                                // 574
                    id: window_id,                                                                                // 575
                    del: function() {delete map[window_id];}                                                      // 576
                };                                                                                                // 577
            }                                                                                                     // 578
            return map[window_id];                                                                                // 579
        }                                                                                                         // 580
    }                                                                                                             // 581
    return _window[MPrefix](window_id);                                                                           // 582
};                                                                                                                // 583
                                                                                                                  // 584
                                                                                                                  // 585
                                                                                                                  // 586
utils.attachMessage = function(listener) {                                                                        // 587
    utils.attachEvent('message', listener);                                                                       // 588
};                                                                                                                // 589
utils.attachEvent = function(event, listener) {                                                                   // 590
    if (typeof _window.addEventListener !== 'undefined') {                                                        // 591
        _window.addEventListener(event, listener, false);                                                         // 592
    } else {                                                                                                      // 593
        // IE quirks.                                                                                             // 594
        // According to: http://stevesouders.com/misc/test-postmessage.php                                        // 595
        // the message gets delivered only to 'document', not 'window'.                                           // 596
        _document.attachEvent("on" + event, listener);                                                            // 597
        // I get 'window' for ie8.                                                                                // 598
        _window.attachEvent("on" + event, listener);                                                              // 599
    }                                                                                                             // 600
};                                                                                                                // 601
                                                                                                                  // 602
utils.detachMessage = function(listener) {                                                                        // 603
    utils.detachEvent('message', listener);                                                                       // 604
};                                                                                                                // 605
utils.detachEvent = function(event, listener) {                                                                   // 606
    if (typeof _window.addEventListener !== 'undefined') {                                                        // 607
        _window.removeEventListener(event, listener, false);                                                      // 608
    } else {                                                                                                      // 609
        _document.detachEvent("on" + event, listener);                                                            // 610
        _window.detachEvent("on" + event, listener);                                                              // 611
    }                                                                                                             // 612
};                                                                                                                // 613
                                                                                                                  // 614
                                                                                                                  // 615
var on_unload = {};                                                                                               // 616
// Things registered after beforeunload are to be called immediately.                                             // 617
var after_unload = false;                                                                                         // 618
                                                                                                                  // 619
var trigger_unload_callbacks = function() {                                                                       // 620
    for(var ref in on_unload) {                                                                                   // 621
        on_unload[ref]();                                                                                         // 622
        delete on_unload[ref];                                                                                    // 623
    };                                                                                                            // 624
};                                                                                                                // 625
                                                                                                                  // 626
var unload_triggered = function() {                                                                               // 627
    if(after_unload) return;                                                                                      // 628
    after_unload = true;                                                                                          // 629
    trigger_unload_callbacks();                                                                                   // 630
};                                                                                                                // 631
                                                                                                                  // 632
utils.unload_add = function(listener) {                                                                           // 633
    var ref = utils.random_string(8);                                                                             // 634
    on_unload[ref] = listener;                                                                                    // 635
    if (after_unload) {                                                                                           // 636
        utils.delay(trigger_unload_callbacks);                                                                    // 637
    }                                                                                                             // 638
    return ref;                                                                                                   // 639
};                                                                                                                // 640
utils.unload_del = function(ref) {                                                                                // 641
    if (ref in on_unload)                                                                                         // 642
        delete on_unload[ref];                                                                                    // 643
};                                                                                                                // 644
                                                                                                                  // 645
                                                                                                                  // 646
utils.createIframe = function (iframe_url, error_callback) {                                                      // 647
    var iframe = _document.createElement('iframe');                                                               // 648
    var tref, unload_ref;                                                                                         // 649
    var unattach = function() {                                                                                   // 650
        clearTimeout(tref);                                                                                       // 651
        // Explorer had problems with that.                                                                       // 652
        try {iframe.onload = null;} catch (x) {}                                                                  // 653
        iframe.onerror = null;                                                                                    // 654
    };                                                                                                            // 655
    var cleanup = function() {                                                                                    // 656
        if (iframe) {                                                                                             // 657
            unattach();                                                                                           // 658
            // This timeout makes chrome fire onbeforeunload event                                                // 659
            // within iframe. Without the timeout it goes straight to                                             // 660
            // onunload.                                                                                          // 661
            setTimeout(function() {                                                                               // 662
                if(iframe) {                                                                                      // 663
                    iframe.parentNode.removeChild(iframe);                                                        // 664
                }                                                                                                 // 665
                iframe = null;                                                                                    // 666
            }, 0);                                                                                                // 667
            utils.unload_del(unload_ref);                                                                         // 668
        }                                                                                                         // 669
    };                                                                                                            // 670
    var onerror = function(r) {                                                                                   // 671
        if (iframe) {                                                                                             // 672
            cleanup();                                                                                            // 673
            error_callback(r);                                                                                    // 674
        }                                                                                                         // 675
    };                                                                                                            // 676
    var post = function(msg, origin) {                                                                            // 677
        try {                                                                                                     // 678
            // When the iframe is not loaded, IE raises an exception                                              // 679
            // on 'contentWindow'.                                                                                // 680
            if (iframe && iframe.contentWindow) {                                                                 // 681
                iframe.contentWindow.postMessage(msg, origin);                                                    // 682
            }                                                                                                     // 683
        } catch (x) {};                                                                                           // 684
    };                                                                                                            // 685
                                                                                                                  // 686
    iframe.src = iframe_url;                                                                                      // 687
    iframe.style.display = 'none';                                                                                // 688
    iframe.style.position = 'absolute';                                                                           // 689
    iframe.onerror = function(){onerror('onerror');};                                                             // 690
    iframe.onload = function() {                                                                                  // 691
        // `onload` is triggered before scripts on the iframe are                                                 // 692
        // executed. Give it few seconds to actually load stuff.                                                  // 693
        clearTimeout(tref);                                                                                       // 694
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);                                          // 695
    };                                                                                                            // 696
    _document.body.appendChild(iframe);                                                                           // 697
    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                    // 698
    unload_ref = utils.unload_add(cleanup);                                                                       // 699
    return {                                                                                                      // 700
        post: post,                                                                                               // 701
        cleanup: cleanup,                                                                                         // 702
        loaded: unattach                                                                                          // 703
    };                                                                                                            // 704
};                                                                                                                // 705
                                                                                                                  // 706
utils.createHtmlfile = function (iframe_url, error_callback) {                                                    // 707
    var doc = new ActiveXObject('htmlfile');                                                                      // 708
    var tref, unload_ref;                                                                                         // 709
    var iframe;                                                                                                   // 710
    var unattach = function() {                                                                                   // 711
        clearTimeout(tref);                                                                                       // 712
    };                                                                                                            // 713
    var cleanup = function() {                                                                                    // 714
        if (doc) {                                                                                                // 715
            unattach();                                                                                           // 716
            utils.unload_del(unload_ref);                                                                         // 717
            iframe.parentNode.removeChild(iframe);                                                                // 718
            iframe = doc = null;                                                                                  // 719
            CollectGarbage();                                                                                     // 720
        }                                                                                                         // 721
    };                                                                                                            // 722
    var onerror = function(r)  {                                                                                  // 723
        if (doc) {                                                                                                // 724
            cleanup();                                                                                            // 725
            error_callback(r);                                                                                    // 726
        }                                                                                                         // 727
    };                                                                                                            // 728
    var post = function(msg, origin) {                                                                            // 729
        try {                                                                                                     // 730
            // When the iframe is not loaded, IE raises an exception                                              // 731
            // on 'contentWindow'.                                                                                // 732
            if (iframe && iframe.contentWindow) {                                                                 // 733
                iframe.contentWindow.postMessage(msg, origin);                                                    // 734
            }                                                                                                     // 735
        } catch (x) {};                                                                                           // 736
    };                                                                                                            // 737
                                                                                                                  // 738
    doc.open();                                                                                                   // 739
    doc.write('<html><s' + 'cript>' +                                                                             // 740
              'document.domain="' + document.domain + '";' +                                                      // 741
              '</s' + 'cript></html>');                                                                           // 742
    doc.close();                                                                                                  // 743
    doc.parentWindow[WPrefix] = _window[WPrefix];                                                                 // 744
    var c = doc.createElement('div');                                                                             // 745
    doc.body.appendChild(c);                                                                                      // 746
    iframe = doc.createElement('iframe');                                                                         // 747
    c.appendChild(iframe);                                                                                        // 748
    iframe.src = iframe_url;                                                                                      // 749
    tref = setTimeout(function(){onerror('timeout');}, 15000);                                                    // 750
    unload_ref = utils.unload_add(cleanup);                                                                       // 751
    return {                                                                                                      // 752
        post: post,                                                                                               // 753
        cleanup: cleanup,                                                                                         // 754
        loaded: unattach                                                                                          // 755
    };                                                                                                            // 756
};                                                                                                                // 757
//         [*] End of lib/dom.js                                                                                  // 758
                                                                                                                  // 759
                                                                                                                  // 760
//         [*] Including lib/dom2.js                                                                              // 761
/*                                                                                                                // 762
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 763
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 764
 *                                                                                                                // 765
 * For the license see COPYING.                                                                                   // 766
 * ***** END LICENSE BLOCK *****                                                                                  // 767
 */                                                                                                               // 768
                                                                                                                  // 769
var AbstractXHRObject = function(){};                                                                             // 770
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);                                              // 771
                                                                                                                  // 772
AbstractXHRObject.prototype._start = function(method, url, payload, opts) {                                       // 773
    var that = this;                                                                                              // 774
                                                                                                                  // 775
    try {                                                                                                         // 776
        that.xhr = new XMLHttpRequest();                                                                          // 777
    } catch(x) {};                                                                                                // 778
                                                                                                                  // 779
    if (!that.xhr) {                                                                                              // 780
        try {                                                                                                     // 781
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');                                            // 782
        } catch(x) {};                                                                                            // 783
    }                                                                                                             // 784
    if (_window.ActiveXObject || _window.XDomainRequest) {                                                        // 785
        // IE8 caches even POSTs                                                                                  // 786
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                        // 787
    }                                                                                                             // 788
                                                                                                                  // 789
    // Explorer tends to keep connection open, even after the                                                     // 790
    // tab gets closed: http://bugs.jquery.com/ticket/5280                                                        // 791
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                         // 792
    try {                                                                                                         // 793
        that.xhr.open(method, url, true);                                                                         // 794
    } catch(e) {                                                                                                  // 795
        // IE raises an exception on wrong port.                                                                  // 796
        that.emit('finish', 0, '');                                                                               // 797
        that._cleanup();                                                                                          // 798
        return;                                                                                                   // 799
    };                                                                                                            // 800
                                                                                                                  // 801
    if (!opts || !opts.no_credentials) {                                                                          // 802
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :                                    // 803
        // "This never affects same-site requests."                                                               // 804
        that.xhr.withCredentials = 'true';                                                                        // 805
    }                                                                                                             // 806
    if (opts && opts.headers) {                                                                                   // 807
        for(var key in opts.headers) {                                                                            // 808
            that.xhr.setRequestHeader(key, opts.headers[key]);                                                    // 809
        }                                                                                                         // 810
    }                                                                                                             // 811
                                                                                                                  // 812
    that.xhr.onreadystatechange = function() {                                                                    // 813
        if (that.xhr) {                                                                                           // 814
            var x = that.xhr;                                                                                     // 815
            switch (x.readyState) {                                                                               // 816
            case 3:                                                                                               // 817
                // IE doesn't like peeking into responseText or status                                            // 818
                // on Microsoft.XMLHTTP and readystate=3                                                          // 819
                try {                                                                                             // 820
                    var status = x.status;                                                                        // 821
                    var text = x.responseText;                                                                    // 822
                } catch (x) {};                                                                                   // 823
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                    // 824
                if (status === 1223) status = 204;                                                                // 825
                                                                                                                  // 826
                // IE does return readystate == 3 for 404 answers.                                                // 827
                if (text && text.length > 0) {                                                                    // 828
                    that.emit('chunk', status, text);                                                             // 829
                }                                                                                                 // 830
                break;                                                                                            // 831
            case 4:                                                                                               // 832
                var status = x.status;                                                                            // 833
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450                                    // 834
                if (status === 1223) status = 204;                                                                // 835
                                                                                                                  // 836
                that.emit('finish', status, x.responseText);                                                      // 837
                that._cleanup(false);                                                                             // 838
                break;                                                                                            // 839
            }                                                                                                     // 840
        }                                                                                                         // 841
    };                                                                                                            // 842
    that.xhr.send(payload);                                                                                       // 843
};                                                                                                                // 844
                                                                                                                  // 845
AbstractXHRObject.prototype._cleanup = function(abort) {                                                          // 846
    var that = this;                                                                                              // 847
    if (!that.xhr) return;                                                                                        // 848
    utils.unload_del(that.unload_ref);                                                                            // 849
                                                                                                                  // 850
    // IE needs this field to be a function                                                                       // 851
    that.xhr.onreadystatechange = function(){};                                                                   // 852
                                                                                                                  // 853
    if (abort) {                                                                                                  // 854
        try {                                                                                                     // 855
            that.xhr.abort();                                                                                     // 856
        } catch(x) {};                                                                                            // 857
    }                                                                                                             // 858
    that.unload_ref = that.xhr = null;                                                                            // 859
};                                                                                                                // 860
                                                                                                                  // 861
AbstractXHRObject.prototype.close = function() {                                                                  // 862
    var that = this;                                                                                              // 863
    that.nuke();                                                                                                  // 864
    that._cleanup(true);                                                                                          // 865
};                                                                                                                // 866
                                                                                                                  // 867
var XHRCorsObject = utils.XHRCorsObject = function() {                                                            // 868
    var that = this, args = arguments;                                                                            // 869
    utils.delay(function(){that._start.apply(that, args);});                                                      // 870
};                                                                                                                // 871
XHRCorsObject.prototype = new AbstractXHRObject();                                                                // 872
                                                                                                                  // 873
var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {                                      // 874
    var that = this;                                                                                              // 875
    utils.delay(function(){                                                                                       // 876
        that._start(method, url, payload, {                                                                       // 877
            no_credentials: true                                                                                  // 878
        });                                                                                                       // 879
    });                                                                                                           // 880
};                                                                                                                // 881
XHRLocalObject.prototype = new AbstractXHRObject();                                                               // 882
                                                                                                                  // 883
                                                                                                                  // 884
                                                                                                                  // 885
// References:                                                                                                    // 886
//   http://ajaxian.com/archives/100-line-ajax-wrapper                                                            // 887
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx                                               // 888
var XDRObject = utils.XDRObject = function(method, url, payload) {                                                // 889
    var that = this;                                                                                              // 890
    utils.delay(function(){that._start(method, url, payload);});                                                  // 891
};                                                                                                                // 892
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);                                                      // 893
XDRObject.prototype._start = function(method, url, payload) {                                                     // 894
    var that = this;                                                                                              // 895
    var xdr = new XDomainRequest();                                                                               // 896
    // IE caches even POSTs                                                                                       // 897
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);                                            // 898
                                                                                                                  // 899
    var onerror = xdr.ontimeout = xdr.onerror = function() {                                                      // 900
        that.emit('finish', 0, '');                                                                               // 901
        that._cleanup(false);                                                                                     // 902
    };                                                                                                            // 903
    xdr.onprogress = function() {                                                                                 // 904
        that.emit('chunk', 200, xdr.responseText);                                                                // 905
    };                                                                                                            // 906
    xdr.onload = function() {                                                                                     // 907
        that.emit('finish', 200, xdr.responseText);                                                               // 908
        that._cleanup(false);                                                                                     // 909
    };                                                                                                            // 910
    that.xdr = xdr;                                                                                               // 911
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});                                         // 912
    try {                                                                                                         // 913
        // Fails with AccessDenied if port number is bogus                                                        // 914
        that.xdr.open(method, url);                                                                               // 915
        that.xdr.send(payload);                                                                                   // 916
    } catch(x) {                                                                                                  // 917
        onerror();                                                                                                // 918
    }                                                                                                             // 919
};                                                                                                                // 920
                                                                                                                  // 921
XDRObject.prototype._cleanup = function(abort) {                                                                  // 922
    var that = this;                                                                                              // 923
    if (!that.xdr) return;                                                                                        // 924
    utils.unload_del(that.unload_ref);                                                                            // 925
                                                                                                                  // 926
    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =                                                 // 927
        that.xdr.onload = null;                                                                                   // 928
    if (abort) {                                                                                                  // 929
        try {                                                                                                     // 930
            that.xdr.abort();                                                                                     // 931
        } catch(x) {};                                                                                            // 932
    }                                                                                                             // 933
    that.unload_ref = that.xdr = null;                                                                            // 934
};                                                                                                                // 935
                                                                                                                  // 936
XDRObject.prototype.close = function() {                                                                          // 937
    var that = this;                                                                                              // 938
    that.nuke();                                                                                                  // 939
    that._cleanup(true);                                                                                          // 940
};                                                                                                                // 941
                                                                                                                  // 942
// 1. Is natively via XHR                                                                                         // 943
// 2. Is natively via XDR                                                                                         // 944
// 3. Nope, but postMessage is there so it should work via the Iframe.                                            // 945
// 4. Nope, sorry.                                                                                                // 946
utils.isXHRCorsCapable = function() {                                                                             // 947
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {                                    // 948
        return 1;                                                                                                 // 949
    }                                                                                                             // 950
    // XDomainRequest doesn't work if page is served from file://                                                 // 951
    if (_window.XDomainRequest && _document.domain) {                                                             // 952
        return 2;                                                                                                 // 953
    }                                                                                                             // 954
    if (IframeTransport.enabled()) {                                                                              // 955
        return 3;                                                                                                 // 956
    }                                                                                                             // 957
    return 4;                                                                                                     // 958
};                                                                                                                // 959
//         [*] End of lib/dom2.js                                                                                 // 960
                                                                                                                  // 961
                                                                                                                  // 962
//         [*] Including lib/sockjs.js                                                                            // 963
/*                                                                                                                // 964
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 965
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 966
 *                                                                                                                // 967
 * For the license see COPYING.                                                                                   // 968
 * ***** END LICENSE BLOCK *****                                                                                  // 969
 */                                                                                                               // 970
                                                                                                                  // 971
var SockJS = function(url, dep_protocols_whitelist, options) {                                                    // 972
    if (!(this instanceof SockJS)) {                                                                              // 973
        // makes `new` optional                                                                                   // 974
        return new SockJS(url, dep_protocols_whitelist, options);                                                 // 975
    }                                                                                                             // 976
                                                                                                                  // 977
    var that = this, protocols_whitelist;                                                                         // 978
    that._options = {devel: false, debug: false, protocols_whitelist: [],                                         // 979
                     info: undefined, rtt: undefined};                                                            // 980
    if (options) {                                                                                                // 981
        utils.objectExtend(that._options, options);                                                               // 982
    }                                                                                                             // 983
    that._base_url = utils.amendUrl(url);                                                                         // 984
    that._server = that._options.server || utils.random_number_string(1000);                                      // 985
    if (that._options.protocols_whitelist &&                                                                      // 986
        that._options.protocols_whitelist.length) {                                                               // 987
        protocols_whitelist = that._options.protocols_whitelist;                                                  // 988
    } else {                                                                                                      // 989
        // Deprecated API                                                                                         // 990
        if (typeof dep_protocols_whitelist === 'string' &&                                                        // 991
            dep_protocols_whitelist.length > 0) {                                                                 // 992
            protocols_whitelist = [dep_protocols_whitelist];                                                      // 993
        } else if (utils.isArray(dep_protocols_whitelist)) {                                                      // 994
            protocols_whitelist = dep_protocols_whitelist                                                         // 995
        } else {                                                                                                  // 996
            protocols_whitelist = null;                                                                           // 997
        }                                                                                                         // 998
        if (protocols_whitelist) {                                                                                // 999
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +                                     // 1000
                        'instead of supplying protocol list as a second ' +                                       // 1001
                        'parameter to SockJS constructor.');                                                      // 1002
        }                                                                                                         // 1003
    }                                                                                                             // 1004
    that._protocols = [];                                                                                         // 1005
    that.protocol = null;                                                                                         // 1006
    that.readyState = SockJS.CONNECTING;                                                                          // 1007
    that._ir = createInfoReceiver(that._base_url);                                                                // 1008
    that._ir.onfinish = function(info, rtt) {                                                                     // 1009
        that._ir = null;                                                                                          // 1010
        if (info) {                                                                                               // 1011
            if (that._options.info) {                                                                             // 1012
                // Override if user supplies the option                                                           // 1013
                info = utils.objectExtend(info, that._options.info);                                              // 1014
            }                                                                                                     // 1015
            if (that._options.rtt) {                                                                              // 1016
                rtt = that._options.rtt;                                                                          // 1017
            }                                                                                                     // 1018
            that._applyInfo(info, rtt, protocols_whitelist);                                                      // 1019
            that._didClose();                                                                                     // 1020
        } else {                                                                                                  // 1021
            that._didClose(1002, 'Can\'t connect to server', true);                                               // 1022
        }                                                                                                         // 1023
    };                                                                                                            // 1024
};                                                                                                                // 1025
// Inheritance                                                                                                    // 1026
SockJS.prototype = new REventTarget();                                                                            // 1027
                                                                                                                  // 1028
SockJS.version = "0.3.4";                                                                                         // 1029
                                                                                                                  // 1030
SockJS.CONNECTING = 0;                                                                                            // 1031
SockJS.OPEN = 1;                                                                                                  // 1032
SockJS.CLOSING = 2;                                                                                               // 1033
SockJS.CLOSED = 3;                                                                                                // 1034
                                                                                                                  // 1035
SockJS.prototype._debug = function() {                                                                            // 1036
    if (this._options.debug)                                                                                      // 1037
        utils.log.apply(utils, arguments);                                                                        // 1038
};                                                                                                                // 1039
                                                                                                                  // 1040
SockJS.prototype._dispatchOpen = function() {                                                                     // 1041
    var that = this;                                                                                              // 1042
    if (that.readyState === SockJS.CONNECTING) {                                                                  // 1043
        if (that._transport_tref) {                                                                               // 1044
            clearTimeout(that._transport_tref);                                                                   // 1045
            that._transport_tref = null;                                                                          // 1046
        }                                                                                                         // 1047
        that.readyState = SockJS.OPEN;                                                                            // 1048
        that.dispatchEvent(new SimpleEvent("open"));                                                              // 1049
    } else {                                                                                                      // 1050
        // The server might have been restarted, and lost track of our                                            // 1051
        // connection.                                                                                            // 1052
        that._didClose(1006, "Server lost session");                                                              // 1053
    }                                                                                                             // 1054
};                                                                                                                // 1055
                                                                                                                  // 1056
SockJS.prototype._dispatchMessage = function(data) {                                                              // 1057
    var that = this;                                                                                              // 1058
    if (that.readyState !== SockJS.OPEN)                                                                          // 1059
            return;                                                                                               // 1060
    that.dispatchEvent(new SimpleEvent("message", {data: data}));                                                 // 1061
};                                                                                                                // 1062
                                                                                                                  // 1063
SockJS.prototype._dispatchHeartbeat = function(data) {                                                            // 1064
    var that = this;                                                                                              // 1065
    if (that.readyState !== SockJS.OPEN)                                                                          // 1066
        return;                                                                                                   // 1067
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));                                                         // 1068
};                                                                                                                // 1069
                                                                                                                  // 1070
SockJS.prototype._didClose = function(code, reason, force) {                                                      // 1071
    var that = this;                                                                                              // 1072
    if (that.readyState !== SockJS.CONNECTING &&                                                                  // 1073
        that.readyState !== SockJS.OPEN &&                                                                        // 1074
        that.readyState !== SockJS.CLOSING)                                                                       // 1075
            throw new Error('INVALID_STATE_ERR');                                                                 // 1076
    if (that._ir) {                                                                                               // 1077
        that._ir.nuke();                                                                                          // 1078
        that._ir = null;                                                                                          // 1079
    }                                                                                                             // 1080
                                                                                                                  // 1081
    if (that._transport) {                                                                                        // 1082
        that._transport.doCleanup();                                                                              // 1083
        that._transport = null;                                                                                   // 1084
    }                                                                                                             // 1085
                                                                                                                  // 1086
    var close_event = new SimpleEvent("close", {                                                                  // 1087
        code: code,                                                                                               // 1088
        reason: reason,                                                                                           // 1089
        wasClean: utils.userSetCode(code)});                                                                      // 1090
                                                                                                                  // 1091
    if (!utils.userSetCode(code) &&                                                                               // 1092
        that.readyState === SockJS.CONNECTING && !force) {                                                        // 1093
        if (that._try_next_protocol(close_event)) {                                                               // 1094
            return;                                                                                               // 1095
        }                                                                                                         // 1096
        close_event = new SimpleEvent("close", {code: 2000,                                                       // 1097
                                                reason: "All transports failed",                                  // 1098
                                                wasClean: false,                                                  // 1099
                                                last_event: close_event});                                        // 1100
    }                                                                                                             // 1101
    that.readyState = SockJS.CLOSED;                                                                              // 1102
                                                                                                                  // 1103
    utils.delay(function() {                                                                                      // 1104
                   that.dispatchEvent(close_event);                                                               // 1105
                });                                                                                               // 1106
};                                                                                                                // 1107
                                                                                                                  // 1108
SockJS.prototype._didMessage = function(data) {                                                                   // 1109
    var that = this;                                                                                              // 1110
    var type = data.slice(0, 1);                                                                                  // 1111
    switch(type) {                                                                                                // 1112
    case 'o':                                                                                                     // 1113
        that._dispatchOpen();                                                                                     // 1114
        break;                                                                                                    // 1115
    case 'a':                                                                                                     // 1116
        var payload = JSON.parse(data.slice(1) || '[]');                                                          // 1117
        for(var i=0; i < payload.length; i++){                                                                    // 1118
            that._dispatchMessage(payload[i]);                                                                    // 1119
        }                                                                                                         // 1120
        break;                                                                                                    // 1121
    case 'm':                                                                                                     // 1122
        var payload = JSON.parse(data.slice(1) || 'null');                                                        // 1123
        that._dispatchMessage(payload);                                                                           // 1124
        break;                                                                                                    // 1125
    case 'c':                                                                                                     // 1126
        var payload = JSON.parse(data.slice(1) || '[]');                                                          // 1127
        that._didClose(payload[0], payload[1]);                                                                   // 1128
        break;                                                                                                    // 1129
    case 'h':                                                                                                     // 1130
        that._dispatchHeartbeat();                                                                                // 1131
        break;                                                                                                    // 1132
    }                                                                                                             // 1133
};                                                                                                                // 1134
                                                                                                                  // 1135
SockJS.prototype._try_next_protocol = function(close_event) {                                                     // 1136
    var that = this;                                                                                              // 1137
    if (that.protocol) {                                                                                          // 1138
        that._debug('Closed transport:', that.protocol, ''+close_event);                                          // 1139
        that.protocol = null;                                                                                     // 1140
    }                                                                                                             // 1141
    if (that._transport_tref) {                                                                                   // 1142
        clearTimeout(that._transport_tref);                                                                       // 1143
        that._transport_tref = null;                                                                              // 1144
    }                                                                                                             // 1145
                                                                                                                  // 1146
    while(1) {                                                                                                    // 1147
        var protocol = that.protocol = that._protocols.shift();                                                   // 1148
        if (!protocol) {                                                                                          // 1149
            return false;                                                                                         // 1150
        }                                                                                                         // 1151
        // Some protocols require access to `body`, what if were in                                               // 1152
        // the `head`?                                                                                            // 1153
        if (SockJS[protocol] &&                                                                                   // 1154
            SockJS[protocol].need_body === true &&                                                                // 1155
            (!_document.body ||                                                                                   // 1156
             (typeof _document.readyState !== 'undefined'                                                         // 1157
              && _document.readyState !== 'complete'))) {                                                         // 1158
            that._protocols.unshift(protocol);                                                                    // 1159
            that.protocol = 'waiting-for-load';                                                                   // 1160
            utils.attachEvent('load', function(){                                                                 // 1161
                that._try_next_protocol();                                                                        // 1162
            });                                                                                                   // 1163
            return true;                                                                                          // 1164
        }                                                                                                         // 1165
                                                                                                                  // 1166
        if (!SockJS[protocol] ||                                                                                  // 1167
              !SockJS[protocol].enabled(that._options)) {                                                         // 1168
            that._debug('Skipping transport:', protocol);                                                         // 1169
        } else {                                                                                                  // 1170
            var roundTrips = SockJS[protocol].roundTrips || 1;                                                    // 1171
            var to = ((that._options.rto || 0) * roundTrips) || 5000;                                             // 1172
            that._transport_tref = utils.delay(to, function() {                                                   // 1173
                if (that.readyState === SockJS.CONNECTING) {                                                      // 1174
                    // I can't understand how it is possible to run                                               // 1175
                    // this timer, when the state is CLOSED, but                                                  // 1176
                    // apparently in IE everythin is possible.                                                    // 1177
                    that._didClose(2007, "Transport timeouted");                                                  // 1178
                }                                                                                                 // 1179
            });                                                                                                   // 1180
                                                                                                                  // 1181
            var connid = utils.random_string(8);                                                                  // 1182
            var trans_url = that._base_url + '/' + that._server + '/' + connid;                                   // 1183
            that._debug('Opening transport:', protocol, ' url:'+trans_url,                                        // 1184
                        ' RTO:'+that._options.rto);                                                               // 1185
            that._transport = new SockJS[protocol](that, trans_url,                                               // 1186
                                                   that._base_url);                                               // 1187
            return true;                                                                                          // 1188
        }                                                                                                         // 1189
    }                                                                                                             // 1190
};                                                                                                                // 1191
                                                                                                                  // 1192
SockJS.prototype.close = function(code, reason) {                                                                 // 1193
    var that = this;                                                                                              // 1194
    if (code && !utils.userSetCode(code))                                                                         // 1195
        throw new Error("INVALID_ACCESS_ERR");                                                                    // 1196
    if(that.readyState !== SockJS.CONNECTING &&                                                                   // 1197
       that.readyState !== SockJS.OPEN) {                                                                         // 1198
        return false;                                                                                             // 1199
    }                                                                                                             // 1200
    that.readyState = SockJS.CLOSING;                                                                             // 1201
    that._didClose(code || 1000, reason || "Normal closure");                                                     // 1202
    return true;                                                                                                  // 1203
};                                                                                                                // 1204
                                                                                                                  // 1205
SockJS.prototype.send = function(data) {                                                                          // 1206
    var that = this;                                                                                              // 1207
    if (that.readyState === SockJS.CONNECTING)                                                                    // 1208
        throw new Error('INVALID_STATE_ERR');                                                                     // 1209
    if (that.readyState === SockJS.OPEN) {                                                                        // 1210
        that._transport.doSend(utils.quote('' + data));                                                           // 1211
    }                                                                                                             // 1212
    return true;                                                                                                  // 1213
};                                                                                                                // 1214
                                                                                                                  // 1215
SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {                                          // 1216
    var that = this;                                                                                              // 1217
    that._options.info = info;                                                                                    // 1218
    that._options.rtt = rtt;                                                                                      // 1219
    that._options.rto = utils.countRTO(rtt);                                                                      // 1220
    that._options.info.null_origin = !_document.domain;                                                           // 1221
    // Servers can override base_url, eg to provide a randomized domain name and                                  // 1222
    // avoid browser per-domain connection limits.                                                                // 1223
    if (info.base_url)                                                                                            // 1224
      that._base_url = info.base_url;                                                                             // 1225
    var probed = utils.probeProtocols();                                                                          // 1226
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);                                   // 1227
// <METEOR>                                                                                                       // 1228
// https://github.com/sockjs/sockjs-client/issues/79                                                              // 1229
    // Hack to avoid XDR when using different protocols                                                           // 1230
    // We're on IE trying to do cross-protocol. jsonp only.                                                       // 1231
    if (!utils.isSameOriginScheme(that._base_url) &&                                                              // 1232
        2 === utils.isXHRCorsCapable()) {                                                                         // 1233
        that._protocols = ['jsonp-polling'];                                                                      // 1234
    }                                                                                                             // 1235
// </METEOR>                                                                                                      // 1236
};                                                                                                                // 1237
//         [*] End of lib/sockjs.js                                                                               // 1238
                                                                                                                  // 1239
                                                                                                                  // 1240
//         [*] Including lib/trans-websocket.js                                                                   // 1241
/*                                                                                                                // 1242
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1243
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1244
 *                                                                                                                // 1245
 * For the license see COPYING.                                                                                   // 1246
 * ***** END LICENSE BLOCK *****                                                                                  // 1247
 */                                                                                                               // 1248
                                                                                                                  // 1249
var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {                                             // 1250
    var that = this;                                                                                              // 1251
    var url = trans_url + '/websocket';                                                                           // 1252
    if (url.slice(0, 5) === 'https') {                                                                            // 1253
        url = 'wss' + url.slice(5);                                                                               // 1254
    } else {                                                                                                      // 1255
        url = 'ws' + url.slice(4);                                                                                // 1256
    }                                                                                                             // 1257
    that.ri = ri;                                                                                                 // 1258
    that.url = url;                                                                                               // 1259
    var Constructor = _window.WebSocket || _window.MozWebSocket;                                                  // 1260
                                                                                                                  // 1261
    that.ws = new Constructor(that.url);                                                                          // 1262
    that.ws.onmessage = function(e) {                                                                             // 1263
        that.ri._didMessage(e.data);                                                                              // 1264
    };                                                                                                            // 1265
    // Firefox has an interesting bug. If a websocket connection is                                               // 1266
    // created after onunload, it stays alive even when user                                                      // 1267
    // navigates away from the page. In such situation let's lie -                                                // 1268
    // let's not open the ws connection at all. See:                                                              // 1269
    // https://github.com/sockjs/sockjs-client/issues/28                                                          // 1270
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085                                                        // 1271
    that.unload_ref = utils.unload_add(function(){that.ws.close()});                                              // 1272
    that.ws.onclose = function() {                                                                                // 1273
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));                               // 1274
    };                                                                                                            // 1275
};                                                                                                                // 1276
                                                                                                                  // 1277
WebSocketTransport.prototype.doSend = function(data) {                                                            // 1278
    this.ws.send('[' + data + ']');                                                                               // 1279
};                                                                                                                // 1280
                                                                                                                  // 1281
WebSocketTransport.prototype.doCleanup = function() {                                                             // 1282
    var that = this;                                                                                              // 1283
    var ws = that.ws;                                                                                             // 1284
    if (ws) {                                                                                                     // 1285
        ws.onmessage = ws.onclose = null;                                                                         // 1286
        ws.close();                                                                                               // 1287
        utils.unload_del(that.unload_ref);                                                                        // 1288
        that.unload_ref = that.ri = that.ws = null;                                                               // 1289
    }                                                                                                             // 1290
};                                                                                                                // 1291
                                                                                                                  // 1292
WebSocketTransport.enabled = function() {                                                                         // 1293
    return !!(_window.WebSocket || _window.MozWebSocket);                                                         // 1294
};                                                                                                                // 1295
                                                                                                                  // 1296
// In theory, ws should require 1 round trip. But in chrome, this is                                              // 1297
// not very stable over SSL. Most likely a ws connection requires a                                               // 1298
// separate SSL connection, in which case 2 round trips are an                                                    // 1299
// absolute minumum.                                                                                              // 1300
WebSocketTransport.roundTrips = 2;                                                                                // 1301
//         [*] End of lib/trans-websocket.js                                                                      // 1302
                                                                                                                  // 1303
                                                                                                                  // 1304
//         [*] Including lib/trans-sender.js                                                                      // 1305
/*                                                                                                                // 1306
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1307
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1308
 *                                                                                                                // 1309
 * For the license see COPYING.                                                                                   // 1310
 * ***** END LICENSE BLOCK *****                                                                                  // 1311
 */                                                                                                               // 1312
                                                                                                                  // 1313
var BufferedSender = function() {};                                                                               // 1314
BufferedSender.prototype.send_constructor = function(sender) {                                                    // 1315
    var that = this;                                                                                              // 1316
    that.send_buffer = [];                                                                                        // 1317
    that.sender = sender;                                                                                         // 1318
};                                                                                                                // 1319
BufferedSender.prototype.doSend = function(message) {                                                             // 1320
    var that = this;                                                                                              // 1321
    that.send_buffer.push(message);                                                                               // 1322
    if (!that.send_stop) {                                                                                        // 1323
        that.send_schedule();                                                                                     // 1324
    }                                                                                                             // 1325
};                                                                                                                // 1326
                                                                                                                  // 1327
// For polling transports in a situation when in the message callback,                                            // 1328
// new message is being send. If the sending connection was started                                               // 1329
// before receiving one, it is possible to saturate the network and                                               // 1330
// timeout due to the lack of receiving socket. To avoid that we delay                                            // 1331
// sending messages by some small time, in order to let receiving                                                 // 1332
// connection be started beforehand. This is only a halfmeasure and                                               // 1333
// does not fix the big problem, but it does make the tests go more                                               // 1334
// stable on slow networks.                                                                                       // 1335
BufferedSender.prototype.send_schedule_wait = function() {                                                        // 1336
    var that = this;                                                                                              // 1337
    var tref;                                                                                                     // 1338
    that.send_stop = function() {                                                                                 // 1339
        that.send_stop = null;                                                                                    // 1340
        clearTimeout(tref);                                                                                       // 1341
    };                                                                                                            // 1342
    tref = utils.delay(25, function() {                                                                           // 1343
        that.send_stop = null;                                                                                    // 1344
        that.send_schedule();                                                                                     // 1345
    });                                                                                                           // 1346
};                                                                                                                // 1347
                                                                                                                  // 1348
BufferedSender.prototype.send_schedule = function() {                                                             // 1349
    var that = this;                                                                                              // 1350
    if (that.send_buffer.length > 0) {                                                                            // 1351
        var payload = '[' + that.send_buffer.join(',') + ']';                                                     // 1352
        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {                   // 1353
            that.send_stop = null;                                                                                // 1354
            if (success === false) {                                                                              // 1355
                that.ri._didClose(1006, 'Sending error ' + abort_reason);                                         // 1356
            } else {                                                                                              // 1357
                that.send_schedule_wait();                                                                        // 1358
            }                                                                                                     // 1359
        });                                                                                                       // 1360
        that.send_buffer = [];                                                                                    // 1361
    }                                                                                                             // 1362
};                                                                                                                // 1363
                                                                                                                  // 1364
BufferedSender.prototype.send_destructor = function() {                                                           // 1365
    var that = this;                                                                                              // 1366
    if (that._send_stop) {                                                                                        // 1367
        that._send_stop();                                                                                        // 1368
    }                                                                                                             // 1369
    that._send_stop = null;                                                                                       // 1370
};                                                                                                                // 1371
                                                                                                                  // 1372
var jsonPGenericSender = function(url, payload, callback) {                                                       // 1373
    var that = this;                                                                                              // 1374
                                                                                                                  // 1375
    if (!('_send_form' in that)) {                                                                                // 1376
        var form = that._send_form = _document.createElement('form');                                             // 1377
        var area = that._send_area = _document.createElement('textarea');                                         // 1378
        area.name = 'd';                                                                                          // 1379
        form.style.display = 'none';                                                                              // 1380
        form.style.position = 'absolute';                                                                         // 1381
        form.method = 'POST';                                                                                     // 1382
        form.enctype = 'application/x-www-form-urlencoded';                                                       // 1383
        form.acceptCharset = "UTF-8";                                                                             // 1384
        form.appendChild(area);                                                                                   // 1385
        _document.body.appendChild(form);                                                                         // 1386
    }                                                                                                             // 1387
    var form = that._send_form;                                                                                   // 1388
    var area = that._send_area;                                                                                   // 1389
    var id = 'a' + utils.random_string(8);                                                                        // 1390
    form.target = id;                                                                                             // 1391
    form.action = url + '/jsonp_send?i=' + id;                                                                    // 1392
                                                                                                                  // 1393
    var iframe;                                                                                                   // 1394
    try {                                                                                                         // 1395
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)                                    // 1396
        iframe = _document.createElement('<iframe name="'+ id +'">');                                             // 1397
    } catch(x) {                                                                                                  // 1398
        iframe = _document.createElement('iframe');                                                               // 1399
        iframe.name = id;                                                                                         // 1400
    }                                                                                                             // 1401
    iframe.id = id;                                                                                               // 1402
    form.appendChild(iframe);                                                                                     // 1403
    iframe.style.display = 'none';                                                                                // 1404
                                                                                                                  // 1405
    try {                                                                                                         // 1406
        area.value = payload;                                                                                     // 1407
    } catch(e) {                                                                                                  // 1408
        utils.log('Your browser is seriously broken. Go home! ' + e.message);                                     // 1409
    }                                                                                                             // 1410
    form.submit();                                                                                                // 1411
                                                                                                                  // 1412
    var completed = function(e) {                                                                                 // 1413
        if (!iframe.onerror) return;                                                                              // 1414
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;                                        // 1415
        // Opera mini doesn't like if we GC iframe                                                                // 1416
        // immediately, thus this timeout.                                                                        // 1417
        utils.delay(500, function() {                                                                             // 1418
                       iframe.parentNode.removeChild(iframe);                                                     // 1419
                       iframe = null;                                                                             // 1420
                   });                                                                                            // 1421
        area.value = '';                                                                                          // 1422
        // It is not possible to detect if the iframe succeeded or                                                // 1423
        // failed to submit our form.                                                                             // 1424
        callback(true);                                                                                           // 1425
    };                                                                                                            // 1426
    iframe.onerror = iframe.onload = completed;                                                                   // 1427
    iframe.onreadystatechange = function(e) {                                                                     // 1428
        if (iframe.readyState == 'complete') completed();                                                         // 1429
    };                                                                                                            // 1430
    return completed;                                                                                             // 1431
};                                                                                                                // 1432
                                                                                                                  // 1433
var createAjaxSender = function(AjaxObject) {                                                                     // 1434
    return function(url, payload, callback) {                                                                     // 1435
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);                                              // 1436
        xo.onfinish = function(status, text) {                                                                    // 1437
            callback(status === 200 || status === 204,                                                            // 1438
                     'http status ' + status);                                                                    // 1439
        };                                                                                                        // 1440
        return function(abort_reason) {                                                                           // 1441
            callback(false, abort_reason);                                                                        // 1442
        };                                                                                                        // 1443
    };                                                                                                            // 1444
};                                                                                                                // 1445
//         [*] End of lib/trans-sender.js                                                                         // 1446
                                                                                                                  // 1447
                                                                                                                  // 1448
//         [*] Including lib/trans-jsonp-receiver.js                                                              // 1449
/*                                                                                                                // 1450
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1451
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1452
 *                                                                                                                // 1453
 * For the license see COPYING.                                                                                   // 1454
 * ***** END LICENSE BLOCK *****                                                                                  // 1455
 */                                                                                                               // 1456
                                                                                                                  // 1457
// Parts derived from Socket.io:                                                                                  // 1458
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js               // 1459
// and jQuery-JSONP:                                                                                              // 1460
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js                             // 1461
var jsonPGenericReceiver = function(url, callback) {                                                              // 1462
    var tref;                                                                                                     // 1463
    var script = _document.createElement('script');                                                               // 1464
    var script2;  // Opera synchronous load trick.                                                                // 1465
    var close_script = function(frame) {                                                                          // 1466
        if (script2) {                                                                                            // 1467
            script2.parentNode.removeChild(script2);                                                              // 1468
            script2 = null;                                                                                       // 1469
        }                                                                                                         // 1470
        if (script) {                                                                                             // 1471
            clearTimeout(tref);                                                                                   // 1472
            // Unfortunately, you can't really abort script loading of                                            // 1473
            // the script.                                                                                        // 1474
            script.parentNode.removeChild(script);                                                                // 1475
            script.onreadystatechange = script.onerror =                                                          // 1476
                script.onload = script.onclick = null;                                                            // 1477
            script = null;                                                                                        // 1478
            callback(frame);                                                                                      // 1479
            callback = null;                                                                                      // 1480
        }                                                                                                         // 1481
    };                                                                                                            // 1482
                                                                                                                  // 1483
    // IE9 fires 'error' event after orsc or before, in random order.                                             // 1484
    var loaded_okay = false;                                                                                      // 1485
    var error_timer = null;                                                                                       // 1486
                                                                                                                  // 1487
    script.id = 'a' + utils.random_string(8);                                                                     // 1488
    script.src = url;                                                                                             // 1489
    script.type = 'text/javascript';                                                                              // 1490
    script.charset = 'UTF-8';                                                                                     // 1491
    script.onerror = function(e) {                                                                                // 1492
        if (!error_timer) {                                                                                       // 1493
            // Delay firing close_script.                                                                         // 1494
            error_timer = setTimeout(function() {                                                                 // 1495
                if (!loaded_okay) {                                                                               // 1496
                    close_script(utils.closeFrame(                                                                // 1497
                        1006,                                                                                     // 1498
                        "JSONP script loaded abnormally (onerror)"));                                             // 1499
                }                                                                                                 // 1500
            }, 1000);                                                                                             // 1501
        }                                                                                                         // 1502
    };                                                                                                            // 1503
    script.onload = function(e) {                                                                                 // 1504
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));                          // 1505
    };                                                                                                            // 1506
                                                                                                                  // 1507
    script.onreadystatechange = function(e) {                                                                     // 1508
        if (/loaded|closed/.test(script.readyState)) {                                                            // 1509
            if (script && script.htmlFor && script.onclick) {                                                     // 1510
                loaded_okay = true;                                                                               // 1511
                try {                                                                                             // 1512
                    // In IE, actually execute the script.                                                        // 1513
                    script.onclick();                                                                             // 1514
                } catch (x) {}                                                                                    // 1515
            }                                                                                                     // 1516
            if (script) {                                                                                         // 1517
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));      // 1518
            }                                                                                                     // 1519
        }                                                                                                         // 1520
    };                                                                                                            // 1521
    // IE: event/htmlFor/onclick trick.                                                                           // 1522
    // One can't rely on proper order for onreadystatechange. In order to                                         // 1523
    // make sure, set a 'htmlFor' and 'event' properties, so that                                                 // 1524
    // script code will be installed as 'onclick' handler for the                                                 // 1525
    // script object. Later, onreadystatechange, manually execute this                                            // 1526
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'                                                // 1527
    // set. For reference see:                                                                                    // 1528
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html                                    // 1529
    // Also, read on that about script ordering:                                                                  // 1530
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order                                               // 1531
    if (typeof script.async === 'undefined' && _document.attachEvent) {                                           // 1532
        // According to mozilla docs, in recent browsers script.async defaults                                    // 1533
        // to 'true', so we may use it to detect a good browser:                                                  // 1534
        // https://developer.mozilla.org/en/HTML/Element/script                                                   // 1535
        if (!/opera/i.test(navigator.userAgent)) {                                                                // 1536
            // Naively assume we're in IE                                                                         // 1537
            try {                                                                                                 // 1538
                script.htmlFor = script.id;                                                                       // 1539
                script.event = "onclick";                                                                         // 1540
            } catch (x) {}                                                                                        // 1541
            script.async = true;                                                                                  // 1542
        } else {                                                                                                  // 1543
            // Opera, second sync script hack                                                                     // 1544
            script2 = _document.createElement('script');                                                          // 1545
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};"; // 1546
            script.async = script2.async = false;                                                                 // 1547
        }                                                                                                         // 1548
    }                                                                                                             // 1549
    if (typeof script.async !== 'undefined') {                                                                    // 1550
        script.async = true;                                                                                      // 1551
    }                                                                                                             // 1552
                                                                                                                  // 1553
    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.                                  // 1554
    tref = setTimeout(function() {                                                                                // 1555
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));       // 1556
                      }, 35000);                                                                                  // 1557
                                                                                                                  // 1558
    var head = _document.getElementsByTagName('head')[0];                                                         // 1559
    head.insertBefore(script, head.firstChild);                                                                   // 1560
    if (script2) {                                                                                                // 1561
        head.insertBefore(script2, head.firstChild);                                                              // 1562
    }                                                                                                             // 1563
    return close_script;                                                                                          // 1564
};                                                                                                                // 1565
//         [*] End of lib/trans-jsonp-receiver.js                                                                 // 1566
                                                                                                                  // 1567
                                                                                                                  // 1568
//         [*] Including lib/trans-jsonp-polling.js                                                               // 1569
/*                                                                                                                // 1570
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1571
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1572
 *                                                                                                                // 1573
 * For the license see COPYING.                                                                                   // 1574
 * ***** END LICENSE BLOCK *****                                                                                  // 1575
 */                                                                                                               // 1576
                                                                                                                  // 1577
// The simplest and most robust transport, using the well-know cross                                              // 1578
// domain hack - JSONP. This transport is quite inefficient - one                                                 // 1579
// mssage could use up to one http request. But at least it works almost                                          // 1580
// everywhere.                                                                                                    // 1581
// Known limitations:                                                                                             // 1582
//   o you will get a spinning cursor                                                                             // 1583
//   o for Konqueror a dumb timer is needed to detect errors                                                      // 1584
                                                                                                                  // 1585
                                                                                                                  // 1586
var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {                                          // 1587
    utils.polluteGlobalNamespace();                                                                               // 1588
    var that = this;                                                                                              // 1589
    that.ri = ri;                                                                                                 // 1590
    that.trans_url = trans_url;                                                                                   // 1591
    that.send_constructor(jsonPGenericSender);                                                                    // 1592
    that._schedule_recv();                                                                                        // 1593
};                                                                                                                // 1594
                                                                                                                  // 1595
// Inheritnace                                                                                                    // 1596
JsonPTransport.prototype = new BufferedSender();                                                                  // 1597
                                                                                                                  // 1598
JsonPTransport.prototype._schedule_recv = function() {                                                            // 1599
    var that = this;                                                                                              // 1600
    var callback = function(data) {                                                                               // 1601
        that._recv_stop = null;                                                                                   // 1602
        if (data) {                                                                                               // 1603
            // no data - heartbeat;                                                                               // 1604
            if (!that._is_closing) {                                                                              // 1605
                that.ri._didMessage(data);                                                                        // 1606
            }                                                                                                     // 1607
        }                                                                                                         // 1608
        // The message can be a close message, and change is_closing state.                                       // 1609
        if (!that._is_closing) {                                                                                  // 1610
            that._schedule_recv();                                                                                // 1611
        }                                                                                                         // 1612
    };                                                                                                            // 1613
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',                                             // 1614
                                           jsonPGenericReceiver, callback);                                       // 1615
};                                                                                                                // 1616
                                                                                                                  // 1617
JsonPTransport.enabled = function() {                                                                             // 1618
    return true;                                                                                                  // 1619
};                                                                                                                // 1620
                                                                                                                  // 1621
JsonPTransport.need_body = true;                                                                                  // 1622
                                                                                                                  // 1623
                                                                                                                  // 1624
JsonPTransport.prototype.doCleanup = function() {                                                                 // 1625
    var that = this;                                                                                              // 1626
    that._is_closing = true;                                                                                      // 1627
    if (that._recv_stop) {                                                                                        // 1628
        that._recv_stop();                                                                                        // 1629
    }                                                                                                             // 1630
    that.ri = that._recv_stop = null;                                                                             // 1631
    that.send_destructor();                                                                                       // 1632
};                                                                                                                // 1633
                                                                                                                  // 1634
                                                                                                                  // 1635
// Abstract away code that handles global namespace pollution.                                                    // 1636
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {                                      // 1637
    var id = 'a' + utils.random_string(6);                                                                        // 1638
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);                                                        // 1639
                                                                                                                  // 1640
    // Unfortunately it is not possible to abort loading of the                                                   // 1641
    // script. We need to keep track of frake close frames.                                                       // 1642
    var aborting = 0;                                                                                             // 1643
                                                                                                                  // 1644
    // Callback will be called exactly once.                                                                      // 1645
    var callback = function(frame) {                                                                              // 1646
        switch(aborting) {                                                                                        // 1647
        case 0:                                                                                                   // 1648
            // Normal behaviour - delete hook _and_ emit message.                                                 // 1649
            delete _window[WPrefix][id];                                                                          // 1650
            user_callback(frame);                                                                                 // 1651
            break;                                                                                                // 1652
        case 1:                                                                                                   // 1653
            // Fake close frame - emit but don't delete hook.                                                     // 1654
            user_callback(frame);                                                                                 // 1655
            aborting = 2;                                                                                         // 1656
            break;                                                                                                // 1657
        case 2:                                                                                                   // 1658
            // Got frame after connection was closed, delete hook, don't emit.                                    // 1659
            delete _window[WPrefix][id];                                                                          // 1660
            break;                                                                                                // 1661
        }                                                                                                         // 1662
    };                                                                                                            // 1663
                                                                                                                  // 1664
    var close_script = constructReceiver(url_id, callback);                                                       // 1665
    _window[WPrefix][id] = close_script;                                                                          // 1666
    var stop = function() {                                                                                       // 1667
        if (_window[WPrefix][id]) {                                                                               // 1668
            aborting = 1;                                                                                         // 1669
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));                              // 1670
        }                                                                                                         // 1671
    };                                                                                                            // 1672
    return stop;                                                                                                  // 1673
};                                                                                                                // 1674
//         [*] End of lib/trans-jsonp-polling.js                                                                  // 1675
                                                                                                                  // 1676
                                                                                                                  // 1677
//         [*] Including lib/trans-xhr.js                                                                         // 1678
/*                                                                                                                // 1679
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1680
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1681
 *                                                                                                                // 1682
 * For the license see COPYING.                                                                                   // 1683
 * ***** END LICENSE BLOCK *****                                                                                  // 1684
 */                                                                                                               // 1685
                                                                                                                  // 1686
var AjaxBasedTransport = function() {};                                                                           // 1687
AjaxBasedTransport.prototype = new BufferedSender();                                                              // 1688
                                                                                                                  // 1689
AjaxBasedTransport.prototype.run = function(ri, trans_url,                                                        // 1690
                                            url_suffix, Receiver, AjaxObject) {                                   // 1691
    var that = this;                                                                                              // 1692
    that.ri = ri;                                                                                                 // 1693
    that.trans_url = trans_url;                                                                                   // 1694
    that.send_constructor(createAjaxSender(AjaxObject));                                                          // 1695
    that.poll = new Polling(ri, Receiver,                                                                         // 1696
                            trans_url + url_suffix, AjaxObject);                                                  // 1697
};                                                                                                                // 1698
                                                                                                                  // 1699
AjaxBasedTransport.prototype.doCleanup = function() {                                                             // 1700
    var that = this;                                                                                              // 1701
    if (that.poll) {                                                                                              // 1702
        that.poll.abort();                                                                                        // 1703
        that.poll = null;                                                                                         // 1704
    }                                                                                                             // 1705
};                                                                                                                // 1706
                                                                                                                  // 1707
// xhr-streaming                                                                                                  // 1708
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {                                   // 1709
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);                                  // 1710
};                                                                                                                // 1711
                                                                                                                  // 1712
XhrStreamingTransport.prototype = new AjaxBasedTransport();                                                       // 1713
                                                                                                                  // 1714
XhrStreamingTransport.enabled = function() {                                                                      // 1715
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but                                                  // 1716
    // doesn't do streaming.                                                                                      // 1717
    return (_window.XMLHttpRequest &&                                                                             // 1718
            'withCredentials' in new XMLHttpRequest() &&                                                          // 1719
            (!/opera/i.test(navigator.userAgent)));                                                               // 1720
};                                                                                                                // 1721
XhrStreamingTransport.roundTrips = 2; // preflight, ajax                                                          // 1722
                                                                                                                  // 1723
// Safari gets confused when a streaming ajax request is started                                                  // 1724
// before onload. This causes the load indicator to spin indefinetely.                                            // 1725
XhrStreamingTransport.need_body = true;                                                                           // 1726
                                                                                                                  // 1727
                                                                                                                  // 1728
// According to:                                                                                                  // 1729
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests           // 1730
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/                                        // 1731
                                                                                                                  // 1732
                                                                                                                  // 1733
// xdr-streaming                                                                                                  // 1734
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {                                   // 1735
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);                                      // 1736
};                                                                                                                // 1737
                                                                                                                  // 1738
XdrStreamingTransport.prototype = new AjaxBasedTransport();                                                       // 1739
                                                                                                                  // 1740
XdrStreamingTransport.enabled = function() {                                                                      // 1741
    return !!_window.XDomainRequest;                                                                              // 1742
};                                                                                                                // 1743
XdrStreamingTransport.roundTrips = 2; // preflight, ajax                                                          // 1744
                                                                                                                  // 1745
                                                                                                                  // 1746
                                                                                                                  // 1747
// xhr-polling                                                                                                    // 1748
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {                                       // 1749
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);                                            // 1750
};                                                                                                                // 1751
                                                                                                                  // 1752
XhrPollingTransport.prototype = new AjaxBasedTransport();                                                         // 1753
                                                                                                                  // 1754
XhrPollingTransport.enabled = XhrStreamingTransport.enabled;                                                      // 1755
XhrPollingTransport.roundTrips = 2; // preflight, ajax                                                            // 1756
                                                                                                                  // 1757
                                                                                                                  // 1758
// xdr-polling                                                                                                    // 1759
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {                                       // 1760
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);                                                // 1761
};                                                                                                                // 1762
                                                                                                                  // 1763
XdrPollingTransport.prototype = new AjaxBasedTransport();                                                         // 1764
                                                                                                                  // 1765
XdrPollingTransport.enabled = XdrStreamingTransport.enabled;                                                      // 1766
XdrPollingTransport.roundTrips = 2; // preflight, ajax                                                            // 1767
//         [*] End of lib/trans-xhr.js                                                                            // 1768
                                                                                                                  // 1769
                                                                                                                  // 1770
//         [*] Including lib/trans-iframe.js                                                                      // 1771
/*                                                                                                                // 1772
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1773
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1774
 *                                                                                                                // 1775
 * For the license see COPYING.                                                                                   // 1776
 * ***** END LICENSE BLOCK *****                                                                                  // 1777
 */                                                                                                               // 1778
                                                                                                                  // 1779
// Few cool transports do work only for same-origin. In order to make                                             // 1780
// them working cross-domain we shall use iframe, served form the                                                 // 1781
// remote domain. New browsers, have capabilities to communicate with                                             // 1782
// cross domain iframe, using postMessage(). In IE it was implemented                                             // 1783
// from IE 8+, but of course, IE got some details wrong:                                                          // 1784
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx                                              // 1785
//    http://stevesouders.com/misc/test-postmessage.php                                                           // 1786
                                                                                                                  // 1787
var IframeTransport = function() {};                                                                              // 1788
                                                                                                                  // 1789
IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {                                     // 1790
    var that = this;                                                                                              // 1791
    that.ri = ri;                                                                                                 // 1792
    that.origin = utils.getOrigin(base_url);                                                                      // 1793
    that.base_url = base_url;                                                                                     // 1794
    that.trans_url = trans_url;                                                                                   // 1795
                                                                                                                  // 1796
    var iframe_url = base_url + '/iframe.html';                                                                   // 1797
    if (that.ri._options.devel) {                                                                                 // 1798
        iframe_url += '?t=' + (+new Date);                                                                        // 1799
    }                                                                                                             // 1800
    that.window_id = utils.random_string(8);                                                                      // 1801
    iframe_url += '#' + that.window_id;                                                                           // 1802
                                                                                                                  // 1803
    that.iframeObj = utils.createIframe(iframe_url, function(r) {                                                 // 1804
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");      // 1805
                                        });                                                                       // 1806
                                                                                                                  // 1807
    that.onmessage_cb = utils.bind(that.onmessage, that);                                                         // 1808
    utils.attachMessage(that.onmessage_cb);                                                                       // 1809
};                                                                                                                // 1810
                                                                                                                  // 1811
IframeTransport.prototype.doCleanup = function() {                                                                // 1812
    var that = this;                                                                                              // 1813
    if (that.iframeObj) {                                                                                         // 1814
        utils.detachMessage(that.onmessage_cb);                                                                   // 1815
        try {                                                                                                     // 1816
            // When the iframe is not loaded, IE raises an exception                                              // 1817
            // on 'contentWindow'.                                                                                // 1818
            if (that.iframeObj.iframe.contentWindow) {                                                            // 1819
                that.postMessage('c');                                                                            // 1820
            }                                                                                                     // 1821
        } catch (x) {}                                                                                            // 1822
        that.iframeObj.cleanup();                                                                                 // 1823
        that.iframeObj = null;                                                                                    // 1824
        that.onmessage_cb = that.iframeObj = null;                                                                // 1825
    }                                                                                                             // 1826
};                                                                                                                // 1827
                                                                                                                  // 1828
IframeTransport.prototype.onmessage = function(e) {                                                               // 1829
    var that = this;                                                                                              // 1830
    if (e.origin !== that.origin) return;                                                                         // 1831
    var window_id = e.data.slice(0, 8);                                                                           // 1832
    var type = e.data.slice(8, 9);                                                                                // 1833
    var data = e.data.slice(9);                                                                                   // 1834
                                                                                                                  // 1835
    if (window_id !== that.window_id) return;                                                                     // 1836
                                                                                                                  // 1837
    switch(type) {                                                                                                // 1838
    case 's':                                                                                                     // 1839
        that.iframeObj.loaded();                                                                                  // 1840
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));    // 1841
        break;                                                                                                    // 1842
    case 't':                                                                                                     // 1843
        that.ri._didMessage(data);                                                                                // 1844
        break;                                                                                                    // 1845
    }                                                                                                             // 1846
};                                                                                                                // 1847
                                                                                                                  // 1848
IframeTransport.prototype.postMessage = function(type, data) {                                                    // 1849
    var that = this;                                                                                              // 1850
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);                                       // 1851
};                                                                                                                // 1852
                                                                                                                  // 1853
IframeTransport.prototype.doSend = function (message) {                                                           // 1854
    this.postMessage('m', message);                                                                               // 1855
};                                                                                                                // 1856
                                                                                                                  // 1857
IframeTransport.enabled = function() {                                                                            // 1858
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with                                // 1859
    // huge delay, or not at all.                                                                                 // 1860
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;          // 1861
    return ((typeof _window.postMessage === 'function' ||                                                         // 1862
            typeof _window.postMessage === 'object') && (!konqueror));                                            // 1863
};                                                                                                                // 1864
//         [*] End of lib/trans-iframe.js                                                                         // 1865
                                                                                                                  // 1866
                                                                                                                  // 1867
//         [*] Including lib/trans-iframe-within.js                                                               // 1868
/*                                                                                                                // 1869
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1870
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1871
 *                                                                                                                // 1872
 * For the license see COPYING.                                                                                   // 1873
 * ***** END LICENSE BLOCK *****                                                                                  // 1874
 */                                                                                                               // 1875
                                                                                                                  // 1876
var curr_window_id;                                                                                               // 1877
                                                                                                                  // 1878
var postMessage = function (type, data) {                                                                         // 1879
    if(parent !== _window) {                                                                                      // 1880
        parent.postMessage(curr_window_id + type + (data || ''), '*');                                            // 1881
    } else {                                                                                                      // 1882
        utils.log("Can't postMessage, no parent window.", type, data);                                            // 1883
    }                                                                                                             // 1884
};                                                                                                                // 1885
                                                                                                                  // 1886
var FacadeJS = function() {};                                                                                     // 1887
FacadeJS.prototype._didClose = function (code, reason) {                                                          // 1888
    postMessage('t', utils.closeFrame(code, reason));                                                             // 1889
};                                                                                                                // 1890
FacadeJS.prototype._didMessage = function (frame) {                                                               // 1891
    postMessage('t', frame);                                                                                      // 1892
};                                                                                                                // 1893
FacadeJS.prototype._doSend = function (data) {                                                                    // 1894
    this._transport.doSend(data);                                                                                 // 1895
};                                                                                                                // 1896
FacadeJS.prototype._doCleanup = function () {                                                                     // 1897
    this._transport.doCleanup();                                                                                  // 1898
};                                                                                                                // 1899
                                                                                                                  // 1900
utils.parent_origin = undefined;                                                                                  // 1901
                                                                                                                  // 1902
SockJS.bootstrap_iframe = function() {                                                                            // 1903
    var facade;                                                                                                   // 1904
    curr_window_id = _document.location.hash.slice(1);                                                            // 1905
    var onMessage = function(e) {                                                                                 // 1906
        if(e.source !== parent) return;                                                                           // 1907
        if(typeof utils.parent_origin === 'undefined')                                                            // 1908
            utils.parent_origin = e.origin;                                                                       // 1909
        if (e.origin !== utils.parent_origin) return;                                                             // 1910
                                                                                                                  // 1911
        var window_id = e.data.slice(0, 8);                                                                       // 1912
        var type = e.data.slice(8, 9);                                                                            // 1913
        var data = e.data.slice(9);                                                                               // 1914
        if (window_id !== curr_window_id) return;                                                                 // 1915
        switch(type) {                                                                                            // 1916
        case 's':                                                                                                 // 1917
            var p = JSON.parse(data);                                                                             // 1918
            var version = p[0];                                                                                   // 1919
            var protocol = p[1];                                                                                  // 1920
            var trans_url = p[2];                                                                                 // 1921
            var base_url = p[3];                                                                                  // 1922
            if (version !== SockJS.version) {                                                                     // 1923
                utils.log("Incompatibile SockJS! Main site uses:" +                                               // 1924
                          " \"" + version + "\", the iframe:" +                                                   // 1925
                          " \"" + SockJS.version + "\".");                                                        // 1926
            }                                                                                                     // 1927
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {                                          // 1928
                utils.log("Only basic urls are supported in SockJS");                                             // 1929
                return;                                                                                           // 1930
            }                                                                                                     // 1931
                                                                                                                  // 1932
            if (!utils.isSameOriginUrl(trans_url) ||                                                              // 1933
                !utils.isSameOriginUrl(base_url)) {                                                               // 1934
                utils.log("Can't connect to different domain from within an " +                                   // 1935
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +            // 1936
                          ")");                                                                                   // 1937
                return;                                                                                           // 1938
            }                                                                                                     // 1939
            facade = new FacadeJS();                                                                              // 1940
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);                              // 1941
            break;                                                                                                // 1942
        case 'm':                                                                                                 // 1943
            facade._doSend(data);                                                                                 // 1944
            break;                                                                                                // 1945
        case 'c':                                                                                                 // 1946
            if (facade)                                                                                           // 1947
                facade._doCleanup();                                                                              // 1948
            facade = null;                                                                                        // 1949
            break;                                                                                                // 1950
        }                                                                                                         // 1951
    };                                                                                                            // 1952
                                                                                                                  // 1953
    // alert('test ticker');                                                                                      // 1954
    // facade = new FacadeJS();                                                                                   // 1955
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');   // 1956
                                                                                                                  // 1957
    utils.attachMessage(onMessage);                                                                               // 1958
                                                                                                                  // 1959
    // Start                                                                                                      // 1960
    postMessage('s');                                                                                             // 1961
};                                                                                                                // 1962
//         [*] End of lib/trans-iframe-within.js                                                                  // 1963
                                                                                                                  // 1964
                                                                                                                  // 1965
//         [*] Including lib/info.js                                                                              // 1966
/*                                                                                                                // 1967
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 1968
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 1969
 *                                                                                                                // 1970
 * For the license see COPYING.                                                                                   // 1971
 * ***** END LICENSE BLOCK *****                                                                                  // 1972
 */                                                                                                               // 1973
                                                                                                                  // 1974
var InfoReceiver = function(base_url, AjaxObject) {                                                               // 1975
    var that = this;                                                                                              // 1976
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});                                                   // 1977
};                                                                                                                // 1978
                                                                                                                  // 1979
InfoReceiver.prototype = new EventEmitter(['finish']);                                                            // 1980
                                                                                                                  // 1981
InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {                                                   // 1982
    var that = this;                                                                                              // 1983
    var t0 = (new Date()).getTime();                                                                              // 1984
                                                                                                                  // 1985
// <METEOR>                                                                                                       // 1986
  // https://github.com/sockjs/sockjs-client/pull/129                                                             // 1987
  // var xo = new AjaxObject('GET', base_url + '/info');                                                          // 1988
                                                                                                                  // 1989
    var xo = new AjaxObject(                                                                                      // 1990
      // add cachebusting parameter to url to work around a chrome bug:                                           // 1991
      // https://code.google.com/p/chromium/issues/detail?id=263981                                               // 1992
      // or misbehaving proxies.                                                                                  // 1993
      'GET', base_url + '/info?cb=' + utils.random_string(10))                                                    // 1994
// </METEOR>                                                                                                      // 1995
                                                                                                                  // 1996
    var tref = utils.delay(8000,                                                                                  // 1997
                           function(){xo.ontimeout();});                                                          // 1998
                                                                                                                  // 1999
    xo.onfinish = function(status, text) {                                                                        // 2000
        clearTimeout(tref);                                                                                       // 2001
        tref = null;                                                                                              // 2002
        if (status === 200) {                                                                                     // 2003
            var rtt = (new Date()).getTime() - t0;                                                                // 2004
            var info = JSON.parse(text);                                                                          // 2005
            if (typeof info !== 'object') info = {};                                                              // 2006
            that.emit('finish', info, rtt);                                                                       // 2007
        } else {                                                                                                  // 2008
            that.emit('finish');                                                                                  // 2009
        }                                                                                                         // 2010
    };                                                                                                            // 2011
    xo.ontimeout = function() {                                                                                   // 2012
        xo.close();                                                                                               // 2013
        that.emit('finish');                                                                                      // 2014
    };                                                                                                            // 2015
};                                                                                                                // 2016
                                                                                                                  // 2017
var InfoReceiverIframe = function(base_url) {                                                                     // 2018
    var that = this;                                                                                              // 2019
    var go = function() {                                                                                         // 2020
        var ifr = new IframeTransport();                                                                          // 2021
        ifr.protocol = 'w-iframe-info-receiver';                                                                  // 2022
        var fun = function(r) {                                                                                   // 2023
            if (typeof r === 'string' && r.substr(0,1) === 'm') {                                                 // 2024
                var d = JSON.parse(r.substr(1));                                                                  // 2025
                var info = d[0], rtt = d[1];                                                                      // 2026
                that.emit('finish', info, rtt);                                                                   // 2027
            } else {                                                                                              // 2028
                that.emit('finish');                                                                              // 2029
            }                                                                                                     // 2030
            ifr.doCleanup();                                                                                      // 2031
            ifr = null;                                                                                           // 2032
        };                                                                                                        // 2033
        var mock_ri = {                                                                                           // 2034
            _options: {},                                                                                         // 2035
            _didClose: fun,                                                                                       // 2036
            _didMessage: fun                                                                                      // 2037
        };                                                                                                        // 2038
        ifr.i_constructor(mock_ri, base_url, base_url);                                                           // 2039
    }                                                                                                             // 2040
    if(!_document.body) {                                                                                         // 2041
        utils.attachEvent('load', go);                                                                            // 2042
    } else {                                                                                                      // 2043
        go();                                                                                                     // 2044
    }                                                                                                             // 2045
};                                                                                                                // 2046
InfoReceiverIframe.prototype = new EventEmitter(['finish']);                                                      // 2047
                                                                                                                  // 2048
                                                                                                                  // 2049
var InfoReceiverFake = function() {                                                                               // 2050
    // It may not be possible to do cross domain AJAX to get the info                                             // 2051
    // data, for example for IE7. But we want to run JSONP, so let's                                              // 2052
    // fake the response, with rtt=2s (rto=6s).                                                                   // 2053
    var that = this;                                                                                              // 2054
    utils.delay(function() {                                                                                      // 2055
        that.emit('finish', {}, 2000);                                                                            // 2056
    });                                                                                                           // 2057
};                                                                                                                // 2058
InfoReceiverFake.prototype = new EventEmitter(['finish']);                                                        // 2059
                                                                                                                  // 2060
var createInfoReceiver = function(base_url) {                                                                     // 2061
    if (utils.isSameOriginUrl(base_url)) {                                                                        // 2062
        // If, for some reason, we have SockJS locally - there's no                                               // 2063
        // need to start up the complex machinery. Just use ajax.                                                 // 2064
        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2065
    }                                                                                                             // 2066
    switch (utils.isXHRCorsCapable()) {                                                                           // 2067
    case 1:                                                                                                       // 2068
        // XHRLocalObject -> no_credentials=true                                                                  // 2069
        return new InfoReceiver(base_url, utils.XHRLocalObject);                                                  // 2070
    case 2:                                                                                                       // 2071
// <METEOR>                                                                                                       // 2072
// https://github.com/sockjs/sockjs-client/issues/79                                                              // 2073
        // XDR doesn't work across different schemes                                                              // 2074
        // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
        if (utils.isSameOriginScheme(base_url))                                                                   // 2076
            return new InfoReceiver(base_url, utils.XDRObject);                                                   // 2077
        else                                                                                                      // 2078
            return new InfoReceiverFake();                                                                        // 2079
// </METEOR>                                                                                                      // 2080
    case 3:                                                                                                       // 2081
        // Opera                                                                                                  // 2082
        return new InfoReceiverIframe(base_url);                                                                  // 2083
    default:                                                                                                      // 2084
        // IE 7                                                                                                   // 2085
        return new InfoReceiverFake();                                                                            // 2086
    };                                                                                                            // 2087
};                                                                                                                // 2088
                                                                                                                  // 2089
                                                                                                                  // 2090
var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {               // 2091
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);                                                    // 2092
    ir.onfinish = function(info, rtt) {                                                                           // 2093
        ri._didMessage('m'+JSON.stringify([info, rtt]));                                                          // 2094
        ri._didClose();                                                                                           // 2095
    }                                                                                                             // 2096
};                                                                                                                // 2097
WInfoReceiverIframe.prototype.doCleanup = function() {};                                                          // 2098
//         [*] End of lib/info.js                                                                                 // 2099
                                                                                                                  // 2100
                                                                                                                  // 2101
//         [*] Including lib/trans-iframe-eventsource.js                                                          // 2102
/*                                                                                                                // 2103
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2104
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2105
 *                                                                                                                // 2106
 * For the license see COPYING.                                                                                   // 2107
 * ***** END LICENSE BLOCK *****                                                                                  // 2108
 */                                                                                                               // 2109
                                                                                                                  // 2110
var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {                                     // 2111
    var that = this;                                                                                              // 2112
    that.protocol = 'w-iframe-eventsource';                                                                       // 2113
    that.i_constructor.apply(that, arguments);                                                                    // 2114
};                                                                                                                // 2115
                                                                                                                  // 2116
EventSourceIframeTransport.prototype = new IframeTransport();                                                     // 2117
                                                                                                                  // 2118
EventSourceIframeTransport.enabled = function () {                                                                // 2119
    return ('EventSource' in _window) && IframeTransport.enabled();                                               // 2120
};                                                                                                                // 2121
                                                                                                                  // 2122
EventSourceIframeTransport.need_body = true;                                                                      // 2123
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource                                       // 2124
                                                                                                                  // 2125
                                                                                                                  // 2126
// w-iframe-eventsource                                                                                           // 2127
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {                           // 2128
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);                           // 2129
}                                                                                                                 // 2130
EventSourceTransport.prototype = new AjaxBasedTransport();                                                        // 2131
//         [*] End of lib/trans-iframe-eventsource.js                                                             // 2132
                                                                                                                  // 2133
                                                                                                                  // 2134
//         [*] Including lib/trans-iframe-xhr-polling.js                                                          // 2135
/*                                                                                                                // 2136
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2137
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2138
 *                                                                                                                // 2139
 * For the license see COPYING.                                                                                   // 2140
 * ***** END LICENSE BLOCK *****                                                                                  // 2141
 */                                                                                                               // 2142
                                                                                                                  // 2143
var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {                                      // 2144
    var that = this;                                                                                              // 2145
    that.protocol = 'w-iframe-xhr-polling';                                                                       // 2146
    that.i_constructor.apply(that, arguments);                                                                    // 2147
};                                                                                                                // 2148
                                                                                                                  // 2149
XhrPollingIframeTransport.prototype = new IframeTransport();                                                      // 2150
                                                                                                                  // 2151
XhrPollingIframeTransport.enabled = function () {                                                                 // 2152
    return _window.XMLHttpRequest && IframeTransport.enabled();                                                   // 2153
};                                                                                                                // 2154
                                                                                                                  // 2155
XhrPollingIframeTransport.need_body = true;                                                                       // 2156
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr                                                // 2157
                                                                                                                  // 2158
                                                                                                                  // 2159
// w-iframe-xhr-polling                                                                                           // 2160
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {                           // 2161
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);                                           // 2162
};                                                                                                                // 2163
                                                                                                                  // 2164
XhrPollingITransport.prototype = new AjaxBasedTransport();                                                        // 2165
//         [*] End of lib/trans-iframe-xhr-polling.js                                                             // 2166
                                                                                                                  // 2167
                                                                                                                  // 2168
//         [*] Including lib/trans-iframe-htmlfile.js                                                             // 2169
/*                                                                                                                // 2170
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2171
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2172
 *                                                                                                                // 2173
 * For the license see COPYING.                                                                                   // 2174
 * ***** END LICENSE BLOCK *****                                                                                  // 2175
 */                                                                                                               // 2176
                                                                                                                  // 2177
// This transport generally works in any browser, but will cause a                                                // 2178
// spinning cursor to appear in any browser other than IE.                                                        // 2179
// We may test this transport in all browsers - why not, but in                                                   // 2180
// production it should be only run in IE.                                                                        // 2181
                                                                                                                  // 2182
var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {                                           // 2183
    var that = this;                                                                                              // 2184
    that.protocol = 'w-iframe-htmlfile';                                                                          // 2185
    that.i_constructor.apply(that, arguments);                                                                    // 2186
};                                                                                                                // 2187
                                                                                                                  // 2188
// Inheritance.                                                                                                   // 2189
HtmlFileIframeTransport.prototype = new IframeTransport();                                                        // 2190
                                                                                                                  // 2191
HtmlFileIframeTransport.enabled = function() {                                                                    // 2192
    return IframeTransport.enabled();                                                                             // 2193
};                                                                                                                // 2194
                                                                                                                  // 2195
HtmlFileIframeTransport.need_body = true;                                                                         // 2196
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile                                             // 2197
                                                                                                                  // 2198
                                                                                                                  // 2199
// w-iframe-htmlfile                                                                                              // 2200
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {                                 // 2201
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);                                 // 2202
};                                                                                                                // 2203
HtmlFileTransport.prototype = new AjaxBasedTransport();                                                           // 2204
//         [*] End of lib/trans-iframe-htmlfile.js                                                                // 2205
                                                                                                                  // 2206
                                                                                                                  // 2207
//         [*] Including lib/trans-polling.js                                                                     // 2208
/*                                                                                                                // 2209
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2210
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2211
 *                                                                                                                // 2212
 * For the license see COPYING.                                                                                   // 2213
 * ***** END LICENSE BLOCK *****                                                                                  // 2214
 */                                                                                                               // 2215
                                                                                                                  // 2216
var Polling = function(ri, Receiver, recv_url, AjaxObject) {                                                      // 2217
    var that = this;                                                                                              // 2218
    that.ri = ri;                                                                                                 // 2219
    that.Receiver = Receiver;                                                                                     // 2220
    that.recv_url = recv_url;                                                                                     // 2221
    that.AjaxObject = AjaxObject;                                                                                 // 2222
    that._scheduleRecv();                                                                                         // 2223
};                                                                                                                // 2224
                                                                                                                  // 2225
Polling.prototype._scheduleRecv = function() {                                                                    // 2226
    var that = this;                                                                                              // 2227
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);                                     // 2228
    var msg_counter = 0;                                                                                          // 2229
    poll.onmessage = function(e) {                                                                                // 2230
        msg_counter += 1;                                                                                         // 2231
        that.ri._didMessage(e.data);                                                                              // 2232
    };                                                                                                            // 2233
    poll.onclose = function(e) {                                                                                  // 2234
        that.poll = poll = poll.onmessage = poll.onclose = null;                                                  // 2235
        if (!that.poll_is_closing) {                                                                              // 2236
            if (e.reason === 'permanent') {                                                                       // 2237
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');                                      // 2238
            } else {                                                                                              // 2239
                that._scheduleRecv();                                                                             // 2240
            }                                                                                                     // 2241
        }                                                                                                         // 2242
    };                                                                                                            // 2243
};                                                                                                                // 2244
                                                                                                                  // 2245
Polling.prototype.abort = function() {                                                                            // 2246
    var that = this;                                                                                              // 2247
    that.poll_is_closing = true;                                                                                  // 2248
    if (that.poll) {                                                                                              // 2249
        that.poll.abort();                                                                                        // 2250
    }                                                                                                             // 2251
};                                                                                                                // 2252
//         [*] End of lib/trans-polling.js                                                                        // 2253
                                                                                                                  // 2254
                                                                                                                  // 2255
//         [*] Including lib/trans-receiver-eventsource.js                                                        // 2256
/*                                                                                                                // 2257
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2258
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2259
 *                                                                                                                // 2260
 * For the license see COPYING.                                                                                   // 2261
 * ***** END LICENSE BLOCK *****                                                                                  // 2262
 */                                                                                                               // 2263
                                                                                                                  // 2264
var EventSourceReceiver = function(url) {                                                                         // 2265
    var that = this;                                                                                              // 2266
    var es = new EventSource(url);                                                                                // 2267
    es.onmessage = function(e) {                                                                                  // 2268
        that.dispatchEvent(new SimpleEvent('message',                                                             // 2269
                                           {'data': unescape(e.data)}));                                          // 2270
    };                                                                                                            // 2271
    that.es_close = es.onerror = function(e, abort_reason) {                                                      // 2272
        // ES on reconnection has readyState = 0 or 1.                                                            // 2273
        // on network error it's CLOSED = 2                                                                       // 2274
        var reason = abort_reason ? 'user' :                                                                      // 2275
            (es.readyState !== 2 ? 'network' : 'permanent');                                                      // 2276
        that.es_close = es.onmessage = es.onerror = null;                                                         // 2277
        // EventSource reconnects automatically.                                                                  // 2278
        es.close();                                                                                               // 2279
        es = null;                                                                                                // 2280
        // Safari and chrome < 15 crash if we close window before                                                 // 2281
        // waiting for ES cleanup. See:                                                                           // 2282
        //   https://code.google.com/p/chromium/issues/detail?id=89155                                            // 2283
        utils.delay(200, function() {                                                                             // 2284
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                           // 2285
                    });                                                                                           // 2286
    };                                                                                                            // 2287
};                                                                                                                // 2288
                                                                                                                  // 2289
EventSourceReceiver.prototype = new REventTarget();                                                               // 2290
                                                                                                                  // 2291
EventSourceReceiver.prototype.abort = function() {                                                                // 2292
    var that = this;                                                                                              // 2293
    if (that.es_close) {                                                                                          // 2294
        that.es_close({}, true);                                                                                  // 2295
    }                                                                                                             // 2296
};                                                                                                                // 2297
//         [*] End of lib/trans-receiver-eventsource.js                                                           // 2298
                                                                                                                  // 2299
                                                                                                                  // 2300
//         [*] Including lib/trans-receiver-htmlfile.js                                                           // 2301
/*                                                                                                                // 2302
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2303
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2304
 *                                                                                                                // 2305
 * For the license see COPYING.                                                                                   // 2306
 * ***** END LICENSE BLOCK *****                                                                                  // 2307
 */                                                                                                               // 2308
                                                                                                                  // 2309
var _is_ie_htmlfile_capable;                                                                                      // 2310
var isIeHtmlfileCapable = function() {                                                                            // 2311
    if (_is_ie_htmlfile_capable === undefined) {                                                                  // 2312
        if ('ActiveXObject' in _window) {                                                                         // 2313
            try {                                                                                                 // 2314
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');                                        // 2315
            } catch (x) {}                                                                                        // 2316
        } else {                                                                                                  // 2317
            _is_ie_htmlfile_capable = false;                                                                      // 2318
        }                                                                                                         // 2319
    }                                                                                                             // 2320
    return _is_ie_htmlfile_capable;                                                                               // 2321
};                                                                                                                // 2322
                                                                                                                  // 2323
                                                                                                                  // 2324
var HtmlfileReceiver = function(url) {                                                                            // 2325
    var that = this;                                                                                              // 2326
    utils.polluteGlobalNamespace();                                                                               // 2327
                                                                                                                  // 2328
    that.id = 'a' + utils.random_string(6, 26);                                                                   // 2329
    url += ((url.indexOf('?') === -1) ? '?' : '&') +                                                              // 2330
        'c=' + escape(WPrefix + '.' + that.id);                                                                   // 2331
                                                                                                                  // 2332
    var constructor = isIeHtmlfileCapable() ?                                                                     // 2333
        utils.createHtmlfile : utils.createIframe;                                                                // 2334
                                                                                                                  // 2335
    var iframeObj;                                                                                                // 2336
    _window[WPrefix][that.id] = {                                                                                 // 2337
        start: function () {                                                                                      // 2338
            iframeObj.loaded();                                                                                   // 2339
        },                                                                                                        // 2340
        message: function (data) {                                                                                // 2341
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));                                       // 2342
        },                                                                                                        // 2343
        stop: function () {                                                                                       // 2344
            that.iframe_close({}, 'network');                                                                     // 2345
        }                                                                                                         // 2346
    };                                                                                                            // 2347
    that.iframe_close = function(e, abort_reason) {                                                               // 2348
        iframeObj.cleanup();                                                                                      // 2349
        that.iframe_close = iframeObj = null;                                                                     // 2350
        delete _window[WPrefix][that.id];                                                                         // 2351
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));                                     // 2352
    };                                                                                                            // 2353
    iframeObj = constructor(url, function(e) {                                                                    // 2354
                                that.iframe_close({}, 'permanent');                                               // 2355
                            });                                                                                   // 2356
};                                                                                                                // 2357
                                                                                                                  // 2358
HtmlfileReceiver.prototype = new REventTarget();                                                                  // 2359
                                                                                                                  // 2360
HtmlfileReceiver.prototype.abort = function() {                                                                   // 2361
    var that = this;                                                                                              // 2362
    if (that.iframe_close) {                                                                                      // 2363
        that.iframe_close({}, 'user');                                                                            // 2364
    }                                                                                                             // 2365
};                                                                                                                // 2366
//         [*] End of lib/trans-receiver-htmlfile.js                                                              // 2367
                                                                                                                  // 2368
                                                                                                                  // 2369
//         [*] Including lib/trans-receiver-xhr.js                                                                // 2370
/*                                                                                                                // 2371
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2372
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2373
 *                                                                                                                // 2374
 * For the license see COPYING.                                                                                   // 2375
 * ***** END LICENSE BLOCK *****                                                                                  // 2376
 */                                                                                                               // 2377
                                                                                                                  // 2378
var XhrReceiver = function(url, AjaxObject) {                                                                     // 2379
    var that = this;                                                                                              // 2380
    var buf_pos = 0;                                                                                              // 2381
                                                                                                                  // 2382
    that.xo = new AjaxObject('POST', url, null);                                                                  // 2383
    that.xo.onchunk = function(status, text) {                                                                    // 2384
        if (status !== 200) return;                                                                               // 2385
        while (1) {                                                                                               // 2386
            var buf = text.slice(buf_pos);                                                                        // 2387
            var p = buf.indexOf('\n');                                                                            // 2388
            if (p === -1) break;                                                                                  // 2389
            buf_pos += p+1;                                                                                       // 2390
            var msg = buf.slice(0, p);                                                                            // 2391
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));                                          // 2392
        }                                                                                                         // 2393
    };                                                                                                            // 2394
    that.xo.onfinish = function(status, text) {                                                                   // 2395
        that.xo.onchunk(status, text);                                                                            // 2396
        that.xo = null;                                                                                           // 2397
        var reason = status === 200 ? 'network' : 'permanent';                                                    // 2398
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));                                           // 2399
    }                                                                                                             // 2400
};                                                                                                                // 2401
                                                                                                                  // 2402
XhrReceiver.prototype = new REventTarget();                                                                       // 2403
                                                                                                                  // 2404
XhrReceiver.prototype.abort = function() {                                                                        // 2405
    var that = this;                                                                                              // 2406
    if (that.xo) {                                                                                                // 2407
        that.xo.close();                                                                                          // 2408
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));                                           // 2409
        that.xo = null;                                                                                           // 2410
    }                                                                                                             // 2411
};                                                                                                                // 2412
//         [*] End of lib/trans-receiver-xhr.js                                                                   // 2413
                                                                                                                  // 2414
                                                                                                                  // 2415
//         [*] Including lib/test-hooks.js                                                                        // 2416
/*                                                                                                                // 2417
 * ***** BEGIN LICENSE BLOCK *****                                                                                // 2418
 * Copyright (c) 2011-2012 VMware, Inc.                                                                           // 2419
 *                                                                                                                // 2420
 * For the license see COPYING.                                                                                   // 2421
 * ***** END LICENSE BLOCK *****                                                                                  // 2422
 */                                                                                                               // 2423
                                                                                                                  // 2424
// For testing                                                                                                    // 2425
SockJS.getUtils = function(){                                                                                     // 2426
    return utils;                                                                                                 // 2427
};                                                                                                                // 2428
                                                                                                                  // 2429
SockJS.getIframeTransport = function(){                                                                           // 2430
    return IframeTransport;                                                                                       // 2431
};                                                                                                                // 2432
//         [*] End of lib/test-hooks.js                                                                           // 2433
                                                                                                                  // 2434
                  return SockJS;                                                                                  // 2435
          })();                                                                                                   // 2436
                                                                                                                  // 2437
// AMD compliance                                                                                                 // 2438
if (typeof define === 'function' && define.amd) {                                                                 // 2439
    define('sockjs', [], function(){return SockJS;});                                                             // 2440
}                                                                                                                 // 2441
//     [*] End of lib/index.js                                                                                    // 2442
                                                                                                                  // 2443
// [*] End of lib/all.js                                                                                          // 2444
                                                                                                                  // 2445
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/stream_client_sockjs.js                                                                      //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// @param url {String} URL to Meteor app                                                                          // 1
//   "http://subdomain.meteor.com/" or "/" or                                                                     // 2
//   "ddp+sockjs://foo-**.meteor.com/sockjs"                                                                      // 3
LivedataTest.ClientStream = function (url) {                                                                      // 4
  var self = this;                                                                                                // 5
  self._initCommon();                                                                                             // 6
                                                                                                                  // 7
  //// Constants                                                                                                  // 8
                                                                                                                  // 9
                                                                                                                  // 10
  // how long between hearing heartbeat from the server until we declare                                          // 11
  // the connection dead. heartbeats come every 25s (stream_server.js)                                            // 12
  //                                                                                                              // 13
  // NOTE: this is a workaround until sockjs detects heartbeats on the                                            // 14
  // client automatically.                                                                                        // 15
  // https://github.com/sockjs/sockjs-client/issues/67                                                            // 16
  // https://github.com/sockjs/sockjs-node/issues/68                                                              // 17
  self.HEARTBEAT_TIMEOUT = 60000;                                                                                 // 18
                                                                                                                  // 19
  self.rawUrl = url;                                                                                              // 20
  self.socket = null;                                                                                             // 21
                                                                                                                  // 22
  self.sent_update_available = false;                                                                             // 23
                                                                                                                  // 24
  self.heartbeatTimer = null;                                                                                     // 25
                                                                                                                  // 26
  // Listen to global 'online' event if we are running in a browser.                                              // 27
  // (IE8 does not support addEventListener)                                                                      // 28
  if (typeof window !== 'undefined' && window.addEventListener)                                                   // 29
    window.addEventListener("online", _.bind(self._online, self),                                                 // 30
                            false /* useCapture. make FF3.6 happy. */);                                           // 31
                                                                                                                  // 32
  //// Kickoff!                                                                                                   // 33
  self._launchConnection();                                                                                       // 34
};                                                                                                                // 35
                                                                                                                  // 36
_.extend(LivedataTest.ClientStream.prototype, {                                                                   // 37
                                                                                                                  // 38
  // data is a utf8 string. Data sent while not connected is dropped on                                           // 39
  // the floor, and it is up the user of this API to retransmit lost                                              // 40
  // messages on 'reset'                                                                                          // 41
  send: function (data) {                                                                                         // 42
    var self = this;                                                                                              // 43
    if (self.currentStatus.connected) {                                                                           // 44
      self.socket.send(data);                                                                                     // 45
    }                                                                                                             // 46
  },                                                                                                              // 47
                                                                                                                  // 48
  // Changes where this connection points                                                                         // 49
  _changeUrl: function (url) {                                                                                    // 50
    var self = this;                                                                                              // 51
    self.rawUrl = url;                                                                                            // 52
  },                                                                                                              // 53
                                                                                                                  // 54
  _connected: function (welcome_message) {                                                                        // 55
    var self = this;                                                                                              // 56
                                                                                                                  // 57
    if (self.connectionTimer) {                                                                                   // 58
      clearTimeout(self.connectionTimer);                                                                         // 59
      self.connectionTimer = null;                                                                                // 60
    }                                                                                                             // 61
                                                                                                                  // 62
    if (self.currentStatus.connected) {                                                                           // 63
      // already connected. do nothing. this probably shouldn't happen.                                           // 64
      return;                                                                                                     // 65
    }                                                                                                             // 66
                                                                                                                  // 67
    // inspect the welcome data and decide if we have to reload                                                   // 68
    try {                                                                                                         // 69
      var welcome_data = JSON.parse(welcome_message);                                                             // 70
    } catch (err) {                                                                                               // 71
      Meteor._debug("DEBUG: malformed welcome packet", welcome_message);                                          // 72
    }                                                                                                             // 73
                                                                                                                  // 74
    if (welcome_data && welcome_data.server_id) {                                                                 // 75
      if (__meteor_runtime_config__.serverId &&                                                                   // 76
          __meteor_runtime_config__.serverId !== welcome_data.server_id &&                                        // 77
          !self.sent_update_available) {                                                                          // 78
        self.sent_update_available = true;                                                                        // 79
        _.each(self.eventCallbacks.update_available,                                                              // 80
               function (callback) { callback(); });                                                              // 81
      }                                                                                                           // 82
    } else                                                                                                        // 83
      Meteor._debug("DEBUG: invalid welcome packet", welcome_data);                                               // 84
                                                                                                                  // 85
    // update status                                                                                              // 86
    self.currentStatus.status = "connected";                                                                      // 87
    self.currentStatus.connected = true;                                                                          // 88
    self.currentStatus.retryCount = 0;                                                                            // 89
    self.statusChanged();                                                                                         // 90
                                                                                                                  // 91
    // fire resets. This must come after status change so that clients                                            // 92
    // can call send from within a reset callback.                                                                // 93
    _.each(self.eventCallbacks.reset, function (callback) { callback(); });                                       // 94
                                                                                                                  // 95
  },                                                                                                              // 96
                                                                                                                  // 97
  _cleanup: function () {                                                                                         // 98
    var self = this;                                                                                              // 99
                                                                                                                  // 100
    self._clearConnectionAndHeartbeatTimers();                                                                    // 101
    if (self.socket) {                                                                                            // 102
      self.socket.onmessage = self.socket.onclose                                                                 // 103
        = self.socket.onerror = self.socket.onheartbeat = function () {};                                         // 104
      self.socket.close();                                                                                        // 105
      self.socket = null;                                                                                         // 106
    }                                                                                                             // 107
  },                                                                                                              // 108
                                                                                                                  // 109
  _clearConnectionAndHeartbeatTimers: function () {                                                               // 110
    var self = this;                                                                                              // 111
    if (self.connectionTimer) {                                                                                   // 112
      clearTimeout(self.connectionTimer);                                                                         // 113
      self.connectionTimer = null;                                                                                // 114
    }                                                                                                             // 115
    if (self.heartbeatTimer) {                                                                                    // 116
      clearTimeout(self.heartbeatTimer);                                                                          // 117
      self.heartbeatTimer = null;                                                                                 // 118
    }                                                                                                             // 119
  },                                                                                                              // 120
                                                                                                                  // 121
  _heartbeat_timeout: function () {                                                                               // 122
    var self = this;                                                                                              // 123
    Meteor._debug("Connection timeout. No heartbeat received.");                                                  // 124
    self._lostConnection();                                                                                       // 125
  },                                                                                                              // 126
                                                                                                                  // 127
  _heartbeat_received: function () {                                                                              // 128
    var self = this;                                                                                              // 129
    // If we've already permanently shut down this stream, the timeout is                                         // 130
    // already cleared, and we don't need to set it again.                                                        // 131
    if (self._forcedToDisconnect)                                                                                 // 132
      return;                                                                                                     // 133
    if (self.heartbeatTimer)                                                                                      // 134
      clearTimeout(self.heartbeatTimer);                                                                          // 135
    self.heartbeatTimer = setTimeout(                                                                             // 136
      _.bind(self._heartbeat_timeout, self),                                                                      // 137
      self.HEARTBEAT_TIMEOUT);                                                                                    // 138
  },                                                                                                              // 139
                                                                                                                  // 140
  _sockjsProtocolsWhitelist: function () {                                                                        // 141
    // only allow polling protocols. no streaming.  streaming                                                     // 142
    // makes safari spin.                                                                                         // 143
    var protocolsWhitelist = [                                                                                    // 144
      'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'];                                       // 145
                                                                                                                  // 146
    // iOS 4 and 5 and below crash when using websockets over certain                                             // 147
    // proxies. this seems to be resolved with iOS 6. eg                                                          // 148
    // https://github.com/LearnBoost/socket.io/issues/193#issuecomment-7308865.                                   // 149
    //                                                                                                            // 150
    // iOS <4 doesn't support websockets at all so sockjs will just                                               // 151
    // immediately fall back to http                                                                              // 152
    var noWebsockets = navigator &&                                                                               // 153
          /iPhone|iPad|iPod/.test(navigator.userAgent) &&                                                         // 154
          /OS 4_|OS 5_/.test(navigator.userAgent);                                                                // 155
                                                                                                                  // 156
    if (!noWebsockets)                                                                                            // 157
      protocolsWhitelist = ['websocket'].concat(protocolsWhitelist);                                              // 158
                                                                                                                  // 159
    return protocolsWhitelist;                                                                                    // 160
  },                                                                                                              // 161
                                                                                                                  // 162
  _launchConnection: function () {                                                                                // 163
    var self = this;                                                                                              // 164
    self._cleanup(); // cleanup the old socket, if there was one.                                                 // 165
                                                                                                                  // 166
    // Convert raw URL to SockJS URL each time we open a connection, so that we                                   // 167
    // can connect to random hostnames and get around browser per-host                                            // 168
    // connection limits.                                                                                         // 169
    self.socket = new SockJS(                                                                                     // 170
      toSockjsUrl(self.rawUrl), undefined, {                                                                      // 171
        debug: false, protocols_whitelist: self._sockjsProtocolsWhitelist()                                       // 172
      });                                                                                                         // 173
    self.socket.onmessage = function (data) {                                                                     // 174
      self._heartbeat_received();                                                                                 // 175
                                                                                                                  // 176
      // first message we get when we're connecting goes to _connected,                                           // 177
      // which connects us. All subsequent messages (while connected) go to                                       // 178
      // the callback.                                                                                            // 179
      if (self.currentStatus.status === "connecting")                                                             // 180
        self._connected(data.data);                                                                               // 181
      else if (self.currentStatus.connected)                                                                      // 182
        _.each(self.eventCallbacks.message, function (callback) {                                                 // 183
          callback(data.data);                                                                                    // 184
        });                                                                                                       // 185
    };                                                                                                            // 186
    self.socket.onclose = function () {                                                                           // 187
      // Meteor._debug("stream disconnect", _.toArray(arguments), (new Date()).toDateString());                   // 188
      self._lostConnection();                                                                                     // 189
    };                                                                                                            // 190
    self.socket.onerror = function () {                                                                           // 191
      // XXX is this ever called?                                                                                 // 192
      Meteor._debug("stream error", _.toArray(arguments), (new Date()).toDateString());                           // 193
    };                                                                                                            // 194
                                                                                                                  // 195
    self.socket.onheartbeat =  function () {                                                                      // 196
      self._heartbeat_received();                                                                                 // 197
    };                                                                                                            // 198
                                                                                                                  // 199
    if (self.connectionTimer)                                                                                     // 200
      clearTimeout(self.connectionTimer);                                                                         // 201
    self.connectionTimer = setTimeout(                                                                            // 202
      _.bind(self._lostConnection, self),                                                                         // 203
      self.CONNECT_TIMEOUT);                                                                                      // 204
  }                                                                                                               // 205
});                                                                                                               // 206
                                                                                                                  // 207
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/stream_client_common.js                                                                      //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                        // 1
var startsWith = function(str, starts) {                                                                          // 2
  return str.length >= starts.length &&                                                                           // 3
    str.substring(0, starts.length) === starts;                                                                   // 4
};                                                                                                                // 5
var endsWith = function(str, ends) {                                                                              // 6
  return str.length >= ends.length &&                                                                             // 7
    str.substring(str.length - ends.length) === ends;                                                             // 8
};                                                                                                                // 9
                                                                                                                  // 10
// @param url {String} URL to Meteor app, eg:                                                                     // 11
//   "/" or "madewith.meteor.com" or "https://foo.meteor.com"                                                     // 12
//   or "ddp+sockjs://ddp--****-foo.meteor.com/sockjs"                                                            // 13
// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                               // 14
// for scheme "http" and subPath "sockjs"                                                                         // 15
//   "http://subdomain.meteor.com/sockjs" or "/sockjs"                                                            // 16
//   or "https://ddp--1234-foo.meteor.com/sockjs"                                                                 // 17
var translateUrl =  function(url, newSchemeBase, subPath) {                                                       // 18
  if (! newSchemeBase) {                                                                                          // 19
    newSchemeBase = "http";                                                                                       // 20
  }                                                                                                               // 21
                                                                                                                  // 22
  var ddpUrlMatch = url.match(/^ddp(i?)\+sockjs:\/\//);                                                           // 23
  var httpUrlMatch = url.match(/^http(s?):\/\//);                                                                 // 24
  var newScheme;                                                                                                  // 25
  if (ddpUrlMatch) {                                                                                              // 26
    // Remove scheme and split off the host.                                                                      // 27
    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                          // 28
    newScheme = ddpUrlMatch[1] === "i" ? newSchemeBase : newSchemeBase + "s";                                     // 29
    var slashPos = urlAfterDDP.indexOf('/');                                                                      // 30
    var host =                                                                                                    // 31
          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                        // 32
    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);                                               // 33
                                                                                                                  // 34
    // In the host (ONLY!), change '*' characters into random digits. This                                        // 35
    // allows different stream connections to connect to different hostnames                                      // 36
    // and avoid browser per-hostname connection limits.                                                          // 37
    host = host.replace(/\*/g, function () {                                                                      // 38
      return Math.floor(Random.fraction()*10);                                                                    // 39
    });                                                                                                           // 40
                                                                                                                  // 41
    return newScheme + '://' + host + rest;                                                                       // 42
  } else if (httpUrlMatch) {                                                                                      // 43
    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + "s";                                           // 44
    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                        // 45
    url = newScheme + "://" + urlAfterHttp;                                                                       // 46
  }                                                                                                               // 47
                                                                                                                  // 48
  // Prefix FQDNs but not relative URLs                                                                           // 49
  if (url.indexOf("://") === -1 && !startsWith(url, "/")) {                                                       // 50
    url = newSchemeBase + "://" + url;                                                                            // 51
  }                                                                                                               // 52
                                                                                                                  // 53
  url = Meteor._relativeToSiteRootUrl(url);                                                                       // 54
                                                                                                                  // 55
  if (endsWith(url, "/"))                                                                                         // 56
    return url + subPath;                                                                                         // 57
  else                                                                                                            // 58
    return url + "/" + subPath;                                                                                   // 59
};                                                                                                                // 60
                                                                                                                  // 61
toSockjsUrl = function (url) {                                                                                    // 62
  return translateUrl(url, "http", "sockjs");                                                                     // 63
};                                                                                                                // 64
                                                                                                                  // 65
toWebsocketUrl = function (url) {                                                                                 // 66
  var ret = translateUrl(url, "ws", "websocket");                                                                 // 67
  return ret;                                                                                                     // 68
};                                                                                                                // 69
                                                                                                                  // 70
LivedataTest.toSockjsUrl = toSockjsUrl;                                                                           // 71
                                                                                                                  // 72
                                                                                                                  // 73
_.extend(LivedataTest.ClientStream.prototype, {                                                                   // 74
                                                                                                                  // 75
  // Register for callbacks.                                                                                      // 76
  on: function (name, callback) {                                                                                 // 77
    var self = this;                                                                                              // 78
                                                                                                                  // 79
    if (name !== 'message' && name !== 'reset' && name !== 'update_available')                                    // 80
      throw new Error("unknown event type: " + name);                                                             // 81
                                                                                                                  // 82
    if (!self.eventCallbacks[name])                                                                               // 83
      self.eventCallbacks[name] = [];                                                                             // 84
    self.eventCallbacks[name].push(callback);                                                                     // 85
  },                                                                                                              // 86
                                                                                                                  // 87
                                                                                                                  // 88
  _initCommon: function () {                                                                                      // 89
    var self = this;                                                                                              // 90
    //// Constants                                                                                                // 91
                                                                                                                  // 92
    // how long to wait until we declare the connection attempt                                                   // 93
    // failed.                                                                                                    // 94
    self.CONNECT_TIMEOUT = 10000;                                                                                 // 95
                                                                                                                  // 96
                                                                                                                  // 97
    // time for initial reconnect attempt.                                                                        // 98
    self.RETRY_BASE_TIMEOUT = 1000;                                                                               // 99
    // exponential factor to increase timeout each attempt.                                                       // 100
    self.RETRY_EXPONENT = 2.2;                                                                                    // 101
    // maximum time between reconnects. keep this intentionally                                                   // 102
    // high-ish to ensure a server can recover from a failure caused                                              // 103
    // by load                                                                                                    // 104
    self.RETRY_MAX_TIMEOUT = 5 * 60000; // 5 minutes                                                              // 105
    // time to wait for the first 2 retries.  this helps page reload                                              // 106
    // speed during dev mode restarts, but doesn't hurt prod too                                                  // 107
    // much (due to CONNECT_TIMEOUT)                                                                              // 108
    self.RETRY_MIN_TIMEOUT = 10;                                                                                  // 109
    // how many times to try to reconnect 'instantly'                                                             // 110
    self.RETRY_MIN_COUNT = 2;                                                                                     // 111
    // fuzz factor to randomize reconnect times by. avoid reconnect                                               // 112
    // storms.                                                                                                    // 113
    self.RETRY_FUZZ = 0.5; // +- 25%                                                                              // 114
                                                                                                                  // 115
                                                                                                                  // 116
                                                                                                                  // 117
    self.eventCallbacks = {}; // name -> [callback]                                                               // 118
                                                                                                                  // 119
    self._forcedToDisconnect = false;                                                                             // 120
                                                                                                                  // 121
    //// Reactive status                                                                                          // 122
    self.currentStatus = {                                                                                        // 123
      status: "connecting",                                                                                       // 124
      connected: false,                                                                                           // 125
      retryCount: 0                                                                                               // 126
    };                                                                                                            // 127
                                                                                                                  // 128
                                                                                                                  // 129
    self.statusListeners = typeof Deps !== 'undefined' && new Deps.Dependency;                                    // 130
    self.statusChanged = function () {                                                                            // 131
      if (self.statusListeners)                                                                                   // 132
        self.statusListeners.changed();                                                                           // 133
    };                                                                                                            // 134
                                                                                                                  // 135
    //// Retry logic                                                                                              // 136
    self.retryTimer = null;                                                                                       // 137
    self.connectionTimer = null;                                                                                  // 138
                                                                                                                  // 139
  },                                                                                                              // 140
                                                                                                                  // 141
  // Trigger a reconnect.                                                                                         // 142
  reconnect: function (options) {                                                                                 // 143
    var self = this;                                                                                              // 144
    options = options || {};                                                                                      // 145
                                                                                                                  // 146
    if (options.url) {                                                                                            // 147
      self._changeUrl(options.url);                                                                               // 148
    }                                                                                                             // 149
                                                                                                                  // 150
    if (self.currentStatus.connected) {                                                                           // 151
      if (options._force || options.url) {                                                                        // 152
        // force reconnect.                                                                                       // 153
        self._lostConnection();                                                                                   // 154
      } // else, noop.                                                                                            // 155
      return;                                                                                                     // 156
    }                                                                                                             // 157
                                                                                                                  // 158
    // if we're mid-connection, stop it.                                                                          // 159
    if (self.currentStatus.status === "connecting") {                                                             // 160
      self._lostConnection();                                                                                     // 161
    }                                                                                                             // 162
                                                                                                                  // 163
    if (self.retryTimer)                                                                                          // 164
      clearTimeout(self.retryTimer);                                                                              // 165
    self.retryTimer = null;                                                                                       // 166
    self.currentStatus.retryCount -= 1; // don't count manual retries                                             // 167
    self._retryNow();                                                                                             // 168
  },                                                                                                              // 169
                                                                                                                  // 170
  disconnect: function (options) {                                                                                // 171
    var self = this;                                                                                              // 172
    options = options || {};                                                                                      // 173
                                                                                                                  // 174
    // Failed is permanent. If we're failed, don't let people go back                                             // 175
    // online by calling 'disconnect' then 'reconnect'.                                                           // 176
    if (self._forcedToDisconnect)                                                                                 // 177
      return;                                                                                                     // 178
                                                                                                                  // 179
    // If _permanent is set, permanently disconnect a stream. Once a stream                                       // 180
    // is forced to disconnect, it can never reconnect. This is for                                               // 181
    // error cases such as ddp version mismatch, where trying again                                               // 182
    // won't fix the problem.                                                                                     // 183
    if (options._permanent) {                                                                                     // 184
      self._forcedToDisconnect = true;                                                                            // 185
    }                                                                                                             // 186
                                                                                                                  // 187
    self._cleanup();                                                                                              // 188
    if (self.retryTimer) {                                                                                        // 189
      clearTimeout(self.retryTimer);                                                                              // 190
      self.retryTimer = null;                                                                                     // 191
    }                                                                                                             // 192
                                                                                                                  // 193
    self.currentStatus = {                                                                                        // 194
      status: (options._permanent ? "failed" : "offline"),                                                        // 195
      connected: false,                                                                                           // 196
      retryCount: 0                                                                                               // 197
    };                                                                                                            // 198
                                                                                                                  // 199
    if (options._permanent && options._error)                                                                     // 200
      self.currentStatus.reason = options._error;                                                                 // 201
                                                                                                                  // 202
    self.statusChanged();                                                                                         // 203
  },                                                                                                              // 204
                                                                                                                  // 205
  _lostConnection: function () {                                                                                  // 206
    var self = this;                                                                                              // 207
                                                                                                                  // 208
    self._cleanup();                                                                                              // 209
    self._retryLater(); // sets status. no need to do it here.                                                    // 210
  },                                                                                                              // 211
                                                                                                                  // 212
  _retryTimeout: function (count) {                                                                               // 213
    var self = this;                                                                                              // 214
                                                                                                                  // 215
    if (count < self.RETRY_MIN_COUNT)                                                                             // 216
      return self.RETRY_MIN_TIMEOUT;                                                                              // 217
                                                                                                                  // 218
    var timeout = Math.min(                                                                                       // 219
      self.RETRY_MAX_TIMEOUT,                                                                                     // 220
      self.RETRY_BASE_TIMEOUT * Math.pow(self.RETRY_EXPONENT, count));                                            // 221
    // fuzz the timeout randomly, to avoid reconnect storms when a                                                // 222
    // server goes down.                                                                                          // 223
    timeout = timeout * ((Random.fraction() * self.RETRY_FUZZ) +                                                  // 224
                         (1 - self.RETRY_FUZZ/2));                                                                // 225
    return timeout;                                                                                               // 226
  },                                                                                                              // 227
                                                                                                                  // 228
  // fired when we detect that we've gone online. try to reconnect                                                // 229
  // immediately.                                                                                                 // 230
  _online: function () {                                                                                          // 231
    // if we've requested to be offline by disconnecting, don't reconnect.                                        // 232
    if (this.currentStatus.status != "offline")                                                                   // 233
      this.reconnect();                                                                                           // 234
  },                                                                                                              // 235
                                                                                                                  // 236
  _retryLater: function () {                                                                                      // 237
    var self = this;                                                                                              // 238
                                                                                                                  // 239
    var timeout = self._retryTimeout(self.currentStatus.retryCount);                                              // 240
    if (self.retryTimer)                                                                                          // 241
      clearTimeout(self.retryTimer);                                                                              // 242
    self.retryTimer = setTimeout(_.bind(self._retryNow, self), timeout);                                          // 243
                                                                                                                  // 244
    self.currentStatus.status = "waiting";                                                                        // 245
    self.currentStatus.connected = false;                                                                         // 246
    self.currentStatus.retryTime = (new Date()).getTime() + timeout;                                              // 247
    self.statusChanged();                                                                                         // 248
  },                                                                                                              // 249
                                                                                                                  // 250
  _retryNow: function () {                                                                                        // 251
    var self = this;                                                                                              // 252
                                                                                                                  // 253
    if (self._forcedToDisconnect)                                                                                 // 254
      return;                                                                                                     // 255
                                                                                                                  // 256
    self.currentStatus.retryCount += 1;                                                                           // 257
    self.currentStatus.status = "connecting";                                                                     // 258
    self.currentStatus.connected = false;                                                                         // 259
    delete self.currentStatus.retryTime;                                                                          // 260
    self.statusChanged();                                                                                         // 261
                                                                                                                  // 262
    self._launchConnection();                                                                                     // 263
  },                                                                                                              // 264
                                                                                                                  // 265
                                                                                                                  // 266
  // Get current status. Reactive.                                                                                // 267
  status: function () {                                                                                           // 268
    var self = this;                                                                                              // 269
    if (self.statusListeners)                                                                                     // 270
      self.statusListeners.depend();                                                                              // 271
    return self.currentStatus;                                                                                    // 272
  }                                                                                                               // 273
});                                                                                                               // 274
                                                                                                                  // 275
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/livedata_common.js                                                                           //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
DDP = {};                                                                                                         // 1
                                                                                                                  // 2
SUPPORTED_DDP_VERSIONS = [ 'pre1' ];                                                                              // 3
                                                                                                                  // 4
LivedataTest.SUPPORTED_DDP_VERSIONS = SUPPORTED_DDP_VERSIONS;                                                     // 5
                                                                                                                  // 6
MethodInvocation = function (options) {                                                                           // 7
  var self = this;                                                                                                // 8
                                                                                                                  // 9
  // true if we're running not the actual method, but a stub (that is,                                            // 10
  // if we're on a client (which may be a browser, or in the future a                                             // 11
  // server connecting to another server) and presently running a                                                 // 12
  // simulation of a server-side method for latency compensation                                                  // 13
  // purposes). not currently true except in a client such as a browser,                                          // 14
  // since there's usually no point in running stubs unless you have a                                            // 15
  // zero-latency connection to the user.                                                                         // 16
  this.isSimulation = options.isSimulation;                                                                       // 17
                                                                                                                  // 18
  // call this function to allow other method invocations (from the                                               // 19
  // same client) to continue running without waiting for this one to                                             // 20
  // complete.                                                                                                    // 21
  this._unblock = options.unblock || function () {};                                                              // 22
  this._calledUnblock = false;                                                                                    // 23
                                                                                                                  // 24
  // current user id                                                                                              // 25
  this.userId = options.userId;                                                                                   // 26
                                                                                                                  // 27
  // sets current user id in all appropriate server contexts and                                                  // 28
  // reruns subscriptions                                                                                         // 29
  this._setUserId = options.setUserId || function () {};                                                          // 30
                                                                                                                  // 31
  // Scratch data scoped to this connection (livedata_connection on the                                           // 32
  // client, livedata_session on the server). This is only used                                                   // 33
  // internally, but we should have real and documented API for this                                              // 34
  // sort of thing someday.                                                                                       // 35
  this._sessionData = options.sessionData;                                                                        // 36
};                                                                                                                // 37
                                                                                                                  // 38
_.extend(MethodInvocation.prototype, {                                                                            // 39
  unblock: function () {                                                                                          // 40
    var self = this;                                                                                              // 41
    self._calledUnblock = true;                                                                                   // 42
    self._unblock();                                                                                              // 43
  },                                                                                                              // 44
  setUserId: function(userId) {                                                                                   // 45
    var self = this;                                                                                              // 46
    if (self._calledUnblock)                                                                                      // 47
      throw new Error("Can't call setUserId in a method after calling unblock");                                  // 48
    self.userId = userId;                                                                                         // 49
    self._setUserId(userId);                                                                                      // 50
  }                                                                                                               // 51
});                                                                                                               // 52
                                                                                                                  // 53
parseDDP = function (stringMessage) {                                                                             // 54
  try {                                                                                                           // 55
    var msg = JSON.parse(stringMessage);                                                                          // 56
  } catch (e) {                                                                                                   // 57
    Meteor._debug("Discarding message with invalid JSON", stringMessage);                                         // 58
    return null;                                                                                                  // 59
  }                                                                                                               // 60
  // DDP messages must be objects.                                                                                // 61
  if (msg === null || typeof msg !== 'object') {                                                                  // 62
    Meteor._debug("Discarding non-object DDP message", stringMessage);                                            // 63
    return null;                                                                                                  // 64
  }                                                                                                               // 65
                                                                                                                  // 66
  // massage msg to get it into "abstract ddp" rather than "wire ddp" format.                                     // 67
                                                                                                                  // 68
  // switch between "cleared" rep of unsetting fields and "undefined"                                             // 69
  // rep of same                                                                                                  // 70
  if (_.has(msg, 'cleared')) {                                                                                    // 71
    if (!_.has(msg, 'fields'))                                                                                    // 72
      msg.fields = {};                                                                                            // 73
    _.each(msg.cleared, function (clearKey) {                                                                     // 74
      msg.fields[clearKey] = undefined;                                                                           // 75
    });                                                                                                           // 76
    delete msg.cleared;                                                                                           // 77
  }                                                                                                               // 78
                                                                                                                  // 79
  _.each(['fields', 'params', 'result'], function (field) {                                                       // 80
    if (_.has(msg, field))                                                                                        // 81
      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);                                                   // 82
  });                                                                                                             // 83
                                                                                                                  // 84
  return msg;                                                                                                     // 85
};                                                                                                                // 86
                                                                                                                  // 87
stringifyDDP = function (msg) {                                                                                   // 88
  var copy = EJSON.clone(msg);                                                                                    // 89
  // swizzle 'changed' messages from 'fields undefined' rep to 'fields                                            // 90
  // and cleared' rep                                                                                             // 91
  if (_.has(msg, 'fields')) {                                                                                     // 92
    var cleared = [];                                                                                             // 93
    _.each(msg.fields, function (value, key) {                                                                    // 94
      if (value === undefined) {                                                                                  // 95
        cleared.push(key);                                                                                        // 96
        delete copy.fields[key];                                                                                  // 97
      }                                                                                                           // 98
    });                                                                                                           // 99
    if (!_.isEmpty(cleared))                                                                                      // 100
      copy.cleared = cleared;                                                                                     // 101
    if (_.isEmpty(copy.fields))                                                                                   // 102
      delete copy.fields;                                                                                         // 103
  }                                                                                                               // 104
  // adjust types to basic                                                                                        // 105
  _.each(['fields', 'params', 'result'], function (field) {                                                       // 106
    if (_.has(copy, field))                                                                                       // 107
      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);                                                   // 108
  });                                                                                                             // 109
  if (msg.id && typeof msg.id !== 'string') {                                                                     // 110
    throw new Error("Message id is not a string");                                                                // 111
  }                                                                                                               // 112
  return JSON.stringify(copy);                                                                                    // 113
};                                                                                                                // 114
                                                                                                                  // 115
// This is private but it's used in a few places. accounts-base uses                                              // 116
// it to get the current user. accounts-password uses it to stash SRP                                             // 117
// state in the DDP session. Meteor.setTimeout and friends clear                                                  // 118
// it. We can probably find a better way to factor this.                                                          // 119
DDP._CurrentInvocation = new Meteor.EnvironmentVariable;                                                          // 120
                                                                                                                  // 121
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/livedata_connection.js                                                                       //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
if (Meteor.isServer) {                                                                                            // 1
  var path = Npm.require('path');                                                                                 // 2
  var Fiber = Npm.require('fibers');                                                                              // 3
  var Future = Npm.require(path.join('fibers', 'future'));                                                        // 4
}                                                                                                                 // 5
                                                                                                                  // 6
// @param url {String|Object} URL to Meteor app,                                                                  // 7
//   or an object as a test hook (see code)                                                                       // 8
// Options:                                                                                                       // 9
//   reloadOnUpdate: should we try to reload when the server says                                                 // 10
//                      there's new code available?                                                               // 11
//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                  // 12
var Connection = function (url, options) {                                                                        // 13
  var self = this;                                                                                                // 14
  options = _.extend({                                                                                            // 15
    reloadOnUpdate: false,                                                                                        // 16
    // The rest of these options are only for testing.                                                            // 17
    reloadWithOutstanding: false,                                                                                 // 18
    supportedDDPVersions: SUPPORTED_DDP_VERSIONS,                                                                 // 19
    onConnectionFailure: function (reason) {                                                                      // 20
      Meteor._debug("Failed DDP connection: " + reason);                                                          // 21
    },                                                                                                            // 22
    onConnected: function () {}                                                                                   // 23
  }, options);                                                                                                    // 24
                                                                                                                  // 25
  // If set, called when we reconnect, queuing method calls _before_ the                                          // 26
  // existing outstanding ones. This is the only data member that is part of the                                  // 27
  // public API!                                                                                                  // 28
  self.onReconnect = null;                                                                                        // 29
                                                                                                                  // 30
  // as a test hook, allow passing a stream instead of a url.                                                     // 31
  if (typeof url === "object") {                                                                                  // 32
    self._stream = url;                                                                                           // 33
  } else {                                                                                                        // 34
    self._stream = new LivedataTest.ClientStream(url);                                                            // 35
  }                                                                                                               // 36
                                                                                                                  // 37
  self._lastSessionId = null;                                                                                     // 38
  self._versionSuggestion = null;  // The last proposed DDP version.                                              // 39
  self._version = null;   // The DDP version agreed on by client and server.                                      // 40
  self._stores = {}; // name -> object with methods                                                               // 41
  self._methodHandlers = {}; // name -> func                                                                      // 42
  self._nextMethodId = 1;                                                                                         // 43
  self._supportedDDPVersions = options.supportedDDPVersions;                                                      // 44
                                                                                                                  // 45
  // Tracks methods which the user has tried to call but which have not yet                                       // 46
  // called their user callback (ie, they are waiting on their result or for all                                  // 47
  // of their writes to be written to the local cache). Map from method ID to                                     // 48
  // MethodInvoker object.                                                                                        // 49
  self._methodInvokers = {};                                                                                      // 50
                                                                                                                  // 51
  // Tracks methods which the user has called but whose result messages have not                                  // 52
  // arrived yet.                                                                                                 // 53
  //                                                                                                              // 54
  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                        // 55
  // represents a set of methods that can run at the same time. The first block                                   // 56
  // represents the methods which are currently in flight; subsequent blocks                                      // 57
  // must wait for previous blocks to be fully finished before they can be sent                                   // 58
  // to the server.                                                                                               // 59
  //                                                                                                              // 60
  // Each block is an object with the following fields:                                                           // 61
  // - methods: a list of MethodInvoker objects                                                                   // 62
  // - wait: a boolean; if true, this block had a single method invoked with                                      // 63
  //         the "wait" option                                                                                    // 64
  //                                                                                                              // 65
  // There will never be adjacent blocks with wait=false, because the only thing                                  // 66
  // that makes methods need to be serialized is a wait method.                                                   // 67
  //                                                                                                              // 68
  // Methods are removed from the first block when their "result" is                                              // 69
  // received. The entire first block is only removed when all of the in-flight                                   // 70
  // methods have received their results (so the "methods" list is empty) *AND*                                   // 71
  // all of the data written by those methods are visible in the local cache. So                                  // 72
  // it is possible for the first block's methods list to be empty, if we are                                     // 73
  // still waiting for some objects to quiesce.                                                                   // 74
  //                                                                                                              // 75
  // Example:                                                                                                     // 76
  //  _outstandingMethodBlocks = [                                                                                // 77
  //    {wait: false, methods: []},                                                                               // 78
  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                     // 79
  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                        // 80
  //                            <MethodInvoker for 'bar'>]}]                                                      // 81
  // This means that there were some methods which were sent to the server and                                    // 82
  // which have returned their results, but some of the data written by                                           // 83
  // the methods may not be visible in the local cache. Once all that data is                                     // 84
  // visible, we will send a 'login' method. Once the login method has returned                                   // 85
  // and all the data is visible (including re-running subs if userId changes),                                   // 86
  // we will send the 'foo' and 'bar' methods in parallel.                                                        // 87
  self._outstandingMethodBlocks = [];                                                                             // 88
                                                                                                                  // 89
  // method ID -> array of objects with keys 'collection' and 'id', listing                                       // 90
  // documents written by a given method's stub. keys are associated with                                         // 91
  // methods whose stub wrote at least one document, and whose data-done message                                  // 92
  // has not yet been received.                                                                                   // 93
  self._documentsWrittenByStub = {};                                                                              // 94
  // collection -> id -> "server document" object. A "server document" has:                                       // 95
  // - "document": the version of the document according the                                                      // 96
  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                    // 97
  //   received from the server)                                                                                  // 98
  //   It is undefined if we think the document does not exist                                                    // 99
  // - "writtenByStubs": a set of method IDs whose stubs wrote to the document                                    // 100
  //   whose "data done" messages have not yet been processed                                                     // 101
  self._serverDocuments = {};                                                                                     // 102
                                                                                                                  // 103
  // Array of callbacks to be called after the next update of the local                                           // 104
  // cache. Used for:                                                                                             // 105
  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                           // 106
  //    the relevant data is flushed.                                                                             // 107
  //  - Invoking the callbacks of "half-finished" methods after reconnect                                         // 108
  //    quiescence. Specifically, methods whose result was received over the old                                  // 109
  //    connection (so we don't re-send it) but whose data had not been made                                      // 110
  //    visible.                                                                                                  // 111
  self._afterUpdateCallbacks = [];                                                                                // 112
                                                                                                                  // 113
  // In two contexts, we buffer all incoming data messages and then process them                                  // 114
  // all at once in a single update:                                                                              // 115
  //   - During reconnect, we buffer all data messages until all subs that had                                    // 116
  //     been ready before reconnect are ready again, and all methods that are                                    // 117
  //     active have returned their "data done message"; then                                                     // 118
  //   - During the execution of a "wait" method, we buffer all data messages                                     // 119
  //     until the wait method gets its "data done" message. (If the wait method                                  // 120
  //     occurs during reconnect, it doesn't get any special handling.)                                           // 121
  // all data messages are processed in one update.                                                               // 122
  //                                                                                                              // 123
  // The following fields are used for this "quiescence" process.                                                 // 124
                                                                                                                  // 125
  // This buffers the messages that aren't being processed yet.                                                   // 126
  self._messagesBufferedUntilQuiescence = [];                                                                     // 127
  // Map from method ID -> true. Methods are removed from this when their                                         // 128
  // "data done" message is received, and we will not quiesce until it is                                         // 129
  // empty.                                                                                                       // 130
  self._methodsBlockingQuiescence = {};                                                                           // 131
  // map from sub ID -> true for subs that were ready (ie, called the sub                                         // 132
  // ready callback) before reconnect but haven't become ready again yet                                          // 133
  self._subsBeingRevived = {}; // map from sub._id -> true                                                        // 134
  // if true, the next data update should reset all stores. (set during                                           // 135
  // reconnect.)                                                                                                  // 136
  self._resetStores = false;                                                                                      // 137
                                                                                                                  // 138
  // name -> array of updates for (yet to be created) collections                                                 // 139
  self._updatesForUnknownStores = {};                                                                             // 140
  // if we're blocking a migration, the retry func                                                                // 141
  self._retryMigrate = null;                                                                                      // 142
                                                                                                                  // 143
  // metadata for subscriptions.  Map from sub ID to object with keys:                                            // 144
  //   - id                                                                                                       // 145
  //   - name                                                                                                     // 146
  //   - params                                                                                                   // 147
  //   - inactive (if true, will be cleaned up if not reused in re-run)                                           // 148
  //   - ready (has the 'ready' message been received?)                                                           // 149
  //   - readyCallback (an optional callback to call when ready)                                                  // 150
  //   - errorCallback (an optional callback to call if the sub terminates with                                   // 151
  //                    an error)                                                                                 // 152
  self._subscriptions = {};                                                                                       // 153
                                                                                                                  // 154
  // Per-connection scratch area. This is only used internally, but we                                            // 155
  // should have real and documented API for this sort of thing someday.                                          // 156
  self._sessionData = {};                                                                                         // 157
                                                                                                                  // 158
  // Reactive userId.                                                                                             // 159
  self._userId = null;                                                                                            // 160
  self._userIdDeps = (typeof Deps !== "undefined") && new Deps.Dependency;                                        // 161
                                                                                                                  // 162
  // Block auto-reload while we're waiting for method responses.                                                  // 163
  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                      // 164
    Reload._onMigrate(function (retry) {                                                                          // 165
      if (!self._readyToMigrate()) {                                                                              // 166
        if (self._retryMigrate)                                                                                   // 167
          throw new Error("Two migrations in progress?");                                                         // 168
        self._retryMigrate = retry;                                                                               // 169
        return false;                                                                                             // 170
      } else {                                                                                                    // 171
        return [true];                                                                                            // 172
      }                                                                                                           // 173
    });                                                                                                           // 174
  }                                                                                                               // 175
                                                                                                                  // 176
  var onMessage = function (raw_msg) {                                                                            // 177
    try {                                                                                                         // 178
      var msg = parseDDP(raw_msg);                                                                                // 179
    } catch (e) {                                                                                                 // 180
      Meteor._debug("Exception while parsing DDP", e);                                                            // 181
      return;                                                                                                     // 182
    }                                                                                                             // 183
                                                                                                                  // 184
    if (msg === null || !msg.msg) {                                                                               // 185
      Meteor._debug("discarding invalid livedata message", msg);                                                  // 186
      return;                                                                                                     // 187
    }                                                                                                             // 188
                                                                                                                  // 189
    if (msg.msg === 'connected') {                                                                                // 190
      self._version = self._versionSuggestion;                                                                    // 191
      options.onConnected();                                                                                      // 192
      self._livedata_connected(msg);                                                                              // 193
    }                                                                                                             // 194
    else if (msg.msg == 'failed') {                                                                               // 195
      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                  // 196
        self._versionSuggestion = msg.version;                                                                    // 197
        self._stream.reconnect({_force: true});                                                                   // 198
      } else {                                                                                                    // 199
        var error =                                                                                               // 200
              "Version negotiation failed; server requested version " + msg.version;                              // 201
        self._stream.disconnect({_permanent: true, _error: error});                                               // 202
        options.onConnectionFailure(error);                                                                       // 203
      }                                                                                                           // 204
    }                                                                                                             // 205
    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))                             // 206
      self._livedata_data(msg);                                                                                   // 207
    else if (msg.msg === 'nosub')                                                                                 // 208
      self._livedata_nosub(msg);                                                                                  // 209
    else if (msg.msg === 'result')                                                                                // 210
      self._livedata_result(msg);                                                                                 // 211
    else if (msg.msg === 'error')                                                                                 // 212
      self._livedata_error(msg);                                                                                  // 213
    else                                                                                                          // 214
      Meteor._debug("discarding unknown livedata message type", msg);                                             // 215
  };                                                                                                              // 216
                                                                                                                  // 217
  var onReset = function () {                                                                                     // 218
    // Send a connect message at the beginning of the stream.                                                     // 219
    // NOTE: reset is called even on the first connection, so this is                                             // 220
    // the only place we send this message.                                                                       // 221
    var msg = {msg: 'connect'};                                                                                   // 222
    if (self._lastSessionId)                                                                                      // 223
      msg.session = self._lastSessionId;                                                                          // 224
    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                       // 225
    self._versionSuggestion = msg.version;                                                                        // 226
    msg.support = self._supportedDDPVersions;                                                                     // 227
    self._send(msg);                                                                                              // 228
                                                                                                                  // 229
    // Now, to minimize setup latency, go ahead and blast out all of                                              // 230
    // our pending methods ands subscriptions before we've even taken                                             // 231
    // the necessary RTT to know if we successfully reconnected. (1)                                              // 232
    // They're supposed to be idempotent; (2) even if we did                                                      // 233
    // reconnect, we're not sure what messages might have gotten lost                                             // 234
    // (in either direction) since we were disconnected (TCP being                                                // 235
    // sloppy about that.)                                                                                        // 236
                                                                                                                  // 237
    // If the current block of methods all got their results (but didn't all get                                  // 238
    // their data visible), discard the empty block now.                                                          // 239
    if (! _.isEmpty(self._outstandingMethodBlocks) &&                                                             // 240
        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {                                                    // 241
      self._outstandingMethodBlocks.shift();                                                                      // 242
    }                                                                                                             // 243
                                                                                                                  // 244
    // Mark all messages as unsent, they have not yet been sent on this                                           // 245
    // connection.                                                                                                // 246
    _.each(self._methodInvokers, function (m) {                                                                   // 247
      m.sentMessage = false;                                                                                      // 248
    });                                                                                                           // 249
                                                                                                                  // 250
    // If an `onReconnect` handler is set, call it first. Go through                                              // 251
    // some hoops to ensure that methods that are called from within                                              // 252
    // `onReconnect` get executed _before_ ones that were originally                                              // 253
    // outstanding (since `onReconnect` is used to re-establish auth                                              // 254
    // certificates)                                                                                              // 255
    if (self.onReconnect)                                                                                         // 256
      self._callOnReconnectAndSendAppropriateOutstandingMethods();                                                // 257
    else                                                                                                          // 258
      self._sendOutstandingMethods();                                                                             // 259
                                                                                                                  // 260
    // add new subscriptions at the end. this way they take effect after                                          // 261
    // the handlers and we don't see flicker.                                                                     // 262
    _.each(self._subscriptions, function (sub, id) {                                                              // 263
      self._send({                                                                                                // 264
        msg: 'sub',                                                                                               // 265
        id: id,                                                                                                   // 266
        name: sub.name,                                                                                           // 267
        params: sub.params                                                                                        // 268
      });                                                                                                         // 269
    });                                                                                                           // 270
  };                                                                                                              // 271
                                                                                                                  // 272
  if (Meteor.isServer) {                                                                                          // 273
    self._stream.on('message', Meteor.bindEnvironment(onMessage, Meteor._debug));                                 // 274
    self._stream.on('reset', Meteor.bindEnvironment(onReset, Meteor._debug));                                     // 275
  } else {                                                                                                        // 276
    self._stream.on('message', onMessage);                                                                        // 277
    self._stream.on('reset', onReset);                                                                            // 278
  }                                                                                                               // 279
                                                                                                                  // 280
                                                                                                                  // 281
  if (Meteor.isClient && Package.reload && options.reloadOnUpdate) {                                              // 282
    self._stream.on('update_available', function () {                                                             // 283
      // Start trying to migrate to a new version. Until all packages                                             // 284
      // signal that they're ready for a migration, the app will                                                  // 285
      // continue running normally.                                                                               // 286
      Reload._reload();                                                                                           // 287
    });                                                                                                           // 288
  }                                                                                                               // 289
                                                                                                                  // 290
};                                                                                                                // 291
                                                                                                                  // 292
// A MethodInvoker manages sending a method to the server and calling the user's                                  // 293
// callbacks. On construction, it registers itself in the connection's                                            // 294
// _methodInvokers map; it removes itself once the method is fully finished and                                   // 295
// the callback is invoked. This occurs when it has both received a result,                                       // 296
// and the data written by it is fully visible.                                                                   // 297
var MethodInvoker = function (options) {                                                                          // 298
  var self = this;                                                                                                // 299
                                                                                                                  // 300
  // Public (within this file) fields.                                                                            // 301
  self.methodId = options.methodId;                                                                               // 302
  self.sentMessage = false;                                                                                       // 303
                                                                                                                  // 304
  self._callback = options.callback;                                                                              // 305
  self._connection = options.connection;                                                                          // 306
  self._message = options.message;                                                                                // 307
  self._onResultReceived = options.onResultReceived || function () {};                                            // 308
  self._wait = options.wait;                                                                                      // 309
  self._methodResult = null;                                                                                      // 310
  self._dataVisible = false;                                                                                      // 311
                                                                                                                  // 312
  // Register with the connection.                                                                                // 313
  self._connection._methodInvokers[self.methodId] = self;                                                         // 314
};                                                                                                                // 315
_.extend(MethodInvoker.prototype, {                                                                               // 316
  // Sends the method message to the server. May be called additional times if                                    // 317
  // we lose the connection and reconnect before receiving a result.                                              // 318
  sendMessage: function () {                                                                                      // 319
    var self = this;                                                                                              // 320
    // This function is called before sending a method (including resending on                                    // 321
    // reconnect). We should only (re)send methods where we don't already have a                                  // 322
    // result!                                                                                                    // 323
    if (self.gotResult())                                                                                         // 324
      throw new Error("sendingMethod is called on method with result");                                           // 325
                                                                                                                  // 326
    // If we're re-sending it, it doesn't matter if data was written the first                                    // 327
    // time.                                                                                                      // 328
    self._dataVisible = false;                                                                                    // 329
                                                                                                                  // 330
    self.sentMessage = true;                                                                                      // 331
                                                                                                                  // 332
    // If this is a wait method, make all data messages be buffered until it is                                   // 333
    // done.                                                                                                      // 334
    if (self._wait)                                                                                               // 335
      self._connection._methodsBlockingQuiescence[self.methodId] = true;                                          // 336
                                                                                                                  // 337
    // Actually send the message.                                                                                 // 338
    self._connection._send(self._message);                                                                        // 339
  },                                                                                                              // 340
  // Invoke the callback, if we have both a result and know that all data has                                     // 341
  // been written to the local cache.                                                                             // 342
  _maybeInvokeCallback: function () {                                                                             // 343
    var self = this;                                                                                              // 344
    if (self._methodResult && self._dataVisible) {                                                                // 345
      // Call the callback. (This won't throw: the callback was wrapped with                                      // 346
      // bindEnvironment.)                                                                                        // 347
      self._callback(self._methodResult[0], self._methodResult[1]);                                               // 348
                                                                                                                  // 349
      // Forget about this method.                                                                                // 350
      delete self._connection._methodInvokers[self.methodId];                                                     // 351
                                                                                                                  // 352
      // Let the connection know that this method is finished, so it can try to                                   // 353
      // move on to the next block of methods.                                                                    // 354
      self._connection._outstandingMethodFinished();                                                              // 355
    }                                                                                                             // 356
  },                                                                                                              // 357
  // Call with the result of the method from the server. Only may be called                                       // 358
  // once; once it is called, you should not call sendMessage again.                                              // 359
  // If the user provided an onResultReceived callback, call it immediately.                                      // 360
  // Then invoke the main callback if data is also visible.                                                       // 361
  receiveResult: function (err, result) {                                                                         // 362
    var self = this;                                                                                              // 363
    if (self.gotResult())                                                                                         // 364
      throw new Error("Methods should only receive results once");                                                // 365
    self._methodResult = [err, result];                                                                           // 366
    self._onResultReceived(err, result);                                                                          // 367
    self._maybeInvokeCallback();                                                                                  // 368
  },                                                                                                              // 369
  // Call this when all data written by the method is visible. This means that                                    // 370
  // the method has returns its "data is done" message *AND* all server                                           // 371
  // documents that are buffered at that time have been written to the local                                      // 372
  // cache. Invokes the main callback if the result has been received.                                            // 373
  dataVisible: function () {                                                                                      // 374
    var self = this;                                                                                              // 375
    self._dataVisible = true;                                                                                     // 376
    self._maybeInvokeCallback();                                                                                  // 377
  },                                                                                                              // 378
  // True if receiveResult has been called.                                                                       // 379
  gotResult: function () {                                                                                        // 380
    var self = this;                                                                                              // 381
    return !!self._methodResult;                                                                                  // 382
  }                                                                                                               // 383
});                                                                                                               // 384
                                                                                                                  // 385
_.extend(Connection.prototype, {                                                                                  // 386
  // 'name' is the name of the data on the wire that should go in the                                             // 387
  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                  // 388
  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                  // 389
  registerStore: function (name, wrappedStore) {                                                                  // 390
    var self = this;                                                                                              // 391
                                                                                                                  // 392
    if (name in self._stores)                                                                                     // 393
      return false;                                                                                               // 394
                                                                                                                  // 395
    // Wrap the input object in an object which makes any store method not                                        // 396
    // implemented by 'store' into a no-op.                                                                       // 397
    var store = {};                                                                                               // 398
    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',                                                // 399
            'retrieveOriginals'], function (method) {                                                             // 400
              store[method] = function () {                                                                       // 401
                return (wrappedStore[method]                                                                      // 402
                        ? wrappedStore[method].apply(wrappedStore, arguments)                                     // 403
                        : undefined);                                                                             // 404
              };                                                                                                  // 405
            });                                                                                                   // 406
                                                                                                                  // 407
    self._stores[name] = store;                                                                                   // 408
                                                                                                                  // 409
    var queued = self._updatesForUnknownStores[name];                                                             // 410
    if (queued) {                                                                                                 // 411
      store.beginUpdate(queued.length, false);                                                                    // 412
      _.each(queued, function (msg) {                                                                             // 413
        store.update(msg);                                                                                        // 414
      });                                                                                                         // 415
      store.endUpdate();                                                                                          // 416
      delete self._updatesForUnknownStores[name];                                                                 // 417
    }                                                                                                             // 418
                                                                                                                  // 419
    return true;                                                                                                  // 420
  },                                                                                                              // 421
                                                                                                                  // 422
  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                       // 423
    var self = this;                                                                                              // 424
                                                                                                                  // 425
    var params = Array.prototype.slice.call(arguments, 1);                                                        // 426
    var callbacks = {};                                                                                           // 427
    if (params.length) {                                                                                          // 428
      var lastParam = params[params.length - 1];                                                                  // 429
      if (typeof lastParam === "function") {                                                                      // 430
        callbacks.onReady = params.pop();                                                                         // 431
      } else if (lastParam && (typeof lastParam.onReady === "function" ||                                         // 432
                               typeof lastParam.onError === "function")) {                                        // 433
        callbacks = params.pop();                                                                                 // 434
      }                                                                                                           // 435
    }                                                                                                             // 436
                                                                                                                  // 437
    // Is there an existing sub with the same name and param, run in an                                           // 438
    // invalidated Computation? This will happen if we are rerunning an                                           // 439
    // existing computation.                                                                                      // 440
    //                                                                                                            // 441
    // For example, consider a rerun of:                                                                          // 442
    //                                                                                                            // 443
    //     Deps.autorun(function () {                                                                             // 444
    //       Meteor.subscribe("foo", Session.get("foo"));                                                         // 445
    //       Meteor.subscribe("bar", Session.get("bar"));                                                         // 446
    //     });                                                                                                    // 447
    //                                                                                                            // 448
    // If "foo" has changed but "bar" has not, we will match the "bar"                                            // 449
    // subcribe to an existing inactive subscription in order to not                                              // 450
    // unsub and resub the subscription unnecessarily.                                                            // 451
    //                                                                                                            // 452
    // We only look for one such sub; if there are N apparently-identical subs                                    // 453
    // being invalidated, we will require N matching subscribe calls to keep                                      // 454
    // them all active.                                                                                           // 455
    var existing = _.find(self._subscriptions, function (sub) {                                                   // 456
      return sub.inactive && sub.name === name &&                                                                 // 457
        EJSON.equals(sub.params, params);                                                                         // 458
    });                                                                                                           // 459
                                                                                                                  // 460
    var id;                                                                                                       // 461
    if (existing) {                                                                                               // 462
      id = existing.id;                                                                                           // 463
      existing.inactive = false; // reactivate                                                                    // 464
                                                                                                                  // 465
      if (callbacks.onReady) {                                                                                    // 466
        // If the sub is not already ready, replace any ready callback with the                                   // 467
        // one provided now. (It's not really clear what users would expect for                                   // 468
        // an onReady callback inside an autorun; the semantics we provide is                                     // 469
        // that at the time the sub first becomes ready, we call the last                                         // 470
        // onReady callback provided, if any.)                                                                    // 471
        if (!existing.ready)                                                                                      // 472
          existing.readyCallback = callbacks.onReady;                                                             // 473
      }                                                                                                           // 474
      if (callbacks.onError) {                                                                                    // 475
        // Replace existing callback if any, so that errors aren't                                                // 476
        // double-reported.                                                                                       // 477
        existing.errorCallback = callbacks.onError;                                                               // 478
      }                                                                                                           // 479
    } else {                                                                                                      // 480
      // New sub! Generate an id, save it locally, and send message.                                              // 481
      id = Random.id();                                                                                           // 482
      self._subscriptions[id] = {                                                                                 // 483
        id: id,                                                                                                   // 484
        name: name,                                                                                               // 485
        params: params,                                                                                           // 486
        inactive: false,                                                                                          // 487
        ready: false,                                                                                             // 488
        readyDeps: (typeof Deps !== "undefined") && new Deps.Dependency,                                          // 489
        readyCallback: callbacks.onReady,                                                                         // 490
        errorCallback: callbacks.onError                                                                          // 491
      };                                                                                                          // 492
      self._send({msg: 'sub', id: id, name: name, params: params});                                               // 493
    }                                                                                                             // 494
                                                                                                                  // 495
    // return a handle to the application.                                                                        // 496
    var handle = {                                                                                                // 497
      stop: function () {                                                                                         // 498
        if (!_.has(self._subscriptions, id))                                                                      // 499
          return;                                                                                                 // 500
        self._send({msg: 'unsub', id: id});                                                                       // 501
        delete self._subscriptions[id];                                                                           // 502
      },                                                                                                          // 503
      ready: function () {                                                                                        // 504
        // return false if we've unsubscribed.                                                                    // 505
        if (!_.has(self._subscriptions, id))                                                                      // 506
          return false;                                                                                           // 507
        var record = self._subscriptions[id];                                                                     // 508
        record.readyDeps && record.readyDeps.depend();                                                            // 509
        return record.ready;                                                                                      // 510
      }                                                                                                           // 511
    };                                                                                                            // 512
                                                                                                                  // 513
    if (Deps.active) {                                                                                            // 514
      // We're in a reactive computation, so we'd like to unsubscribe when the                                    // 515
      // computation is invalidated... but not if the rerun just re-subscribes                                    // 516
      // to the same subscription!  When a rerun happens, we use onInvalidate                                     // 517
      // as a change to mark the subscription "inactive" so that it can                                           // 518
      // be reused from the rerun.  If it isn't reused, it's killed from                                          // 519
      // an afterFlush.                                                                                           // 520
      Deps.onInvalidate(function (c) {                                                                            // 521
        if (_.has(self._subscriptions, id))                                                                       // 522
          self._subscriptions[id].inactive = true;                                                                // 523
                                                                                                                  // 524
        Deps.afterFlush(function () {                                                                             // 525
          if (_.has(self._subscriptions, id) &&                                                                   // 526
              self._subscriptions[id].inactive)                                                                   // 527
            handle.stop();                                                                                        // 528
        });                                                                                                       // 529
      });                                                                                                         // 530
    }                                                                                                             // 531
                                                                                                                  // 532
    return handle;                                                                                                // 533
  },                                                                                                              // 534
                                                                                                                  // 535
  // options:                                                                                                     // 536
  // - onLateError {Function(error)} called if an error was received after the ready event.                       // 537
  //     (errors received before ready cause an error to be thrown)                                               // 538
  _subscribeAndWait: function (name, args, options) {                                                             // 539
    var self = this;                                                                                              // 540
    var f = new Future();                                                                                         // 541
    var ready = false;                                                                                            // 542
    args = args || [];                                                                                            // 543
    args.push({                                                                                                   // 544
      onReady: function () {                                                                                      // 545
        ready = true;                                                                                             // 546
        f['return']();                                                                                            // 547
      },                                                                                                          // 548
      onError: function (e) {                                                                                     // 549
        if (!ready)                                                                                               // 550
          f['throw'](e);                                                                                          // 551
        else                                                                                                      // 552
          options && options.onLateError && options.onLateError(e);                                               // 553
      }                                                                                                           // 554
    });                                                                                                           // 555
                                                                                                                  // 556
    self.subscribe.apply(self, [name].concat(args));                                                              // 557
    f.wait();                                                                                                     // 558
  },                                                                                                              // 559
                                                                                                                  // 560
  methods: function (methods) {                                                                                   // 561
    var self = this;                                                                                              // 562
    _.each(methods, function (func, name) {                                                                       // 563
      if (self._methodHandlers[name])                                                                             // 564
        throw new Error("A method named '" + name + "' is already defined");                                      // 565
      self._methodHandlers[name] = func;                                                                          // 566
    });                                                                                                           // 567
  },                                                                                                              // 568
                                                                                                                  // 569
  call: function (name /* .. [arguments] .. callback */) {                                                        // 570
    // if it's a function, the last argument is the result callback,                                              // 571
    // not a parameter to the remote method.                                                                      // 572
    var args = Array.prototype.slice.call(arguments, 1);                                                          // 573
    if (args.length && typeof args[args.length - 1] === "function")                                               // 574
      var callback = args.pop();                                                                                  // 575
    return this.apply(name, args, callback);                                                                      // 576
  },                                                                                                              // 577
                                                                                                                  // 578
  // @param options {Optional Object}                                                                             // 579
  //   wait: Boolean - Should we wait to call this until all current methods                                      // 580
  //                   are fully finished, and block subsequent method calls                                      // 581
  //                   until this method is fully finished?                                                       // 582
  //                   (does not affect methods called from within this method)                                   // 583
  //   onResultReceived: Function - a callback to call as soon as the method                                      // 584
  //                                result is received. the data written by                                       // 585
  //                                the method may not yet be in the cache!                                       // 586
  // @param callback {Optional Function}                                                                          // 587
  apply: function (name, args, options, callback) {                                                               // 588
    var self = this;                                                                                              // 589
                                                                                                                  // 590
    // We were passed 3 arguments. They may be either (name, args, options)                                       // 591
    // or (name, args, callback)                                                                                  // 592
    if (!callback && typeof options === 'function') {                                                             // 593
      callback = options;                                                                                         // 594
      options = {};                                                                                               // 595
    }                                                                                                             // 596
    options = options || {};                                                                                      // 597
                                                                                                                  // 598
    if (callback) {                                                                                               // 599
      // XXX would it be better form to do the binding in stream.on,                                              // 600
      // or caller, instead of here?                                                                              // 601
      callback = Meteor.bindEnvironment(callback, function (e) {                                                  // 602
        // XXX improve error message (and how we report it)                                                       // 603
        Meteor._debug("Exception while delivering result of invoking '" +                                         // 604
                      name + "'", e, e.stack);                                                                    // 605
      });                                                                                                         // 606
    }                                                                                                             // 607
                                                                                                                  // 608
    // Lazily allocate method ID once we know that it'll be needed.                                               // 609
    var methodId = (function () {                                                                                 // 610
      var id;                                                                                                     // 611
      return function () {                                                                                        // 612
        if (id === undefined)                                                                                     // 613
          id = '' + (self._nextMethodId++);                                                                       // 614
        return id;                                                                                                // 615
      };                                                                                                          // 616
    })();                                                                                                         // 617
                                                                                                                  // 618
    // Run the stub, if we have one. The stub is supposed to make some                                            // 619
    // temporary writes to the database to give the user a smooth experience                                      // 620
    // until the actual result of executing the method comes back from the                                        // 621
    // server (whereupon the temporary writes to the database will be reversed                                    // 622
    // during the beginUpdate/endUpdate process.)                                                                 // 623
    //                                                                                                            // 624
    // Normally, we ignore the return value of the stub (even if it is an                                         // 625
    // exception), in favor of the real return value from the server. The                                         // 626
    // exception is if the *caller* is a stub. In that case, we're not going                                      // 627
    // to do a RPC, so we use the return value of the stub as our return                                          // 628
    // value.                                                                                                     // 629
                                                                                                                  // 630
    var enclosing = DDP._CurrentInvocation.get();                                                                 // 631
    var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                // 632
                                                                                                                  // 633
    var stub = self._methodHandlers[name];                                                                        // 634
    if (stub) {                                                                                                   // 635
      var setUserId = function(userId) {                                                                          // 636
        self.setUserId(userId);                                                                                   // 637
      };                                                                                                          // 638
      var invocation = new MethodInvocation({                                                                     // 639
        isSimulation: true,                                                                                       // 640
        userId: self.userId(), setUserId: setUserId,                                                              // 641
        sessionData: self._sessionData                                                                            // 642
      });                                                                                                         // 643
                                                                                                                  // 644
      if (!alreadyInSimulation)                                                                                   // 645
        self._saveOriginals();                                                                                    // 646
                                                                                                                  // 647
      try {                                                                                                       // 648
        // Note that unlike in the corresponding server code, we never audit                                      // 649
        // that stubs check() their arguments.                                                                    // 650
        var ret = DDP._CurrentInvocation.withValue(invocation, function () {                                      // 651
          if (Meteor.isServer) {                                                                                  // 652
            // Because saveOriginals and retrieveOriginals aren't reentrant,                                      // 653
            // don't allow stubs to yield.                                                                        // 654
            return Meteor._noYieldsAllowed(function () {                                                          // 655
              return stub.apply(invocation, EJSON.clone(args));                                                   // 656
            });                                                                                                   // 657
          } else {                                                                                                // 658
            return stub.apply(invocation, EJSON.clone(args));                                                     // 659
          }                                                                                                       // 660
        });                                                                                                       // 661
      }                                                                                                           // 662
      catch (e) {                                                                                                 // 663
        var exception = e;                                                                                        // 664
      }                                                                                                           // 665
                                                                                                                  // 666
      if (!alreadyInSimulation)                                                                                   // 667
        self._retrieveAndStoreOriginals(methodId());                                                              // 668
    }                                                                                                             // 669
                                                                                                                  // 670
    // If we're in a simulation, stop and return the result we have,                                              // 671
    // rather than going on to do an RPC. If there was no stub,                                                   // 672
    // we'll end up returning undefined.                                                                          // 673
    if (alreadyInSimulation) {                                                                                    // 674
      if (callback) {                                                                                             // 675
        callback(exception, ret);                                                                                 // 676
        return undefined;                                                                                         // 677
      }                                                                                                           // 678
      if (exception)                                                                                              // 679
        throw exception;                                                                                          // 680
      return ret;                                                                                                 // 681
    }                                                                                                             // 682
                                                                                                                  // 683
    // If an exception occurred in a stub, and we're ignoring it                                                  // 684
    // because we're doing an RPC and want to use what the server                                                 // 685
    // returns instead, log it so the developer knows.                                                            // 686
    //                                                                                                            // 687
    // Tests can set the 'expected' flag on an exception so it won't                                              // 688
    // go to log.                                                                                                 // 689
    if (exception && !exception.expected) {                                                                       // 690
      Meteor._debug("Exception while simulating the effect of invoking '" +                                       // 691
                    name + "'", exception, exception.stack);                                                      // 692
    }                                                                                                             // 693
                                                                                                                  // 694
                                                                                                                  // 695
    // At this point we're definitely doing an RPC, and we're going to                                            // 696
    // return the value of the RPC to the caller.                                                                 // 697
                                                                                                                  // 698
    // If the caller didn't give a callback, decide what to do.                                                   // 699
    if (!callback) {                                                                                              // 700
      if (Meteor.isClient) {                                                                                      // 701
        // On the client, we don't have fibers, so we can't block. The                                            // 702
        // only thing we can do is to return undefined and discard the                                            // 703
        // result of the RPC.                                                                                     // 704
        callback = function () {};                                                                                // 705
      } else {                                                                                                    // 706
        // On the server, make the function synchronous. Throw on                                                 // 707
        // errors, return on success.                                                                             // 708
        var future = new Future;                                                                                  // 709
        callback = future.resolver();                                                                             // 710
      }                                                                                                           // 711
    }                                                                                                             // 712
    // Send the RPC. Note that on the client, it is important that the                                            // 713
    // stub have finished before we send the RPC, so that we know we have                                         // 714
    // a complete list of which local documents the stub wrote.                                                   // 715
    var methodInvoker = new MethodInvoker({                                                                       // 716
      methodId: methodId(),                                                                                       // 717
      callback: callback,                                                                                         // 718
      connection: self,                                                                                           // 719
      onResultReceived: options.onResultReceived,                                                                 // 720
      wait: !!options.wait,                                                                                       // 721
      message: {                                                                                                  // 722
        msg: 'method',                                                                                            // 723
        method: name,                                                                                             // 724
        params: args,                                                                                             // 725
        id: methodId()                                                                                            // 726
      }                                                                                                           // 727
    });                                                                                                           // 728
                                                                                                                  // 729
    if (options.wait) {                                                                                           // 730
      // It's a wait method! Wait methods go in their own block.                                                  // 731
      self._outstandingMethodBlocks.push(                                                                         // 732
        {wait: true, methods: [methodInvoker]});                                                                  // 733
    } else {                                                                                                      // 734
      // Not a wait method. Start a new block if the previous block was a wait                                    // 735
      // block, and add it to the last block of methods.                                                          // 736
      if (_.isEmpty(self._outstandingMethodBlocks) ||                                                             // 737
          _.last(self._outstandingMethodBlocks).wait)                                                             // 738
        self._outstandingMethodBlocks.push({wait: false, methods: []});                                           // 739
      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                          // 740
    }                                                                                                             // 741
                                                                                                                  // 742
    // If we added it to the first block, send it out now.                                                        // 743
    if (self._outstandingMethodBlocks.length === 1)                                                               // 744
      methodInvoker.sendMessage();                                                                                // 745
                                                                                                                  // 746
    // If we're using the default callback on the server,                                                         // 747
    // block waiting for the result.                                                                              // 748
    if (future) {                                                                                                 // 749
      return future.wait();                                                                                       // 750
    }                                                                                                             // 751
    return undefined;                                                                                             // 752
  },                                                                                                              // 753
                                                                                                                  // 754
  // Before calling a method stub, prepare all stores to track changes and allow                                  // 755
  // _retrieveAndStoreOriginals to get the original versions of changed                                           // 756
  // documents.                                                                                                   // 757
  _saveOriginals: function () {                                                                                   // 758
    var self = this;                                                                                              // 759
    _.each(self._stores, function (s) {                                                                           // 760
      s.saveOriginals();                                                                                          // 761
    });                                                                                                           // 762
  },                                                                                                              // 763
  // Retrieves the original versions of all documents modified by the stub for                                    // 764
  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                  // 765
  // by document) and _documentsWrittenByStub (keyed by method ID).                                               // 766
  _retrieveAndStoreOriginals: function (methodId) {                                                               // 767
    var self = this;                                                                                              // 768
    if (self._documentsWrittenByStub[methodId])                                                                   // 769
      throw new Error("Duplicate methodId in _retrieveAndStoreOriginals");                                        // 770
                                                                                                                  // 771
    var docsWritten = [];                                                                                         // 772
    _.each(self._stores, function (s, collection) {                                                               // 773
      var originals = s.retrieveOriginals();                                                                      // 774
      _.each(originals, function (doc, id) {                                                                      // 775
        if (typeof id !== 'string')                                                                               // 776
          throw new Error("id is not a string");                                                                  // 777
        docsWritten.push({collection: collection, id: id});                                                       // 778
        var serverDoc = Meteor._ensure(self._serverDocuments, collection, id);                                    // 779
        if (serverDoc.writtenByStubs) {                                                                           // 780
          // We're not the first stub to write this doc. Just add our method ID                                   // 781
          // to the record.                                                                                       // 782
          serverDoc.writtenByStubs[methodId] = true;                                                              // 783
        } else {                                                                                                  // 784
          // First stub! Save the original value and our method ID.                                               // 785
          serverDoc.document = doc;                                                                               // 786
          serverDoc.flushCallbacks = [];                                                                          // 787
          serverDoc.writtenByStubs = {};                                                                          // 788
          serverDoc.writtenByStubs[methodId] = true;                                                              // 789
        }                                                                                                         // 790
      });                                                                                                         // 791
    });                                                                                                           // 792
    if (!_.isEmpty(docsWritten)) {                                                                                // 793
      self._documentsWrittenByStub[methodId] = docsWritten;                                                       // 794
    }                                                                                                             // 795
  },                                                                                                              // 796
                                                                                                                  // 797
  // This is very much a private function we use to make the tests                                                // 798
  // take up fewer server resources after they complete.                                                          // 799
  _unsubscribeAll: function () {                                                                                  // 800
    var self = this;                                                                                              // 801
    _.each(_.clone(self._subscriptions), function (sub, id) {                                                     // 802
      self._send({msg: 'unsub', id: id});                                                                         // 803
      delete self._subscriptions[id];                                                                             // 804
    });                                                                                                           // 805
  },                                                                                                              // 806
                                                                                                                  // 807
  // Sends the DDP stringification of the given message object                                                    // 808
  _send: function (obj) {                                                                                         // 809
    var self = this;                                                                                              // 810
    self._stream.send(stringifyDDP(obj));                                                                         // 811
  },                                                                                                              // 812
                                                                                                                  // 813
  status: function (/*passthrough args*/) {                                                                       // 814
    var self = this;                                                                                              // 815
    return self._stream.status.apply(self._stream, arguments);                                                    // 816
  },                                                                                                              // 817
                                                                                                                  // 818
  reconnect: function (/*passthrough args*/) {                                                                    // 819
    var self = this;                                                                                              // 820
    return self._stream.reconnect.apply(self._stream, arguments);                                                 // 821
  },                                                                                                              // 822
                                                                                                                  // 823
  disconnect: function (/*passthrough args*/) {                                                                   // 824
    var self = this;                                                                                              // 825
    return self._stream.disconnect.apply(self._stream, arguments);                                                // 826
  },                                                                                                              // 827
                                                                                                                  // 828
  close: function () {                                                                                            // 829
    var self = this;                                                                                              // 830
    return self._stream.disconnect({_permanent: true});                                                           // 831
  },                                                                                                              // 832
                                                                                                                  // 833
  ///                                                                                                             // 834
  /// Reactive user system                                                                                        // 835
  ///                                                                                                             // 836
  userId: function () {                                                                                           // 837
    var self = this;                                                                                              // 838
    if (self._userIdDeps)                                                                                         // 839
      self._userIdDeps.depend();                                                                                  // 840
    return self._userId;                                                                                          // 841
  },                                                                                                              // 842
                                                                                                                  // 843
  setUserId: function (userId) {                                                                                  // 844
    var self = this;                                                                                              // 845
    // Avoid invalidating dependents if setUserId is called with current value.                                   // 846
    if (self._userId === userId)                                                                                  // 847
      return;                                                                                                     // 848
    self._userId = userId;                                                                                        // 849
    if (self._userIdDeps)                                                                                         // 850
      self._userIdDeps.changed();                                                                                 // 851
  },                                                                                                              // 852
                                                                                                                  // 853
  // Returns true if we are in a state after reconnect of waiting for subs to be                                  // 854
  // revived or early methods to finish their data, or we are waiting for a                                       // 855
  // "wait" method to finish.                                                                                     // 856
  _waitingForQuiescence: function () {                                                                            // 857
    var self = this;                                                                                              // 858
    return (! _.isEmpty(self._subsBeingRevived) ||                                                                // 859
            ! _.isEmpty(self._methodsBlockingQuiescence));                                                        // 860
  },                                                                                                              // 861
                                                                                                                  // 862
  // Returns true if any method whose message has been sent to the server has                                     // 863
  // not yet invoked its user callback.                                                                           // 864
  _anyMethodsAreOutstanding: function () {                                                                        // 865
    var self = this;                                                                                              // 866
    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                   // 867
  },                                                                                                              // 868
                                                                                                                  // 869
  _livedata_connected: function (msg) {                                                                           // 870
    var self = this;                                                                                              // 871
                                                                                                                  // 872
    // If this is a reconnect, we'll have to reset all stores.                                                    // 873
    if (self._lastSessionId)                                                                                      // 874
      self._resetStores = true;                                                                                   // 875
                                                                                                                  // 876
    if (typeof (msg.session) === "string") {                                                                      // 877
      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);                                   // 878
      self._lastSessionId = msg.session;                                                                          // 879
    }                                                                                                             // 880
                                                                                                                  // 881
    if (reconnectedToPreviousSession) {                                                                           // 882
      // Successful reconnection -- pick up where we left off.  Note that right                                   // 883
      // now, this never happens: the server never connects us to a previous                                      // 884
      // session, because DDP doesn't provide enough data for the server to know                                  // 885
      // what messages the client has processed. We need to improve DDP to make                                   // 886
      // this possible, at which point we'll probably need more code here.                                        // 887
      return;                                                                                                     // 888
    }                                                                                                             // 889
                                                                                                                  // 890
    // Server doesn't have our data any more. Re-sync a new session.                                              // 891
                                                                                                                  // 892
    // Forget about messages we were buffering for unknown collections. They'll                                   // 893
    // be resent if still relevant.                                                                               // 894
    self._updatesForUnknownStores = {};                                                                           // 895
                                                                                                                  // 896
    if (self._resetStores) {                                                                                      // 897
      // Forget about the effects of stubs. We'll be resetting all collections                                    // 898
      // anyway.                                                                                                  // 899
      self._documentsWrittenByStub = {};                                                                          // 900
      self._serverDocuments = {};                                                                                 // 901
    }                                                                                                             // 902
                                                                                                                  // 903
    // Clear _afterUpdateCallbacks.                                                                               // 904
    self._afterUpdateCallbacks = [];                                                                              // 905
                                                                                                                  // 906
    // Mark all named subscriptions which are ready (ie, we already called the                                    // 907
    // ready callback) as needing to be revived.                                                                  // 908
    // XXX We should also block reconnect quiescence until unnamed subscriptions                                  // 909
    //     (eg, autopublish) are done re-publishing to avoid flicker!                                             // 910
    self._subsBeingRevived = {};                                                                                  // 911
    _.each(self._subscriptions, function (sub, id) {                                                              // 912
      if (sub.ready)                                                                                              // 913
        self._subsBeingRevived[id] = true;                                                                        // 914
    });                                                                                                           // 915
                                                                                                                  // 916
    // Arrange for "half-finished" methods to have their callbacks run, and                                       // 917
    // track methods that were sent on this connection so that we don't                                           // 918
    // quiesce until they are all done.                                                                           // 919
    //                                                                                                            // 920
    // Start by clearing _methodsBlockingQuiescence: methods sent before                                          // 921
    // reconnect don't matter, and any "wait" methods sent on the new connection                                  // 922
    // that we drop here will be restored by the loop below.                                                      // 923
    self._methodsBlockingQuiescence = {};                                                                         // 924
    if (self._resetStores) {                                                                                      // 925
      _.each(self._methodInvokers, function (invoker) {                                                           // 926
        if (invoker.gotResult()) {                                                                                // 927
          // This method already got its result, but it didn't call its callback                                  // 928
          // because its data didn't become visible. We did not resend the                                        // 929
          // method RPC. We'll call its callback when we get a full quiesce,                                      // 930
          // since that's as close as we'll get to "data must be visible".                                        // 931
          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                  // 932
        } else if (invoker.sentMessage) {                                                                         // 933
          // This method has been sent on this connection (maybe as a resend                                      // 934
          // from the last connection, maybe from onReconnect, maybe just very                                    // 935
          // quickly before processing the connected message).                                                    // 936
          //                                                                                                      // 937
          // We don't need to do anything special to ensure its callbacks get                                     // 938
          // called, but we'll count it as a method which is preventing                                           // 939
          // reconnect quiescence. (eg, it might be a login method that was run                                   // 940
          // from onReconnect, and we don't want to see flicker by seeing a                                       // 941
          // logged-out state.)                                                                                   // 942
          self._methodsBlockingQuiescence[invoker.methodId] = true;                                               // 943
        }                                                                                                         // 944
      });                                                                                                         // 945
    }                                                                                                             // 946
                                                                                                                  // 947
    self._messagesBufferedUntilQuiescence = [];                                                                   // 948
                                                                                                                  // 949
    // If we're not waiting on any methods or subs, we can reset the stores and                                   // 950
    // call the callbacks immediately.                                                                            // 951
    if (!self._waitingForQuiescence()) {                                                                          // 952
      if (self._resetStores) {                                                                                    // 953
        _.each(self._stores, function (s) {                                                                       // 954
          s.beginUpdate(0, true);                                                                                 // 955
          s.endUpdate();                                                                                          // 956
        });                                                                                                       // 957
        self._resetStores = false;                                                                                // 958
      }                                                                                                           // 959
      self._runAfterUpdateCallbacks();                                                                            // 960
    }                                                                                                             // 961
  },                                                                                                              // 962
                                                                                                                  // 963
                                                                                                                  // 964
  _processOneDataMessage: function (msg, updates) {                                                               // 965
    var self = this;                                                                                              // 966
    // Using underscore here so as not to need to capitalize.                                                     // 967
    self['_process_' + msg.msg](msg, updates);                                                                    // 968
  },                                                                                                              // 969
                                                                                                                  // 970
                                                                                                                  // 971
  _livedata_data: function (msg) {                                                                                // 972
    var self = this;                                                                                              // 973
                                                                                                                  // 974
    // collection name -> array of messages                                                                       // 975
    var updates = {};                                                                                             // 976
                                                                                                                  // 977
    if (self._waitingForQuiescence()) {                                                                           // 978
      self._messagesBufferedUntilQuiescence.push(msg);                                                            // 979
                                                                                                                  // 980
      if (msg.msg === "nosub")                                                                                    // 981
        delete self._subsBeingRevived[msg.id];                                                                    // 982
                                                                                                                  // 983
      _.each(msg.subs || [], function (subId) {                                                                   // 984
        delete self._subsBeingRevived[subId];                                                                     // 985
      });                                                                                                         // 986
      _.each(msg.methods || [], function (methodId) {                                                             // 987
        delete self._methodsBlockingQuiescence[methodId];                                                         // 988
      });                                                                                                         // 989
                                                                                                                  // 990
      if (self._waitingForQuiescence())                                                                           // 991
        return;                                                                                                   // 992
                                                                                                                  // 993
      // No methods or subs are blocking quiescence!                                                              // 994
      // We'll now process and all of our buffered messages, reset all stores,                                    // 995
      // and apply them all at once.                                                                              // 996
      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                      // 997
        self._processOneDataMessage(bufferedMsg, updates);                                                        // 998
      });                                                                                                         // 999
      self._messagesBufferedUntilQuiescence = [];                                                                 // 1000
    } else {                                                                                                      // 1001
      self._processOneDataMessage(msg, updates);                                                                  // 1002
    }                                                                                                             // 1003
                                                                                                                  // 1004
    if (self._resetStores || !_.isEmpty(updates)) {                                                               // 1005
      // Begin a transactional update of each store.                                                              // 1006
      _.each(self._stores, function (s, storeName) {                                                              // 1007
        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,                                  // 1008
                      self._resetStores);                                                                         // 1009
      });                                                                                                         // 1010
      self._resetStores = false;                                                                                  // 1011
                                                                                                                  // 1012
      _.each(updates, function (updateMessages, storeName) {                                                      // 1013
        var store = self._stores[storeName];                                                                      // 1014
        if (store) {                                                                                              // 1015
          _.each(updateMessages, function (updateMessage) {                                                       // 1016
            store.update(updateMessage);                                                                          // 1017
          });                                                                                                     // 1018
        } else {                                                                                                  // 1019
          // Nobody's listening for this data. Queue it up until                                                  // 1020
          // someone wants it.                                                                                    // 1021
          // XXX memory use will grow without bound if you forget to                                              // 1022
          // create a collection or just don't care about it... going                                             // 1023
          // to have to do something about that.                                                                  // 1024
          if (!_.has(self._updatesForUnknownStores, storeName))                                                   // 1025
            self._updatesForUnknownStores[storeName] = [];                                                        // 1026
          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],                                    // 1027
                                     updateMessages);                                                             // 1028
        }                                                                                                         // 1029
      });                                                                                                         // 1030
                                                                                                                  // 1031
      // End update transaction.                                                                                  // 1032
      _.each(self._stores, function (s) { s.endUpdate(); });                                                      // 1033
    }                                                                                                             // 1034
                                                                                                                  // 1035
    self._runAfterUpdateCallbacks();                                                                              // 1036
  },                                                                                                              // 1037
                                                                                                                  // 1038
  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                       // 1039
  // relevant docs have been flushed, as well as dataVisible callbacks at                                         // 1040
  // reconnect-quiescence time.                                                                                   // 1041
  _runAfterUpdateCallbacks: function () {                                                                         // 1042
    var self = this;                                                                                              // 1043
    var callbacks = self._afterUpdateCallbacks;                                                                   // 1044
    self._afterUpdateCallbacks = [];                                                                              // 1045
    _.each(callbacks, function (c) {                                                                              // 1046
      c();                                                                                                        // 1047
    });                                                                                                           // 1048
  },                                                                                                              // 1049
                                                                                                                  // 1050
  _pushUpdate: function (updates, collection, msg) {                                                              // 1051
    var self = this;                                                                                              // 1052
    if (!_.has(updates, collection)) {                                                                            // 1053
      updates[collection] = [];                                                                                   // 1054
    }                                                                                                             // 1055
    updates[collection].push(msg);                                                                                // 1056
  },                                                                                                              // 1057
                                                                                                                  // 1058
  _process_added: function (msg, updates) {                                                                       // 1059
    var self = this;                                                                                              // 1060
    var serverDoc = Meteor._get(self._serverDocuments, msg.collection, msg.id);                                   // 1061
    if (serverDoc) {                                                                                              // 1062
      // Some outstanding stub wrote here.                                                                        // 1063
      if (serverDoc.document !== undefined) {                                                                     // 1064
        throw new Error("It doesn't make sense to be adding something we know exists: "                           // 1065
                        + msg.id);                                                                                // 1066
      }                                                                                                           // 1067
      serverDoc.document = msg.fields || {};                                                                      // 1068
      serverDoc.document._id = LocalCollection._idParse(msg.id);                                                  // 1069
    } else {                                                                                                      // 1070
      self._pushUpdate(updates, msg.collection, msg);                                                             // 1071
    }                                                                                                             // 1072
  },                                                                                                              // 1073
                                                                                                                  // 1074
  _process_changed: function (msg, updates) {                                                                     // 1075
    var self = this;                                                                                              // 1076
    var serverDoc = Meteor._get(self._serverDocuments, msg.collection, msg.id);                                   // 1077
    if (serverDoc) {                                                                                              // 1078
      if (serverDoc.document === undefined) {                                                                     // 1079
        throw new Error("It doesn't make sense to be changing something we don't think exists: "                  // 1080
                        + msg.id);                                                                                // 1081
      }                                                                                                           // 1082
      LocalCollection._applyChanges(serverDoc.document, msg.fields);                                              // 1083
    } else {                                                                                                      // 1084
      self._pushUpdate(updates, msg.collection, msg);                                                             // 1085
    }                                                                                                             // 1086
  },                                                                                                              // 1087
                                                                                                                  // 1088
  _process_removed: function (msg, updates) {                                                                     // 1089
    var self = this;                                                                                              // 1090
    var serverDoc = Meteor._get(                                                                                  // 1091
      self._serverDocuments, msg.collection, msg.id);                                                             // 1092
    if (serverDoc) {                                                                                              // 1093
      // Some outstanding stub wrote here.                                                                        // 1094
      if (serverDoc.document === undefined) {                                                                     // 1095
        throw new Error("It doesn't make sense to be deleting something we don't know exists: "                   // 1096
                        + msg.id);                                                                                // 1097
      }                                                                                                           // 1098
      serverDoc.document = undefined;                                                                             // 1099
    } else {                                                                                                      // 1100
      self._pushUpdate(updates, msg.collection, {                                                                 // 1101
        msg: 'removed',                                                                                           // 1102
        collection: msg.collection,                                                                               // 1103
        id: msg.id                                                                                                // 1104
      });                                                                                                         // 1105
    }                                                                                                             // 1106
  },                                                                                                              // 1107
                                                                                                                  // 1108
  _process_updated: function (msg, updates) {                                                                     // 1109
    var self = this;                                                                                              // 1110
    // Process "method done" messages.                                                                            // 1111
    _.each(msg.methods, function (methodId) {                                                                     // 1112
      _.each(self._documentsWrittenByStub[methodId], function (written) {                                         // 1113
        var serverDoc = Meteor._get(self._serverDocuments,                                                        // 1114
                                    written.collection, written.id);                                              // 1115
        if (!serverDoc)                                                                                           // 1116
          throw new Error("Lost serverDoc for " + JSON.stringify(written));                                       // 1117
        if (!serverDoc.writtenByStubs[methodId])                                                                  // 1118
          throw new Error("Doc " + JSON.stringify(written) +                                                      // 1119
                          " not written by  method " + methodId);                                                 // 1120
        delete serverDoc.writtenByStubs[methodId];                                                                // 1121
        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                // 1122
          // All methods whose stubs wrote this method have completed! We can                                     // 1123
          // now copy the saved document to the database (reverting the stub's                                    // 1124
          // change if the server did not write to this object, or applying the                                   // 1125
          // server's writes if it did).                                                                          // 1126
                                                                                                                  // 1127
          // This is a fake ddp 'replace' message.  It's just for talking between                                 // 1128
          // livedata connections and minimongo.                                                                  // 1129
          self._pushUpdate(updates, written.collection, {                                                         // 1130
            msg: 'replace',                                                                                       // 1131
            id: written.id,                                                                                       // 1132
            replace: serverDoc.document                                                                           // 1133
          });                                                                                                     // 1134
          // Call all flush callbacks.                                                                            // 1135
          _.each(serverDoc.flushCallbacks, function (c) {                                                         // 1136
            c();                                                                                                  // 1137
          });                                                                                                     // 1138
                                                                                                                  // 1139
          // Delete this completed serverDocument. Don't bother to GC empty                                       // 1140
          // objects inside self._serverDocuments, since there probably aren't                                    // 1141
          // many collections and they'll be written repeatedly.                                                  // 1142
          delete self._serverDocuments[written.collection][written.id];                                           // 1143
        }                                                                                                         // 1144
      });                                                                                                         // 1145
      delete self._documentsWrittenByStub[methodId];                                                              // 1146
                                                                                                                  // 1147
      // We want to call the data-written callback, but we can't do so until all                                  // 1148
      // currently buffered messages are flushed.                                                                 // 1149
      var callbackInvoker = self._methodInvokers[methodId];                                                       // 1150
      if (!callbackInvoker)                                                                                       // 1151
        throw new Error("No callback invoker for method " + methodId);                                            // 1152
      self._runWhenAllServerDocsAreFlushed(                                                                       // 1153
        _.bind(callbackInvoker.dataVisible, callbackInvoker));                                                    // 1154
    });                                                                                                           // 1155
  },                                                                                                              // 1156
                                                                                                                  // 1157
  _process_ready: function (msg, updates) {                                                                       // 1158
    var self = this;                                                                                              // 1159
    // Process "sub ready" messages. "sub ready" messages don't take effect                                       // 1160
    // until all current server documents have been flushed to the local                                          // 1161
    // database. We can use a write fence to implement this.                                                      // 1162
    _.each(msg.subs, function (subId) {                                                                           // 1163
      self._runWhenAllServerDocsAreFlushed(function () {                                                          // 1164
        var subRecord = self._subscriptions[subId];                                                               // 1165
        // Did we already unsubscribe?                                                                            // 1166
        if (!subRecord)                                                                                           // 1167
          return;                                                                                                 // 1168
        // Did we already receive a ready message? (Oops!)                                                        // 1169
        if (subRecord.ready)                                                                                      // 1170
          return;                                                                                                 // 1171
        subRecord.readyCallback && subRecord.readyCallback();                                                     // 1172
        subRecord.ready = true;                                                                                   // 1173
        subRecord.readyDeps && subRecord.readyDeps.changed();                                                     // 1174
      });                                                                                                         // 1175
    });                                                                                                           // 1176
  },                                                                                                              // 1177
                                                                                                                  // 1178
  // Ensures that "f" will be called after all documents currently in                                             // 1179
  // _serverDocuments have been written to the local cache. f will not be called                                  // 1180
  // if the connection is lost before then!                                                                       // 1181
  _runWhenAllServerDocsAreFlushed: function (f) {                                                                 // 1182
    var self = this;                                                                                              // 1183
    var runFAfterUpdates = function () {                                                                          // 1184
      self._afterUpdateCallbacks.push(f);                                                                         // 1185
    };                                                                                                            // 1186
    var unflushedServerDocCount = 0;                                                                              // 1187
    var onServerDocFlush = function () {                                                                          // 1188
      --unflushedServerDocCount;                                                                                  // 1189
      if (unflushedServerDocCount === 0) {                                                                        // 1190
        // This was the last doc to flush! Arrange to run f after the updates                                     // 1191
        // have been applied.                                                                                     // 1192
        runFAfterUpdates();                                                                                       // 1193
      }                                                                                                           // 1194
    };                                                                                                            // 1195
    _.each(self._serverDocuments, function (collectionDocs) {                                                     // 1196
      _.each(collectionDocs, function (serverDoc) {                                                               // 1197
        var writtenByStubForAMethodWithSentMessage = _.any(                                                       // 1198
          serverDoc.writtenByStubs, function (dummy, methodId) {                                                  // 1199
            var invoker = self._methodInvokers[methodId];                                                         // 1200
            return invoker && invoker.sentMessage;                                                                // 1201
          });                                                                                                     // 1202
        if (writtenByStubForAMethodWithSentMessage) {                                                             // 1203
          ++unflushedServerDocCount;                                                                              // 1204
          serverDoc.flushCallbacks.push(onServerDocFlush);                                                        // 1205
        }                                                                                                         // 1206
      });                                                                                                         // 1207
    });                                                                                                           // 1208
    if (unflushedServerDocCount === 0) {                                                                          // 1209
      // There aren't any buffered docs --- we can call f as soon as the current                                  // 1210
      // round of updates is applied!                                                                             // 1211
      runFAfterUpdates();                                                                                         // 1212
    }                                                                                                             // 1213
  },                                                                                                              // 1214
                                                                                                                  // 1215
  _livedata_nosub: function (msg) {                                                                               // 1216
    var self = this;                                                                                              // 1217
                                                                                                                  // 1218
    // First pass it through _livedata_data, which only uses it to help get                                       // 1219
    // towards quiescence.                                                                                        // 1220
    self._livedata_data(msg);                                                                                     // 1221
                                                                                                                  // 1222
    // Do the rest of our processing immediately, with no                                                         // 1223
    // buffering-until-quiescence.                                                                                // 1224
                                                                                                                  // 1225
    // we weren't subbed anyway, or we initiated the unsub.                                                       // 1226
    if (!_.has(self._subscriptions, msg.id))                                                                      // 1227
      return;                                                                                                     // 1228
    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                // 1229
    delete self._subscriptions[msg.id];                                                                           // 1230
    if (errorCallback && msg.error) {                                                                             // 1231
      errorCallback(new Meteor.Error(                                                                             // 1232
        msg.error.error, msg.error.reason, msg.error.details));                                                   // 1233
    }                                                                                                             // 1234
  },                                                                                                              // 1235
                                                                                                                  // 1236
  _process_nosub: function () {                                                                                   // 1237
    // This is called as part of the "buffer until quiescence" process, but                                       // 1238
    // nosub's effect is always immediate. It only goes in the buffer at all                                      // 1239
    // because it's possible for a nosub to be the thing that triggers                                            // 1240
    // quiescence, if we were waiting for a sub to be revived and it dies                                         // 1241
    // instead.                                                                                                   // 1242
  },                                                                                                              // 1243
                                                                                                                  // 1244
  _livedata_result: function (msg) {                                                                              // 1245
    // id, result or error. error has error (code), reason, details                                               // 1246
                                                                                                                  // 1247
    var self = this;                                                                                              // 1248
                                                                                                                  // 1249
    // find the outstanding request                                                                               // 1250
    // should be O(1) in nearly all realistic use cases                                                           // 1251
    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                               // 1252
      Meteor._debug("Received method result but no methods outstanding");                                         // 1253
      return;                                                                                                     // 1254
    }                                                                                                             // 1255
    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                            // 1256
    var m;                                                                                                        // 1257
    for (var i = 0; i < currentMethodBlock.length; i++) {                                                         // 1258
      m = currentMethodBlock[i];                                                                                  // 1259
      if (m.methodId === msg.id)                                                                                  // 1260
        break;                                                                                                    // 1261
    }                                                                                                             // 1262
                                                                                                                  // 1263
    if (!m) {                                                                                                     // 1264
      Meteor._debug("Can't match method response to original method call", msg);                                  // 1265
      return;                                                                                                     // 1266
    }                                                                                                             // 1267
                                                                                                                  // 1268
    // Remove from current method block. This may leave the block empty, but we                                   // 1269
    // don't move on to the next block until the callback has been delivered, in                                  // 1270
    // _outstandingMethodFinished.                                                                                // 1271
    currentMethodBlock.splice(i, 1);                                                                              // 1272
                                                                                                                  // 1273
    if (_.has(msg, 'error')) {                                                                                    // 1274
      m.receiveResult(new Meteor.Error(                                                                           // 1275
        msg.error.error, msg.error.reason,                                                                        // 1276
        msg.error.details));                                                                                      // 1277
    } else {                                                                                                      // 1278
      // msg.result may be undefined if the method didn't return a                                                // 1279
      // value                                                                                                    // 1280
      m.receiveResult(undefined, msg.result);                                                                     // 1281
    }                                                                                                             // 1282
  },                                                                                                              // 1283
                                                                                                                  // 1284
  // Called by MethodInvoker after a method's callback is invoked.  If this was                                   // 1285
  // the last outstanding method in the current block, runs the next block. If                                    // 1286
  // there are no more methods, consider accepting a hot code push.                                               // 1287
  _outstandingMethodFinished: function () {                                                                       // 1288
    var self = this;                                                                                              // 1289
    if (self._anyMethodsAreOutstanding())                                                                         // 1290
      return;                                                                                                     // 1291
                                                                                                                  // 1292
    // No methods are outstanding. This should mean that the first block of                                       // 1293
    // methods is empty. (Or it might not exist, if this was a method that                                        // 1294
    // half-finished before disconnect/reconnect.)                                                                // 1295
    if (! _.isEmpty(self._outstandingMethodBlocks)) {                                                             // 1296
      var firstBlock = self._outstandingMethodBlocks.shift();                                                     // 1297
      if (! _.isEmpty(firstBlock.methods))                                                                        // 1298
        throw new Error("No methods outstanding but nonempty block: " +                                           // 1299
                        JSON.stringify(firstBlock));                                                              // 1300
                                                                                                                  // 1301
      // Send the outstanding methods now in the first block.                                                     // 1302
      if (!_.isEmpty(self._outstandingMethodBlocks))                                                              // 1303
        self._sendOutstandingMethods();                                                                           // 1304
    }                                                                                                             // 1305
                                                                                                                  // 1306
    // Maybe accept a hot code push.                                                                              // 1307
    self._maybeMigrate();                                                                                         // 1308
  },                                                                                                              // 1309
                                                                                                                  // 1310
  // Sends messages for all the methods in the first block in                                                     // 1311
  // _outstandingMethodBlocks.                                                                                    // 1312
  _sendOutstandingMethods: function() {                                                                           // 1313
    var self = this;                                                                                              // 1314
    if (_.isEmpty(self._outstandingMethodBlocks))                                                                 // 1315
      return;                                                                                                     // 1316
    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                               // 1317
      m.sendMessage();                                                                                            // 1318
    });                                                                                                           // 1319
  },                                                                                                              // 1320
                                                                                                                  // 1321
  _livedata_error: function (msg) {                                                                               // 1322
    Meteor._debug("Received error from server: ", msg.reason);                                                    // 1323
    if (msg.offendingMessage)                                                                                     // 1324
      Meteor._debug("For: ", msg.offendingMessage);                                                               // 1325
  },                                                                                                              // 1326
                                                                                                                  // 1327
  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {                                              // 1328
    var self = this;                                                                                              // 1329
    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                               // 1330
    self._outstandingMethodBlocks = [];                                                                           // 1331
                                                                                                                  // 1332
    self.onReconnect();                                                                                           // 1333
                                                                                                                  // 1334
    if (_.isEmpty(oldOutstandingMethodBlocks))                                                                    // 1335
      return;                                                                                                     // 1336
                                                                                                                  // 1337
    // We have at least one block worth of old outstanding methods to try                                         // 1338
    // again. First: did onReconnect actually send anything? If not, we just                                      // 1339
    // restore all outstanding methods and run the first block.                                                   // 1340
    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                               // 1341
      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                 // 1342
      self._sendOutstandingMethods();                                                                             // 1343
      return;                                                                                                     // 1344
    }                                                                                                             // 1345
                                                                                                                  // 1346
    // OK, there are blocks on both sides. Special case: merge the last block of                                  // 1347
    // the reconnect methods with the first block of the original methods, if                                     // 1348
    // neither of them are "wait" blocks.                                                                         // 1349
    if (!_.last(self._outstandingMethodBlocks).wait &&                                                            // 1350
        !oldOutstandingMethodBlocks[0].wait) {                                                                    // 1351
      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                // 1352
        _.last(self._outstandingMethodBlocks).methods.push(m);                                                    // 1353
                                                                                                                  // 1354
        // If this "last block" is also the first block, send the message.                                        // 1355
        if (self._outstandingMethodBlocks.length === 1)                                                           // 1356
          m.sendMessage();                                                                                        // 1357
      });                                                                                                         // 1358
                                                                                                                  // 1359
      oldOutstandingMethodBlocks.shift();                                                                         // 1360
    }                                                                                                             // 1361
                                                                                                                  // 1362
    // Now add the rest of the original blocks on.                                                                // 1363
    _.each(oldOutstandingMethodBlocks, function (block) {                                                         // 1364
      self._outstandingMethodBlocks.push(block);                                                                  // 1365
    });                                                                                                           // 1366
  },                                                                                                              // 1367
                                                                                                                  // 1368
  // We can accept a hot code push if there are no methods in flight.                                             // 1369
  _readyToMigrate: function() {                                                                                   // 1370
    var self = this;                                                                                              // 1371
    return _.isEmpty(self._methodInvokers);                                                                       // 1372
  },                                                                                                              // 1373
                                                                                                                  // 1374
  // If we were blocking a migration, see if it's now possible to continue.                                       // 1375
  // Call whenever the set of outstanding/blocked methods shrinks.                                                // 1376
  _maybeMigrate: function () {                                                                                    // 1377
    var self = this;                                                                                              // 1378
    if (self._retryMigrate && self._readyToMigrate()) {                                                           // 1379
      self._retryMigrate();                                                                                       // 1380
      self._retryMigrate = null;                                                                                  // 1381
    }                                                                                                             // 1382
  }                                                                                                               // 1383
});                                                                                                               // 1384
                                                                                                                  // 1385
LivedataTest.Connection = Connection;                                                                             // 1386
                                                                                                                  // 1387
// @param url {String} URL to Meteor app,                                                                         // 1388
//     e.g.:                                                                                                      // 1389
//     "subdomain.meteor.com",                                                                                    // 1390
//     "http://subdomain.meteor.com",                                                                             // 1391
//     "/",                                                                                                       // 1392
//     "ddp+sockjs://ddp--****-foo.meteor.com/sockjs"                                                             // 1393
//                                                                                                                // 1394
DDP.connect = function (url, _reloadOnUpdate) {                                                                   // 1395
  var ret = new Connection(                                                                                       // 1396
    url, {reloadOnUpdate: _reloadOnUpdate});                                                                      // 1397
  allConnections.push(ret); // hack. see below.                                                                   // 1398
  return ret;                                                                                                     // 1399
};                                                                                                                // 1400
                                                                                                                  // 1401
// Hack for `spiderable` package: a way to see if the page is done                                                // 1402
// loading all the data it needs.                                                                                 // 1403
//                                                                                                                // 1404
allConnections = [];                                                                                              // 1405
DDP._allSubscriptionsReady = function () {                                                                        // 1406
  return _.all(allConnections, function (conn) {                                                                  // 1407
    return _.all(conn._subscriptions, function (sub) {                                                            // 1408
      return sub.ready;                                                                                           // 1409
    });                                                                                                           // 1410
  });                                                                                                             // 1411
};                                                                                                                // 1412
                                                                                                                  // 1413
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                //
// packages/livedata/client_convenience.js                                                                        //
//                                                                                                                //
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                  //
// Meteor.refresh can be called on the client (if you're in common code) but it                                   // 1
// only has an effect on the server.                                                                              // 2
Meteor.refresh = function (notification) {                                                                        // 3
};                                                                                                                // 4
                                                                                                                  // 5
if (Meteor.isClient) {                                                                                            // 6
  // By default, try to connect back to the same endpoint as the page                                             // 7
  // was served from.                                                                                             // 8
  var ddpUrl = '/';                                                                                               // 9
  if (typeof __meteor_runtime_config__ !== "undefined") {                                                         // 10
    if (__meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL)                                                     // 11
      ddpUrl = __meteor_runtime_config__.DDP_DEFAULT_CONNECTION_URL;                                              // 12
  }                                                                                                               // 13
  Meteor.connection =                                                                                             // 14
    DDP.connect(ddpUrl, true /* restart_on_update */);                                                            // 15
                                                                                                                  // 16
  // Proxy the public methods of Meteor.connection so they can                                                    // 17
  // be called directly on Meteor.                                                                                // 18
  _.each(['subscribe', 'methods', 'call', 'apply', 'status', 'reconnect',                                         // 19
          'disconnect'],                                                                                          // 20
         function (name) {                                                                                        // 21
           Meteor[name] = _.bind(Meteor.connection[name], Meteor.connection);                                     // 22
         });                                                                                                      // 23
} else {                                                                                                          // 24
  // Never set up a default connection on the server. Don't even map                                              // 25
  // subscribe/call/etc onto Meteor.                                                                              // 26
  Meteor.connection = null;                                                                                       // 27
}                                                                                                                 // 28
                                                                                                                  // 29
// Meteor.connection used to be called                                                                            // 30
// Meteor.default_connection. Provide backcompat as a courtesy even                                               // 31
// though it was never documented.                                                                                // 32
// XXX COMPAT WITH 0.6.4                                                                                          // 33
Meteor.default_connection = Meteor.connection;                                                                    // 34
                                                                                                                  // 35
// We should transition from Meteor.connect to DDP.connect.                                                       // 36
// XXX COMPAT WITH 0.6.4                                                                                          // 37
Meteor.connect = DDP.connect;                                                                                     // 38
                                                                                                                  // 39
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.livedata = {
  DDP: DDP,
  LivedataTest: LivedataTest
};

})();

//# sourceMappingURL=15a15ecf503c2ac7d5b2a0df56aa8553b761d984.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var JSON = Package.json.JSON;
var _ = Package.underscore._;
var LocalCollection = Package.minimongo.LocalCollection;
var DDP = Package.livedata.DDP;
var Deps = Package.deps.Deps;
var check = Package.check.check;
var Match = Package.check.Match;

/* Package-scope variables */
var LocalCollectionDriver;

(function () {

///////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                           //
// packages/mongo-livedata/local_collection_driver.js                                        //
//                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////
                                                                                             //
LocalCollectionDriver = function () {                                                        // 1
  var self = this;                                                                           // 2
  self.noConnCollections = {};                                                               // 3
};                                                                                           // 4
                                                                                             // 5
var ensureCollection = function (name, collections) {                                        // 6
  if (!(name in collections))                                                                // 7
    collections[name] = new LocalCollection(name);                                           // 8
  return collections[name];                                                                  // 9
};                                                                                           // 10
                                                                                             // 11
_.extend(LocalCollectionDriver.prototype, {                                                  // 12
  open: function (name, conn) {                                                              // 13
    var self = this;                                                                         // 14
    if (!name)                                                                               // 15
      return new LocalCollection;                                                            // 16
    if (! conn) {                                                                            // 17
      return ensureCollection(name, self.noConnCollections);                                 // 18
    }                                                                                        // 19
    if (! conn._mongo_livedata_collections)                                                  // 20
      conn._mongo_livedata_collections = {};                                                 // 21
    // XXX is there a way to keep track of a connection's collections without                // 22
    // dangling it off the connection object?                                                // 23
    return ensureCollection(name, conn._mongo_livedata_collections);                         // 24
  }                                                                                          // 25
});                                                                                          // 26
                                                                                             // 27
// singleton                                                                                 // 28
LocalCollectionDriver = new LocalCollectionDriver;                                           // 29
                                                                                             // 30
///////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

///////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                           //
// packages/mongo-livedata/collection.js                                                     //
//                                                                                           //
///////////////////////////////////////////////////////////////////////////////////////////////
                                                                                             //
// options.connection, if given, is a LivedataClient or LivedataServer                       // 1
// XXX presently there is no way to destroy/clean up a Collection                            // 2
                                                                                             // 3
Meteor.Collection = function (name, options) {                                               // 4
  var self = this;                                                                           // 5
  if (! (self instanceof Meteor.Collection))                                                 // 6
    throw new Error('use "new" to construct a Meteor.Collection');                           // 7
  if (options && options.methods) {                                                          // 8
    // Backwards compatibility hack with original signature (which passed                    // 9
    // "connection" directly instead of in options. (Connections must have a "methods"       // 10
    // method.)                                                                              // 11
    // XXX remove before 1.0                                                                 // 12
    options = {connection: options};                                                         // 13
  }                                                                                          // 14
  // Backwards compatibility: "connection" used to be called "manager".                      // 15
  if (options && options.manager && !options.connection) {                                   // 16
    options.connection = options.manager;                                                    // 17
  }                                                                                          // 18
  options = _.extend({                                                                       // 19
    connection: undefined,                                                                   // 20
    idGeneration: 'STRING',                                                                  // 21
    transform: null,                                                                         // 22
    _driver: undefined,                                                                      // 23
    _preventAutopublish: false                                                               // 24
  }, options);                                                                               // 25
                                                                                             // 26
  switch (options.idGeneration) {                                                            // 27
  case 'MONGO':                                                                              // 28
    self._makeNewID = function () {                                                          // 29
      return new Meteor.Collection.ObjectID();                                               // 30
    };                                                                                       // 31
    break;                                                                                   // 32
  case 'STRING':                                                                             // 33
  default:                                                                                   // 34
    self._makeNewID = function () {                                                          // 35
      return Random.id();                                                                    // 36
    };                                                                                       // 37
    break;                                                                                   // 38
  }                                                                                          // 39
                                                                                             // 40
  if (options.transform)                                                                     // 41
    self._transform = Deps._makeNonreactive(options.transform);                              // 42
  else                                                                                       // 43
    self._transform = null;                                                                  // 44
                                                                                             // 45
  if (!name && (name !== null)) {                                                            // 46
    Meteor._debug("Warning: creating anonymous collection. It will not be " +                // 47
                  "saved or synchronized over the network. (Pass null for " +                // 48
                  "the collection name to turn off this warning.)");                         // 49
  }                                                                                          // 50
                                                                                             // 51
  if (! name || options.connection === null)                                                 // 52
    // note: nameless collections never have a connection                                    // 53
    self._connection = null;                                                                 // 54
  else if (options.connection)                                                               // 55
    self._connection = options.connection;                                                   // 56
  else if (Meteor.isClient)                                                                  // 57
    self._connection = Meteor.connection;                                                    // 58
  else                                                                                       // 59
    self._connection = Meteor.server;                                                        // 60
                                                                                             // 61
  if (!options._driver) {                                                                    // 62
    if (name && self._connection === Meteor.server &&                                        // 63
        typeof MongoInternals !== "undefined" &&                                             // 64
        MongoInternals.defaultRemoteCollectionDriver) {                                      // 65
      options._driver = MongoInternals.defaultRemoteCollectionDriver();                      // 66
    } else {                                                                                 // 67
      options._driver = LocalCollectionDriver;                                               // 68
    }                                                                                        // 69
  }                                                                                          // 70
                                                                                             // 71
  self._collection = options._driver.open(name, self._connection);                           // 72
  self._name = name;                                                                         // 73
                                                                                             // 74
  if (self._connection && self._connection.registerStore) {                                  // 75
    // OK, we're going to be a slave, replicating some remote                                // 76
    // database, except possibly with some temporary divergence while                        // 77
    // we have unacknowledged RPC's.                                                         // 78
    var ok = self._connection.registerStore(name, {                                          // 79
      // Called at the beginning of a batch of updates. batchSize is the number              // 80
      // of update calls to expect.                                                          // 81
      //                                                                                     // 82
      // XXX This interface is pretty janky. reset probably ought to go back to              // 83
      // being its own function, and callers shouldn't have to calculate                     // 84
      // batchSize. The optimization of not calling pause/remove should be                   // 85
      // delayed until later: the first call to update() should buffer its                   // 86
      // message, and then we can either directly apply it at endUpdate time if              // 87
      // it was the only update, or do pauseObservers/apply/apply at the next                // 88
      // update() if there's another one.                                                    // 89
      beginUpdate: function (batchSize, reset) {                                             // 90
        // pause observers so users don't see flicker when updating several                  // 91
        // objects at once (including the post-reconnect reset-and-reapply                   // 92
        // stage), and so that a re-sorting of a query can take advantage of the             // 93
        // full _diffQuery moved calculation instead of applying change one at a             // 94
        // time.                                                                             // 95
        if (batchSize > 1 || reset)                                                          // 96
          self._collection.pauseObservers();                                                 // 97
                                                                                             // 98
        if (reset)                                                                           // 99
          self._collection.remove({});                                                       // 100
      },                                                                                     // 101
                                                                                             // 102
      // Apply an update.                                                                    // 103
      // XXX better specify this interface (not in terms of a wire message)?                 // 104
      update: function (msg) {                                                               // 105
        var mongoId = LocalCollection._idParse(msg.id);                                      // 106
        var doc = self._collection.findOne(mongoId);                                         // 107
                                                                                             // 108
        // Is this a "replace the whole doc" message coming from the quiescence              // 109
        // of method writes to an object? (Note that 'undefined' is a valid                  // 110
        // value meaning "remove it".)                                                       // 111
        if (msg.msg === 'replace') {                                                         // 112
          var replace = msg.replace;                                                         // 113
          if (!replace) {                                                                    // 114
            if (doc)                                                                         // 115
              self._collection.remove(mongoId);                                              // 116
          } else if (!doc) {                                                                 // 117
            self._collection.insert(replace);                                                // 118
          } else {                                                                           // 119
            // XXX check that replace has no $ ops                                           // 120
            self._collection.update(mongoId, replace);                                       // 121
          }                                                                                  // 122
          return;                                                                            // 123
        } else if (msg.msg === 'added') {                                                    // 124
          if (doc) {                                                                         // 125
            throw new Error("Expected not to find a document already present for an add");   // 126
          }                                                                                  // 127
          self._collection.insert(_.extend({_id: mongoId}, msg.fields));                     // 128
        } else if (msg.msg === 'removed') {                                                  // 129
          if (!doc)                                                                          // 130
            throw new Error("Expected to find a document already present for removed");      // 131
          self._collection.remove(mongoId);                                                  // 132
        } else if (msg.msg === 'changed') {                                                  // 133
          if (!doc)                                                                          // 134
            throw new Error("Expected to find a document to change");                        // 135
          if (!_.isEmpty(msg.fields)) {                                                      // 136
            var modifier = {};                                                               // 137
            _.each(msg.fields, function (value, key) {                                       // 138
              if (value === undefined) {                                                     // 139
                if (!modifier.$unset)                                                        // 140
                  modifier.$unset = {};                                                      // 141
                modifier.$unset[key] = 1;                                                    // 142
              } else {                                                                       // 143
                if (!modifier.$set)                                                          // 144
                  modifier.$set = {};                                                        // 145
                modifier.$set[key] = value;                                                  // 146
              }                                                                              // 147
            });                                                                              // 148
            self._collection.update(mongoId, modifier);                                      // 149
          }                                                                                  // 150
        } else {                                                                             // 151
          throw new Error("I don't know how to deal with this message");                     // 152
        }                                                                                    // 153
                                                                                             // 154
      },                                                                                     // 155
                                                                                             // 156
      // Called at the end of a batch of updates.                                            // 157
      endUpdate: function () {                                                               // 158
        self._collection.resumeObservers();                                                  // 159
      },                                                                                     // 160
                                                                                             // 161
      // Called around method stub invocations to capture the original versions              // 162
      // of modified documents.                                                              // 163
      saveOriginals: function () {                                                           // 164
        self._collection.saveOriginals();                                                    // 165
      },                                                                                     // 166
      retrieveOriginals: function () {                                                       // 167
        return self._collection.retrieveOriginals();                                         // 168
      }                                                                                      // 169
    });                                                                                      // 170
                                                                                             // 171
    if (!ok)                                                                                 // 172
      throw new Error("There is already a collection named '" + name + "'");                 // 173
  }                                                                                          // 174
                                                                                             // 175
  self._defineMutationMethods();                                                             // 176
                                                                                             // 177
  // autopublish                                                                             // 178
  if (Package.autopublish && !options._preventAutopublish && self._connection                // 179
      && self._connection.publish) {                                                         // 180
    self._connection.publish(null, function () {                                             // 181
      return self.find();                                                                    // 182
    }, {is_auto: true});                                                                     // 183
  }                                                                                          // 184
};                                                                                           // 185
                                                                                             // 186
///                                                                                          // 187
/// Main collection API                                                                      // 188
///                                                                                          // 189
                                                                                             // 190
                                                                                             // 191
_.extend(Meteor.Collection.prototype, {                                                      // 192
                                                                                             // 193
  _getFindSelector: function (args) {                                                        // 194
    if (args.length == 0)                                                                    // 195
      return {};                                                                             // 196
    else                                                                                     // 197
      return args[0];                                                                        // 198
  },                                                                                         // 199
                                                                                             // 200
  _getFindOptions: function (args) {                                                         // 201
    var self = this;                                                                         // 202
    if (args.length < 2) {                                                                   // 203
      return { transform: self._transform };                                                 // 204
    } else {                                                                                 // 205
      return _.extend({                                                                      // 206
        transform: self._transform                                                           // 207
      }, args[1]);                                                                           // 208
    }                                                                                        // 209
  },                                                                                         // 210
                                                                                             // 211
  find: function (/* selector, options */) {                                                 // 212
    // Collection.find() (return all docs) behaves differently                               // 213
    // from Collection.find(undefined) (return 0 docs).  so be                               // 214
    // careful about the length of arguments.                                                // 215
    var self = this;                                                                         // 216
    var argArray = _.toArray(arguments);                                                     // 217
    return self._collection.find(self._getFindSelector(argArray),                            // 218
                                 self._getFindOptions(argArray));                            // 219
  },                                                                                         // 220
                                                                                             // 221
  findOne: function (/* selector, options */) {                                              // 222
    var self = this;                                                                         // 223
    var argArray = _.toArray(arguments);                                                     // 224
    return self._collection.findOne(self._getFindSelector(argArray),                         // 225
                                    self._getFindOptions(argArray));                         // 226
  }                                                                                          // 227
                                                                                             // 228
});                                                                                          // 229
                                                                                             // 230
Meteor.Collection._publishCursor = function (cursor, sub, collection) {                      // 231
  var observeHandle = cursor.observeChanges({                                                // 232
    added: function (id, fields) {                                                           // 233
      sub.added(collection, id, fields);                                                     // 234
    },                                                                                       // 235
    changed: function (id, fields) {                                                         // 236
      sub.changed(collection, id, fields);                                                   // 237
    },                                                                                       // 238
    removed: function (id) {                                                                 // 239
      sub.removed(collection, id);                                                           // 240
    }                                                                                        // 241
  });                                                                                        // 242
                                                                                             // 243
  // We don't call sub.ready() here: it gets called in livedata_server, after                // 244
  // possibly calling _publishCursor on multiple returned cursors.                           // 245
                                                                                             // 246
  // register stop callback (expects lambda w/ no args).                                     // 247
  sub.onStop(function () {observeHandle.stop();});                                           // 248
};                                                                                           // 249
                                                                                             // 250
// protect against dangerous selectors.  falsey and {_id: falsey} are both                   // 251
// likely programmer error, and not what you want, particularly for destructive              // 252
// operations.  JS regexps don't serialize over DDP but can be trivially                     // 253
// replaced by $regex.                                                                       // 254
Meteor.Collection._rewriteSelector = function (selector) {                                   // 255
  // shorthand -- scalars match _id                                                          // 256
  if (LocalCollection._selectorIsId(selector))                                               // 257
    selector = {_id: selector};                                                              // 258
                                                                                             // 259
  if (!selector || (('_id' in selector) && !selector._id))                                   // 260
    // can't match anything                                                                  // 261
    return {_id: Random.id()};                                                               // 262
                                                                                             // 263
  var ret = {};                                                                              // 264
  _.each(selector, function (value, key) {                                                   // 265
    // Mongo supports both {field: /foo/} and {field: {$regex: /foo/}}                       // 266
    if (value instanceof RegExp) {                                                           // 267
      ret[key] = convertRegexpToMongoSelector(value);                                        // 268
    } else if (value && value.$regex instanceof RegExp) {                                    // 269
      ret[key] = convertRegexpToMongoSelector(value.$regex);                                 // 270
      // if value is {$regex: /foo/, $options: ...} then $options                            // 271
      // override the ones set on $regex.                                                    // 272
      if (value.$options !== undefined)                                                      // 273
        ret[key].$options = value.$options;                                                  // 274
    }                                                                                        // 275
    else if (_.contains(['$or','$and','$nor'], key)) {                                       // 276
      // Translate lower levels of $and/$or/$nor                                             // 277
      ret[key] = _.map(value, function (v) {                                                 // 278
        return Meteor.Collection._rewriteSelector(v);                                        // 279
      });                                                                                    // 280
    }                                                                                        // 281
    else {                                                                                   // 282
      ret[key] = value;                                                                      // 283
    }                                                                                        // 284
  });                                                                                        // 285
  return ret;                                                                                // 286
};                                                                                           // 287
                                                                                             // 288
// convert a JS RegExp object to a Mongo {$regex: ..., $options: ...}                        // 289
// selector                                                                                  // 290
var convertRegexpToMongoSelector = function (regexp) {                                       // 291
  check(regexp, RegExp); // safety belt                                                      // 292
                                                                                             // 293
  var selector = {$regex: regexp.source};                                                    // 294
  var regexOptions = '';                                                                     // 295
  // JS RegExp objects support 'i', 'm', and 'g'. Mongo regex $options                       // 296
  // support 'i', 'm', 'x', and 's'. So we support 'i' and 'm' here.                         // 297
  if (regexp.ignoreCase)                                                                     // 298
    regexOptions += 'i';                                                                     // 299
  if (regexp.multiline)                                                                      // 300
    regexOptions += 'm';                                                                     // 301
  if (regexOptions)                                                                          // 302
    selector.$options = regexOptions;                                                        // 303
                                                                                             // 304
  return selector;                                                                           // 305
};                                                                                           // 306
                                                                                             // 307
var throwIfSelectorIsNotId = function (selector, methodName) {                               // 308
  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                             // 309
    throw new Meteor.Error(                                                                  // 310
      403, "Not permitted. Untrusted code may only " + methodName +                          // 311
        " documents by ID.");                                                                // 312
  }                                                                                          // 313
};                                                                                           // 314
                                                                                             // 315
// 'insert' immediately returns the inserted document's new _id.  The                        // 316
// others return nothing.                                                                    // 317
//                                                                                           // 318
// Otherwise, the semantics are exactly like other methods: they take                        // 319
// a callback as an optional last argument; if no callback is                                // 320
// provided, they block until the operation is complete, and throw an                        // 321
// exception if it fails; if a callback is provided, then they don't                         // 322
// necessarily block, and they call the callback when they finish with                       // 323
// error and result arguments.  (The insert method provides the                              // 324
// document ID as its result; update and remove don't provide a result.)                     // 325
//                                                                                           // 326
// On the client, blocking is impossible, so if a callback                                   // 327
// isn't provided, they just return immediately and any error                                // 328
// information is lost.                                                                      // 329
//                                                                                           // 330
// There's one more tweak. On the client, if you don't provide a                             // 331
// callback, then if there is an error, a message will be logged with                        // 332
// Meteor._debug.                                                                            // 333
//                                                                                           // 334
// The intent (though this is actually determined by the underlying                          // 335
// drivers) is that the operations should be done synchronously, not                         // 336
// generating their result until the database has acknowledged                               // 337
// them. In the future maybe we should provide a flag to turn this                           // 338
// off.                                                                                      // 339
_.each(["insert", "update", "remove"], function (name) {                                     // 340
  Meteor.Collection.prototype[name] = function (/* arguments */) {                           // 341
    var self = this;                                                                         // 342
    var args = _.toArray(arguments);                                                         // 343
    var callback;                                                                            // 344
    var ret;                                                                                 // 345
                                                                                             // 346
    if (args.length && args[args.length - 1] instanceof Function)                            // 347
      callback = args.pop();                                                                 // 348
                                                                                             // 349
    if (Meteor.isClient && !callback) {                                                      // 350
      // Client can't block, so it can't report errors by exception,                         // 351
      // only by callback. If they forget the callback, give them a                          // 352
      // default one that logs the error, so they aren't totally                             // 353
      // baffled if their writes don't work because their database is                        // 354
      // down.                                                                               // 355
      callback = function (err) {                                                            // 356
        if (err)                                                                             // 357
          Meteor._debug(name + " failed: " + (err.reason || err.stack));                     // 358
      };                                                                                     // 359
    }                                                                                        // 360
                                                                                             // 361
    if (name === "insert") {                                                                 // 362
      if (!args.length)                                                                      // 363
        throw new Error("insert requires an argument");                                      // 364
      // shallow-copy the document and generate an ID                                        // 365
      args[0] = _.extend({}, args[0]);                                                       // 366
      if ('_id' in args[0]) {                                                                // 367
        ret = args[0]._id;                                                                   // 368
        if (!(typeof ret === 'string'                                                        // 369
              || ret instanceof Meteor.Collection.ObjectID))                                 // 370
          throw new Error("Meteor requires document _id fields to be strings or ObjectIDs"); // 371
      } else {                                                                               // 372
        ret = args[0]._id = self._makeNewID();                                               // 373
      }                                                                                      // 374
    } else {                                                                                 // 375
      args[0] = Meteor.Collection._rewriteSelector(args[0]);                                 // 376
    }                                                                                        // 377
                                                                                             // 378
    var wrappedCallback;                                                                     // 379
    if (callback) {                                                                          // 380
      wrappedCallback = function (error, result) {                                           // 381
        callback(error, !error && ret);                                                      // 382
      };                                                                                     // 383
    }                                                                                        // 384
                                                                                             // 385
    if (self._connection && self._connection !== Meteor.server) {                            // 386
      // just remote to another endpoint, propagate return value or                          // 387
      // exception.                                                                          // 388
                                                                                             // 389
      var enclosing = DDP._CurrentInvocation.get();                                          // 390
      var alreadyInSimulation = enclosing && enclosing.isSimulation;                         // 391
      if (!alreadyInSimulation && name !== "insert") {                                       // 392
        // If we're about to actually send an RPC, we should throw an error if               // 393
        // this is a non-ID selector, because the mutation methods only allow                // 394
        // single-ID selectors. (If we don't throw here, we'll see flicker.)                 // 395
        throwIfSelectorIsNotId(args[0], name);                                               // 396
      }                                                                                      // 397
                                                                                             // 398
      self._connection.apply(self._prefix + name, args, wrappedCallback);                    // 399
                                                                                             // 400
    } else {                                                                                 // 401
      // it's my collection.  descend into the collection object                             // 402
      // and propagate any exception.                                                        // 403
      args.push(wrappedCallback);                                                            // 404
      try {                                                                                  // 405
        self._collection[name].apply(self._collection, args);                                // 406
      } catch (e) {                                                                          // 407
        if (callback) {                                                                      // 408
          callback(e);                                                                       // 409
          return null;                                                                       // 410
        }                                                                                    // 411
        throw e;                                                                             // 412
      }                                                                                      // 413
    }                                                                                        // 414
                                                                                             // 415
    // both sync and async, unless we threw an exception, return ret                         // 416
    // (new document ID for insert, undefined otherwise).                                    // 417
    return ret;                                                                              // 418
  };                                                                                         // 419
});                                                                                          // 420
                                                                                             // 421
// We'll actually design an index API later. For now, we just pass through to                // 422
// Mongo's, but make it synchronous.                                                         // 423
Meteor.Collection.prototype._ensureIndex = function (index, options) {                       // 424
  var self = this;                                                                           // 425
  if (!self._collection._ensureIndex)                                                        // 426
    throw new Error("Can only call _ensureIndex on server collections");                     // 427
  self._collection._ensureIndex(index, options);                                             // 428
};                                                                                           // 429
Meteor.Collection.prototype._dropIndex = function (index) {                                  // 430
  var self = this;                                                                           // 431
  if (!self._collection._dropIndex)                                                          // 432
    throw new Error("Can only call _dropIndex on server collections");                       // 433
  self._collection._dropIndex(index);                                                        // 434
};                                                                                           // 435
Meteor.Collection.prototype._createCappedCollection = function (byteSize) {                  // 436
  var self = this;                                                                           // 437
  if (!self._collection._createCappedCollection)                                             // 438
    throw new Error("Can only call _createCappedCollection on server collections");          // 439
  self._collection._createCappedCollection(byteSize);                                        // 440
};                                                                                           // 441
                                                                                             // 442
Meteor.Collection.ObjectID = LocalCollection._ObjectID;                                      // 443
                                                                                             // 444
///                                                                                          // 445
/// Remote methods and access control.                                                       // 446
///                                                                                          // 447
                                                                                             // 448
// Restrict default mutators on collection. allow() and deny() take the                      // 449
// same options:                                                                             // 450
//                                                                                           // 451
// options.insert {Function(userId, doc)}                                                    // 452
//   return true to allow/deny adding this document                                          // 453
//                                                                                           // 454
// options.update {Function(userId, docs, fields, modifier)}                                 // 455
//   return true to allow/deny updating these documents.                                     // 456
//   `fields` is passed as an array of fields that are to be modified                        // 457
//                                                                                           // 458
// options.remove {Function(userId, docs)}                                                   // 459
//   return true to allow/deny removing these documents                                      // 460
//                                                                                           // 461
// options.fetch {Array}                                                                     // 462
//   Fields to fetch for these validators. If any call to allow or deny                      // 463
//   does not have this option then all fields are loaded.                                   // 464
//                                                                                           // 465
// allow and deny can be called multiple times. The validators are                           // 466
// evaluated as follows:                                                                     // 467
// - If neither deny() nor allow() has been called on the collection,                        // 468
//   then the request is allowed if and only if the "insecure" smart                         // 469
//   package is in use.                                                                      // 470
// - Otherwise, if any deny() function returns true, the request is denied.                  // 471
// - Otherwise, if any allow() function returns true, the request is allowed.                // 472
// - Otherwise, the request is denied.                                                       // 473
//                                                                                           // 474
// Meteor may call your deny() and allow() functions in any order, and may not               // 475
// call all of them if it is able to make a decision without calling them all                // 476
// (so don't include side effects).                                                          // 477
                                                                                             // 478
(function () {                                                                               // 479
  var addValidator = function(allowOrDeny, options) {                                        // 480
    // validate keys                                                                         // 481
    var VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];                   // 482
    _.each(_.keys(options), function (key) {                                                 // 483
      if (!_.contains(VALID_KEYS, key))                                                      // 484
        throw new Error(allowOrDeny + ": Invalid key: " + key);                              // 485
    });                                                                                      // 486
                                                                                             // 487
    var self = this;                                                                         // 488
    self._restricted = true;                                                                 // 489
                                                                                             // 490
    _.each(['insert', 'update', 'remove'], function (name) {                                 // 491
      if (options[name]) {                                                                   // 492
        if (!(options[name] instanceof Function)) {                                          // 493
          throw new Error(allowOrDeny + ": Value for `" + name + "` must be a function");    // 494
        }                                                                                    // 495
        if (self._transform)                                                                 // 496
          options[name].transform = self._transform;                                         // 497
        if (options.transform)                                                               // 498
          options[name].transform = Deps._makeNonreactive(options.transform);                // 499
        self._validators[name][allowOrDeny].push(options[name]);                             // 500
      }                                                                                      // 501
    });                                                                                      // 502
                                                                                             // 503
    // Only update the fetch fields if we're passed things that affect                       // 504
    // fetching. This way allow({}) and allow({insert: f}) don't result in                   // 505
    // setting fetchAllFields                                                                // 506
    if (options.update || options.remove || options.fetch) {                                 // 507
      if (options.fetch && !(options.fetch instanceof Array)) {                              // 508
        throw new Error(allowOrDeny + ": Value for `fetch` must be an array");               // 509
      }                                                                                      // 510
      self._updateFetch(options.fetch);                                                      // 511
    }                                                                                        // 512
  };                                                                                         // 513
                                                                                             // 514
  Meteor.Collection.prototype.allow = function(options) {                                    // 515
    addValidator.call(this, 'allow', options);                                               // 516
  };                                                                                         // 517
  Meteor.Collection.prototype.deny = function(options) {                                     // 518
    addValidator.call(this, 'deny', options);                                                // 519
  };                                                                                         // 520
})();                                                                                        // 521
                                                                                             // 522
                                                                                             // 523
Meteor.Collection.prototype._defineMutationMethods = function() {                            // 524
  var self = this;                                                                           // 525
                                                                                             // 526
  // set to true once we call any allow or deny methods. If true, use                        // 527
  // allow/deny semantics. If false, use insecure mode semantics.                            // 528
  self._restricted = false;                                                                  // 529
                                                                                             // 530
  // Insecure mode (default to allowing writes). Defaults to 'undefined' which               // 531
  // means insecure iff the insecure package is loaded. This property can be                 // 532
  // overriden by tests or packages wishing to change insecure mode behavior of              // 533
  // their collections.                                                                      // 534
  self._insecure = undefined;                                                                // 535
                                                                                             // 536
  self._validators = {                                                                       // 537
    insert: {allow: [], deny: []},                                                           // 538
    update: {allow: [], deny: []},                                                           // 539
    remove: {allow: [], deny: []},                                                           // 540
    fetch: [],                                                                               // 541
    fetchAllFields: false                                                                    // 542
  };                                                                                         // 543
                                                                                             // 544
  if (!self._name)                                                                           // 545
    return; // anonymous collection                                                          // 546
                                                                                             // 547
  // XXX Think about method namespacing. Maybe methods should be                             // 548
  // "Meteor:Mongo:insert/NAME"?                                                             // 549
  self._prefix = '/' + self._name + '/';                                                     // 550
                                                                                             // 551
  // mutation methods                                                                        // 552
  if (self._connection) {                                                                    // 553
    var m = {};                                                                              // 554
                                                                                             // 555
    _.each(['insert', 'update', 'remove'], function (method) {                               // 556
      m[self._prefix + method] = function (/* ... */) {                                      // 557
        // All the methods do their own validation, instead of using check().                // 558
        check(arguments, [Match.Any]);                                                       // 559
        try {                                                                                // 560
          if (this.isSimulation) {                                                           // 561
                                                                                             // 562
            // In a client simulation, you can do any mutation (even with a                  // 563
            // complex selector).                                                            // 564
            self._collection[method].apply(                                                  // 565
              self._collection, _.toArray(arguments));                                       // 566
            return;                                                                          // 567
          }                                                                                  // 568
                                                                                             // 569
          // This is the server receiving a method call from the client. We                  // 570
          // don't allow arbitrary selectors in mutations from the client: only              // 571
          // single-ID selectors.                                                            // 572
          if (method !== 'insert')                                                           // 573
            throwIfSelectorIsNotId(arguments[0], method);                                    // 574
                                                                                             // 575
          if (self._restricted) {                                                            // 576
            // short circuit if there is no way it will pass.                                // 577
            if (self._validators[method].allow.length === 0) {                               // 578
              throw new Meteor.Error(                                                        // 579
                403, "Access denied. No allow validators set on restricted " +               // 580
                  "collection for method '" + method + "'.");                                // 581
            }                                                                                // 582
                                                                                             // 583
            var validatedMethodName =                                                        // 584
                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);           // 585
            var argsWithUserId = [this.userId].concat(_.toArray(arguments));                 // 586
            self[validatedMethodName].apply(self, argsWithUserId);                           // 587
          } else if (self._isInsecure()) {                                                   // 588
            // In insecure mode, allow any mutation (with a simple selector).                // 589
            self._collection[method].apply(self._collection,                                 // 590
                                           _.toArray(arguments));                            // 591
          } else {                                                                           // 592
            // In secure mode, if we haven't called allow or deny, then nothing              // 593
            // is permitted.                                                                 // 594
            throw new Meteor.Error(403, "Access denied");                                    // 595
          }                                                                                  // 596
        } catch (e) {                                                                        // 597
          if (e.name === 'MongoError' || e.name === 'MinimongoError') {                      // 598
            throw new Meteor.Error(409, e.toString());                                       // 599
          } else {                                                                           // 600
            throw e;                                                                         // 601
          }                                                                                  // 602
        }                                                                                    // 603
      };                                                                                     // 604
    });                                                                                      // 605
    // Minimongo on the server gets no stubs; instead, by default                            // 606
    // it wait()s until its result is ready, yielding.                                       // 607
    // This matches the behavior of macromongo on the server better.                         // 608
    if (Meteor.isClient || self._connection === Meteor.server)                               // 609
      self._connection.methods(m);                                                           // 610
  }                                                                                          // 611
};                                                                                           // 612
                                                                                             // 613
                                                                                             // 614
Meteor.Collection.prototype._updateFetch = function (fields) {                               // 615
  var self = this;                                                                           // 616
                                                                                             // 617
  if (!self._validators.fetchAllFields) {                                                    // 618
    if (fields) {                                                                            // 619
      self._validators.fetch = _.union(self._validators.fetch, fields);                      // 620
    } else {                                                                                 // 621
      self._validators.fetchAllFields = true;                                                // 622
      // clear fetch just to make sure we don't accidentally read it                         // 623
      self._validators.fetch = null;                                                         // 624
    }                                                                                        // 625
  }                                                                                          // 626
};                                                                                           // 627
                                                                                             // 628
Meteor.Collection.prototype._isInsecure = function () {                                      // 629
  var self = this;                                                                           // 630
  if (self._insecure === undefined)                                                          // 631
    return !!Package.insecure;                                                               // 632
  return self._insecure;                                                                     // 633
};                                                                                           // 634
                                                                                             // 635
var docToValidate = function (validator, doc) {                                              // 636
  var ret = doc;                                                                             // 637
  if (validator.transform)                                                                   // 638
    ret = validator.transform(EJSON.clone(doc));                                             // 639
  return ret;                                                                                // 640
};                                                                                           // 641
                                                                                             // 642
Meteor.Collection.prototype._validatedInsert = function(userId, doc) {                       // 643
  var self = this;                                                                           // 644
                                                                                             // 645
  // call user validators.                                                                   // 646
  // Any deny returns true means denied.                                                     // 647
  if (_.any(self._validators.insert.deny, function(validator) {                              // 648
    return validator(userId, docToValidate(validator, doc));                                 // 649
  })) {                                                                                      // 650
    throw new Meteor.Error(403, "Access denied");                                            // 651
  }                                                                                          // 652
  // Any allow returns true means proceed. Throw error if they all fail.                     // 653
  if (_.all(self._validators.insert.allow, function(validator) {                             // 654
    return !validator(userId, docToValidate(validator, doc));                                // 655
  })) {                                                                                      // 656
    throw new Meteor.Error(403, "Access denied");                                            // 657
  }                                                                                          // 658
                                                                                             // 659
  self._collection.insert.call(self._collection, doc);                                       // 660
};                                                                                           // 661
                                                                                             // 662
var transformDoc = function (validator, doc) {                                               // 663
  if (validator.transform)                                                                   // 664
    return validator.transform(doc);                                                         // 665
  return doc;                                                                                // 666
};                                                                                           // 667
                                                                                             // 668
// Simulate a mongo `update` operation while validating that the access                      // 669
// control rules set by calls to `allow/deny` are satisfied. If all                          // 670
// pass, rewrite the mongo operation to use $in to set the list of                           // 671
// document ids to change ##ValidatedChange                                                  // 672
Meteor.Collection.prototype._validatedUpdate = function(                                     // 673
    userId, selector, mutator, options) {                                                    // 674
  var self = this;                                                                           // 675
                                                                                             // 676
  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))                               // 677
    throw new Error("validated update should be of a single ID");                            // 678
                                                                                             // 679
  // compute modified fields                                                                 // 680
  var fields = [];                                                                           // 681
  _.each(mutator, function (params, op) {                                                    // 682
    if (op.charAt(0) !== '$') {                                                              // 683
      throw new Meteor.Error(                                                                // 684
        403, "Access denied. In a restricted collection you can only update documents, not replace them. Use a Mongo update operator, such as '$set'.");
    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {                                      // 686
      throw new Meteor.Error(                                                                // 687
        403, "Access denied. Operator " + op + " not allowed in a restricted collection.");  // 688
    } else {                                                                                 // 689
      _.each(_.keys(params), function (field) {                                              // 690
        // treat dotted fields as if they are replacing their                                // 691
        // top-level part                                                                    // 692
        if (field.indexOf('.') !== -1)                                                       // 693
          field = field.substring(0, field.indexOf('.'));                                    // 694
                                                                                             // 695
        // record the field we are trying to change                                          // 696
        if (!_.contains(fields, field))                                                      // 697
          fields.push(field);                                                                // 698
      });                                                                                    // 699
    }                                                                                        // 700
  });                                                                                        // 701
                                                                                             // 702
  var findOptions = {transform: null};                                                       // 703
  if (!self._validators.fetchAllFields) {                                                    // 704
    findOptions.fields = {};                                                                 // 705
    _.each(self._validators.fetch, function(fieldName) {                                     // 706
      findOptions.fields[fieldName] = 1;                                                     // 707
    });                                                                                      // 708
  }                                                                                          // 709
                                                                                             // 710
  var doc = self._collection.findOne(selector, findOptions);                                 // 711
  if (!doc)  // none satisfied!                                                              // 712
    return;                                                                                  // 713
                                                                                             // 714
  var factoriedDoc;                                                                          // 715
                                                                                             // 716
  // call user validators.                                                                   // 717
  // Any deny returns true means denied.                                                     // 718
  if (_.any(self._validators.update.deny, function(validator) {                              // 719
    if (!factoriedDoc)                                                                       // 720
      factoriedDoc = transformDoc(validator, doc);                                           // 721
    return validator(userId,                                                                 // 722
                     factoriedDoc,                                                           // 723
                     fields,                                                                 // 724
                     mutator);                                                               // 725
  })) {                                                                                      // 726
    throw new Meteor.Error(403, "Access denied");                                            // 727
  }                                                                                          // 728
  // Any allow returns true means proceed. Throw error if they all fail.                     // 729
  if (_.all(self._validators.update.allow, function(validator) {                             // 730
    if (!factoriedDoc)                                                                       // 731
      factoriedDoc = transformDoc(validator, doc);                                           // 732
    return !validator(userId,                                                                // 733
                      factoriedDoc,                                                          // 734
                      fields,                                                                // 735
                      mutator);                                                              // 736
  })) {                                                                                      // 737
    throw new Meteor.Error(403, "Access denied");                                            // 738
  }                                                                                          // 739
                                                                                             // 740
  // Back when we supported arbitrary client-provided selectors, we actually                 // 741
  // rewrote the selector to include an _id clause before passing to Mongo to                // 742
  // avoid races, but since selector is guaranteed to already just be an ID, we              // 743
  // don't have to any more.                                                                 // 744
                                                                                             // 745
  self._collection.update.call(                                                              // 746
    self._collection, selector, mutator, options);                                           // 747
};                                                                                           // 748
                                                                                             // 749
// Only allow these operations in validated updates. Specifically                            // 750
// whitelist operations, rather than blacklist, so new complex                               // 751
// operations that are added aren't automatically allowed. A complex                         // 752
// operation is one that does more than just modify its target                               // 753
// field. For now this contains all update operations except '$rename'.                      // 754
// http://docs.mongodb.org/manual/reference/operators/#update                                // 755
var ALLOWED_UPDATE_OPERATIONS = {                                                            // 756
  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,                        // 757
  $pushAll:1, $push:1, $bit:1                                                                // 758
};                                                                                           // 759
                                                                                             // 760
// Simulate a mongo `remove` operation while validating access control                       // 761
// rules. See #ValidatedChange                                                               // 762
Meteor.Collection.prototype._validatedRemove = function(userId, selector) {                  // 763
  var self = this;                                                                           // 764
                                                                                             // 765
  var findOptions = {transform: null};                                                       // 766
  if (!self._validators.fetchAllFields) {                                                    // 767
    findOptions.fields = {};                                                                 // 768
    _.each(self._validators.fetch, function(fieldName) {                                     // 769
      findOptions.fields[fieldName] = 1;                                                     // 770
    });                                                                                      // 771
  }                                                                                          // 772
                                                                                             // 773
  var doc = self._collection.findOne(selector, findOptions);                                 // 774
  if (!doc)                                                                                  // 775
    return;                                                                                  // 776
                                                                                             // 777
  // call user validators.                                                                   // 778
  // Any deny returns true means denied.                                                     // 779
  if (_.any(self._validators.remove.deny, function(validator) {                              // 780
    return validator(userId, transformDoc(validator, doc));                                  // 781
  })) {                                                                                      // 782
    throw new Meteor.Error(403, "Access denied");                                            // 783
  }                                                                                          // 784
  // Any allow returns true means proceed. Throw error if they all fail.                     // 785
  if (_.all(self._validators.remove.allow, function(validator) {                             // 786
    return !validator(userId, transformDoc(validator, doc));                                 // 787
  })) {                                                                                      // 788
    throw new Meteor.Error(403, "Access denied");                                            // 789
  }                                                                                          // 790
                                                                                             // 791
  // Back when we supported arbitrary client-provided selectors, we actually                 // 792
  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to             // 793
  // Mongo to avoid races, but since selector is guaranteed to already just be               // 794
  // an ID, we don't have to any more.                                                       // 795
                                                                                             // 796
  self._collection.remove.call(self._collection, selector);                                  // 797
};                                                                                           // 798
                                                                                             // 799
///////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['mongo-livedata'] = {};

})();

//# sourceMappingURL=94f1f8c354e018030c021e1a615ce8876c641930.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var _ = Package.underscore._;

/* Package-scope variables */
var stringify;

(function () {

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// packages/canonical-stringify/stringify.js                                    //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
                                                                                //
// Based on json2.js from https://github.com/douglascrockford/JSON-js           // 1
//                                                                              // 2
//    json2.js                                                                  // 3
//    2012-10-08                                                                // 4
//                                                                              // 5
//    Public Domain.                                                            // 6
//                                                                              // 7
//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.                   // 8
                                                                                // 9
                                                                                // 10
function quote(string) {                                                        // 11
  return JSON.stringify(string);                                                // 12
}                                                                               // 13
                                                                                // 14
var rep, gap, indent;                                                           // 15
                                                                                // 16
function str(key, holder) {                                                     // 17
                                                                                // 18
// Produce a string from holder[key].                                           // 19
                                                                                // 20
    var i,          // The loop counter.                                        // 21
        k,          // The member key.                                          // 22
        v,          // The member value.                                        // 23
        length,                                                                 // 24
        mind = gap,                                                             // 25
        partial,                                                                // 26
        value = holder[key];                                                    // 27
                                                                                // 28
// If the value has a toJSON method, call it to obtain a replacement value.     // 29
                                                                                // 30
    if (value && typeof value === 'object' &&                                   // 31
            typeof value.toJSON === 'function') {                               // 32
        value = value.toJSON(key);                                              // 33
    }                                                                           // 34
                                                                                // 35
// If we were called with a replacer function, then call the replacer to        // 36
// obtain a replacement value.                                                  // 37
                                                                                // 38
    if (typeof rep === 'function') {                                            // 39
        value = rep.call(holder, key, value);                                   // 40
    }                                                                           // 41
                                                                                // 42
// What happens next depends on the value's type.                               // 43
                                                                                // 44
    switch (typeof value) {                                                     // 45
    case 'string':                                                              // 46
        return quote(value);                                                    // 47
                                                                                // 48
    case 'number':                                                              // 49
                                                                                // 50
// JSON numbers must be finite. Encode non-finite numbers as null.              // 51
                                                                                // 52
        return isFinite(value) ? String(value) : 'null';                        // 53
                                                                                // 54
    case 'boolean':                                                             // 55
    case 'null':                                                                // 56
                                                                                // 57
// If the value is a boolean or null, convert it to a string. Note:             // 58
// typeof null does not produce 'null'. The case is included here in            // 59
// the remote chance that this gets fixed someday.                              // 60
                                                                                // 61
        return String(value);                                                   // 62
                                                                                // 63
// If the type is 'object', we might be dealing with an object or an array or   // 64
// null.                                                                        // 65
                                                                                // 66
    case 'object':                                                              // 67
                                                                                // 68
// Due to a specification blunder in ECMAScript, typeof null is 'object',       // 69
// so watch out for that case.                                                  // 70
                                                                                // 71
        if (!value) {                                                           // 72
            return 'null';                                                      // 73
        }                                                                       // 74
                                                                                // 75
// Make an array to hold the partial results of stringifying this object value. // 76
                                                                                // 77
        gap += indent;                                                          // 78
        partial = [];                                                           // 79
                                                                                // 80
// Is the value an array?                                                       // 81
                                                                                // 82
        if (Object.prototype.toString.apply(value) === '[object Array]') {      // 83
                                                                                // 84
// The value is an array. Stringify every element. Use null as a placeholder    // 85
// for non-JSON values.                                                         // 86
                                                                                // 87
            length = value.length;                                              // 88
            for (i = 0; i < length; i += 1) {                                   // 89
                partial[i] = str(i, value) || 'null';                           // 90
            }                                                                   // 91
                                                                                // 92
// Join all of the elements together, separated with commas, and wrap them in   // 93
// brackets.                                                                    // 94
                                                                                // 95
            v = partial.length === 0                                            // 96
                ? '[]'                                                          // 97
                : gap                                                           // 98
                ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'   // 99
                : '[' + partial.join(',') + ']';                                // 100
            gap = mind;                                                         // 101
            return v;                                                           // 102
        }                                                                       // 103
                                                                                // 104
// If the replacer is an array, use it to select the members to be stringified. // 105
                                                                                // 106
        if (rep && typeof rep === 'object') {                                   // 107
            length = rep.length;                                                // 108
            for (i = 0; i < length; i += 1) {                                   // 109
                if (typeof rep[i] === 'string') {                               // 110
                    k = rep[i];                                                 // 111
                    v = str(k, value);                                          // 112
                    if (v) {                                                    // 113
                        partial.push(quote(k) + (gap ? ': ' : ':') + v);        // 114
                    }                                                           // 115
                }                                                               // 116
            }                                                                   // 117
        } else {                                                                // 118
                                                                                // 119
// Otherwise, iterate through all of the keys in the object.                    // 120
                                                                                // 121
            _.each(_.keys(value).sort(), function (k) {                         // 122
                v = str(k, value);                                              // 123
                if (v) {                                                        // 124
                    partial.push(quote(k) + (gap ? ': ' : ':') + v);            // 125
                }                                                               // 126
            });                                                                 // 127
        }                                                                       // 128
                                                                                // 129
// Join all of the member texts together, separated with commas,                // 130
// and wrap them in braces.                                                     // 131
                                                                                // 132
        v = partial.length === 0                                                // 133
            ? '{}'                                                              // 134
            : gap                                                               // 135
            ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'       // 136
            : '{' + partial.join(',') + '}';                                    // 137
        gap = mind;                                                             // 138
        return v;                                                               // 139
    }                                                                           // 140
}                                                                               // 141
                                                                                // 142
                                                                                // 143
stringify = function (value, replacer, space) {                                 // 144
                                                                                // 145
// The stringify method takes a value and an optional replacer, and an optional // 146
// space parameter, and returns a JSON text. The replacer can be a function     // 147
// that can replace values, or an array of strings that will select the keys.   // 148
// A default replacer method can be provided. Use of the space parameter can    // 149
// produce text that is more easily readable.                                   // 150
                                                                                // 151
            var i;                                                              // 152
            gap = '';                                                           // 153
            indent = '';                                                        // 154
                                                                                // 155
// If the space parameter is a number, make an indent string containing that    // 156
// many spaces.                                                                 // 157
                                                                                // 158
            if (typeof space === 'number') {                                    // 159
                for (i = 0; i < space; i += 1) {                                // 160
                    indent += ' ';                                              // 161
                }                                                               // 162
                                                                                // 163
// If the space parameter is a string, it will be used as the indent string.    // 164
                                                                                // 165
            } else if (typeof space === 'string') {                             // 166
                indent = space;                                                 // 167
            }                                                                   // 168
                                                                                // 169
// If there is a replacer, it must be a function or an array.                   // 170
// Otherwise, throw an error.                                                   // 171
                                                                                // 172
            rep = replacer;                                                     // 173
            if (replacer && typeof replacer !== 'function' &&                   // 174
                    (typeof replacer !== 'object' ||                            // 175
                    typeof replacer.length !== 'number')) {                     // 176
                throw new Error('stringify');                                   // 177
            }                                                                   // 178
                                                                                // 179
// Make a fake root object containing our value under the key of ''.            // 180
// Return the result of stringifying the value.                                 // 181
                                                                                // 182
            return str('', {'': value});                                        // 183
        }                                                                       // 184
                                                                                // 185
//////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['canonical-stringify'] = {
  stringify: stringify
};

})();

//# sourceMappingURL=87dc228ec402721635feb53596439af9741fdfbe.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var isolateValue, __coffeescriptShare;

(function () {

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// packages/isolate-value/isolate.coffee.js                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////
                                                                        //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
                 

isolateValue = function(fn) {
  var dep, firstTime, lastValue, outerComputation;
  firstTime = true;
  lastValue = null;
  outerComputation = Deps.currentComputation;
  dep = new Deps.Dependency();
  Deps.autorun(function(c) {
    var value;
    if (outerComputation != null ? outerComputation.stopped : void 0) {
      c.stop();
      return;
    }
    value = fn();
    if (firstTime) {
      lastValue = value;
      firstTime = false;
    } else {
      if (!EJSON.equals(value, lastValue)) {
        dep.changed();
      }
    }
  });
  dep.depend();
  return lastValue;
};

if (typeof Package === "undefined" || Package === null) {
  this.isolateValue = isolateValue;
}
//////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['isolate-value'] = {
  isolateValue: isolateValue
};

})();

//# sourceMappingURL=9e8fa7077053631460f9c45e82d200329c34dd85.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var Deps = Package.deps.Deps;
var EJSON = Package.ejson.EJSON;

/* Package-scope variables */
var Variable, __coffeescriptShare;

(function () {

///////////////////////////////////////////////////////////////////////
//                                                                   //
// packages/variable/variable.coffee.js                              //
//                                                                   //
///////////////////////////////////////////////////////////////////////
                                                                     //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var _Variable;          

_Variable = function(initialValue) {
  var dep, fn, value;
  value = initialValue;
  dep = new Deps.Dependency();
  fn = function() {
    dep.depend();
    return value;
  };
  fn.set = function(newValue) {
    if (!EJSON.equals(newValue, value)) {
      value = newValue;
      dep.changed();
    }
  };
  return fn;
};

if (typeof Package !== "undefined" && Package !== null) {
  Variable = _Variable;
} else {
  this.Variable = _Variable;
}
///////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package.variable = {
  Variable: Variable
};

})();

//# sourceMappingURL=a0a81f3535d8759217a619daa9b5172289ca4d0d.map
//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
//                                                                      //
// If you are using Chrome, open the Developer Tools and click the gear //
// icon in its lower right corner. In the General Settings panel, turn  //
// on 'Enable source maps'.                                             //
//                                                                      //
// If you are using Firefox 23, go to `about:config` and set the        //
// `devtools.debugger.source-maps-enabled` preference to true.          //
// (The preference should be on by default in Firefox 24; versions      //
// older than 23 do not support source maps.)                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var EJSON = Package.ejson.EJSON;
var DDP = Package.livedata.DDP;
var _ = Package.underscore._;
var stringify = Package['canonical-stringify'].stringify;
var isolateValue = Package['isolate-value'].isolateValue;
var LocalCollection = Package.minimongo.LocalCollection;
var Random = Package.random.Random;
var Variable = Package.variable.Variable;

/* Package-scope variables */
var Context, Errors, Fanout, Result, contains, Offline, broadcast, __coffeescriptShare;

(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/context.litcoffee.js                                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var ContextEntry, contextVar, getContext, resetContext, withContext;         

ContextEntry = (function() {
  function ContextEntry(entry, parentContext) {
    this.entry = entry;
    this.parentContext = parentContext;
  }

  ContextEntry.prototype.add = function(entry) {
    return new ContextEntry(entry, this);
  };

  ContextEntry.prototype.toArray = function() {
    var array, context, entry;
    array = [];
    context = this;
    while (context != null) {
      entry = context.entry;
      if (entry != null) {
        array.push(entry);
      }
      context = context.parentContext;
    }
    return array.reverse();
  };

  return ContextEntry;

})();

contextVar = new Meteor.EnvironmentVariable();

getContext = function() {
  var context;
  context = contextVar.get();
  if (context != null) {
    return context.toArray();
  } else {
    return [];
  }
};

withContext = function(entry, fn) {
  var context;
  if (typeof fn !== 'function') {
    throw new Error("withContext: fn arg is not a function: " + fn);
  }
  context = new ContextEntry(entry, contextVar.get());
  return contextVar.withValue(context, fn);
};

resetContext = function(fn) {
  return contextVar.withValue(null, fn);
};

Context = {
  getContext: getContext,
  resetContext: resetContext,
  withContext: withContext
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/errors.litcoffee.js                                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var ErrorDescription, Failed, bind, catcherr, defer, describeError, ensureString, logError, reportError;        

ensureString = function(x) {
  var error;
  if (x === null) {
    return 'null';
  }
  if (typeof x === 'undefined') {
    return 'undefined';
  }
  if (typeof x === 'string') {
    return x;
  }
  try {
    return x.toString();
  } catch (_error) {
    error = _error;
    return EJSON.stringify(describeError(error));
  }
};

ErrorDescription = (function() {
  function ErrorDescription() {}

  return ErrorDescription;

})();

describeError = function(err, context) {
  var constructorName, description, message, stack, type, _ref;
  if (err === null) {
    message = "null";
  } else if (typeof err === 'undefined') {
    message = 'undefined';
  } else {
    if (err.message !== null && typeof err.message !== 'undefined') {
      message = ensureString(err.message);
    } else {
      message = ensureString(err);
    }
    if (err.stack !== null && typeof err.stack !== 'undefined') {
      stack = ensureString(err.stack);
    }
    if (err instanceof Error) {
      constructorName = (_ref = err.constructor) != null ? _ref.name : void 0;
      if (constructorName != null) {
        type = ensureString(constructorName);
      }
    }
  }
  description = new ErrorDescription();
  description.message = message;
  if (type != null) {
    description.type = type;
  }
  if (stack != null) {
    description.stack = stack;
  }
  if (context != null) {
    description.context = context;
  }
  return description;
};

logError = function(description) {
  var entry, _i, _len, _ref;
  if (description.stack != null) {
    Meteor._debug(description.stack);
  } else {
    Meteor._debug(description.message);
  }
  if (description.context != null) {
    _ref = description.context;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      entry = _ref[_i];
      Meteor._debug('-', entry);
    }
  }
};

reportError = function(error) {
  logError(describeError(error, Context.getContext()));
};

Failed = (function() {
  function Failed(reason) {
    this.reason = reason;
  }

  return Failed;

})();

catcherr = function(fn, failureReason) {
  var error;
  try {
    return fn();
  } catch (_error) {
    error = _error;
    if (!(error instanceof Failed)) {
      reportError(error);
    }
    throw new Failed(failureReason);
  }
};

defer = function(fn) {
  if (typeof fn !== 'function') {
    throw new Error("not a function: " + fn);
  }
  return Meteor.defer(function() {
    return catcherr(fn);
  });
};

bind = function(fn) {
  return Meteor.bindEnvironment(fn, reportError, this);
};

Errors = {
  bind: bind,
  catcherr: catcherr,
  defer: defer,
  Failed: Failed,
  reportError: reportError
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/fanout.litcoffee.js                                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var        
  __slice = [].slice;

Fanout = function() {
  var fn, listeners;
  listeners = [];
  fn = function() {
    var args, callback, _i, _len;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (listeners != null) {
      for (_i = 0, _len = listeners.length; _i < _len; _i++) {
        callback = listeners[_i];
        Errors.catcherr(function() {
          return callback.apply(null, args);
        });
      }
    }
  };
  fn.listen = function(callback) {
    if (listeners != null) {
      listeners.push(callback);
    }
  };
  fn.dispose = function() {
    listeners = null;
  };
  return fn;
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/result.litcoffee.js                                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
           

Result = (function() {
  function Result() {
    this._done = false;
    this._failed = null;
    this._doneFanout = Fanout();
  }

  Result.prototype.callback = function(cb) {
    var _this = this;
    if (typeof cb !== 'function') {
      throw new Error("Result.on: callback is not a function: " + cb);
    }
    if (this._done) {
      Errors.catcherr(function() {
        return cb(_this._failed, _this._value, _this);
      });
    } else {
      this._doneFanout.listen(Errors.bind(cb));
    }
    return this;
  };

  Result.prototype.onSuccess = function(cb) {
    var _this = this;
    if (typeof cb !== 'function') {
      throw new Error("Result.onSuccess: callback is not a function: " + cb);
    }
    this.callback(function(failed, value) {
      if (failed) {
        return;
      }
      Errors.catcherr(function() {
        return cb(value, _this);
      });
    });
    return this;
  };

  Result.prototype.onFailure = function(cb) {
    var _this = this;
    if (typeof cb !== 'function') {
      throw new Error("Result.onFail: callback is not a function: " + cb);
    }
    this.callback(function(failed, value) {
      if (!failed) {
        return;
      }
      Errors.catcherr(function() {
        return cb(failed, _this);
      });
    });
    return this;
  };

  Result.prototype._broadcast = function() {
    this._doneFanout(this._failed, this._value, this);
    this._doneFanout.dispose();
  };

  Result.prototype.complete = function(value) {
    if (this._done) {
      return this;
    }
    if (value instanceof Result) {
      this.from(value);
      return;
    }
    this._done = true;
    this._value = value;
    this._broadcast();
    return this;
  };

  Result.prototype.fail = function(failure) {
    if (this._done) {
      return this;
    }
    this._done = true;
    this._failed = failure != null ? failure : true;
    this._broadcast();
    return this;
  };

  Result.prototype.into = function(result) {
    var _this = this;
    this.callback(function(failed, value) {
      if (failed) {
        return result.fail();
      } else {
        return result.complete(value);
      }
    });
    return this;
  };

  Result.prototype.from = function(result) {
    result.into(this);
    return this;
  };

  Result.prototype._run = function(fn, arg) {
    var error, ret;
    try {
      ret = fn(arg);
    } catch (_error) {
      error = _error;
      Errors.reportError(error);
      this.fail();
      return;
    }
    if (ret instanceof Result) {
      this.from(ret);
    } else {
      this.complete(ret);
    }
  };

  Result.prototype.then = function(successFn, failureFn) {
    var result,
      _this = this;
    if ((successFn != null) && !(typeof successFn === 'function')) {
      throw new Error("Result.then: successFn is not a function: " + successFn);
    }
    if ((failureFn != null) && !(typeof failureFn === 'function')) {
      throw new Error("Result.then: failureFn is not a function: " + failureFn);
    }
    result = new Result();
    this.callback(function(failure, value) {
      if (failure != null) {
        if (failureFn != null) {
          result._run(failureFn, failure);
        } else {
          result.fail();
        }
      } else {
        if (successFn != null) {
          result._run(successFn, value);
        } else {
          result.complete(value);
        }
      }
    });
    return result;
  };

  Result.prototype.always = function(fn) {
    var f;
    f = function() {
      fn();
    };
    return this.then(f, f);
  };

  Result.value = function(v) {
    var result;
    result = new Result();
    result.complete(v);
    return result;
  };

  Result.completed = function(v) {
    return Result.value(v);
  };

  Result.failed = function(failure) {
    var result;
    result = new Result();
    result.fail(failure);
    return result;
  };

  Result.delay = function(milliseconds, v) {
    var result;
    result = new Result();
    Meteor.setTimeout((function() {
      return result.complete(v);
    }), milliseconds);
    return result;
  };

  Result.defer = function(v) {
    var result;
    result = new Result();
    Errors.defer(function() {
      return result.complete(v);
    });
    return result;
  };

  Result.join = function(results) {
    var finalResult, i, nComplete, output, result, total, _fn, _i, _len;
    if (results.length === 0) {
      return Result.completed([]);
    }
    finalResult = new Result();
    total = results.length;
    nComplete = 0;
    output = [];
    _fn = function(result, i) {
      return result.callback(function(failure, value) {
        if (failure) {
          return finalResult.fail(failure);
        } else {
          output[i] = value;
          ++nComplete;
          if (nComplete === total) {
            return finalResult.complete(output);
          }
        }
      });
    };
    for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {
      result = results[i];
      _fn(result, i);
    }
    return finalResult;
  };

  Result.map = function(array, fn) {
    var item, result, results, _i, _len;
    results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      result = new Result;
      result._run(fn, item);
      results.push(result);
    }
    return Result.join(results);
  };

  Result.sequence = function(input, fns) {
    var finalResult, i, next;
    finalResult = new Result();
    i = 0;
    next = function(value) {
      var result;
      result = new Result();
      result._run(fns[i], value);
      result.callback(function(failure, nextValue) {
        if (failure != null) {
          finalResult.fail(failure);
          return;
        }
        ++i;
        if (i === fns.length) {
          finalResult.complete(nextValue);
        } else {
          next(nextValue);
        }
      });
    };
    Result.value(input).callback(function(failure, nextValue) {
      if (failure != null) {
        finalResult.fail(failure);
        return;
      }
      next(nextValue);
    });
    return finalResult;
  };

  Result.prototype.timeout = function(milliseconds) {
    var delay, result;
    result = new Result();
    delay = Result.delay(milliseconds);
    delay.onSuccess(function() {
      return result.fail('timeout');
    });
    this.into(result);
    return result;
  };

  Result.prototype.debug = function(msg) {
    if (msg == null) {
      msg = "result";
    }
    this.callback(function(failure, value) {
      if (failure != null) {
        Meteor._debug(msg, 'FAILED', failure);
      } else {
        Meteor._debug(msg, 'completed', value);
      }
    });
    return this;
  };

  return Result;

})();
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/contains.litcoffee.js                                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
             

contains = function(list, value) {
  var item, _i, _len;
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    item = list[_i];
    if (EJSON.equals(item, value)) {
      return true;
    }
  }
  return false;
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/offline.litcoffee.js                                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var _ref, _ref1, _ref2, _ref3, _ref4, _ref5;         

Offline = {};

Offline.isWebWorker = Meteor.isClient && (typeof window === "undefined" || window === null) && (typeof document === "undefined" || document === null) && (typeof importScripts !== "undefined" && importScripts !== null);

if (Offline.isWebWorker) {
  Offline.persistent = true;
} else if (Meteor.isClient) {
  Offline.persistent = (!((_ref = Meteor.settings) != null ? (_ref1 = _ref["public"]) != null ? (_ref2 = _ref1.offlineData) != null ? _ref2.disable : void 0 : void 0 : void 0)) && (typeof openDatabase !== "undefined" && openDatabase !== null) && ((!((_ref3 = Meteor.settings) != null ? (_ref4 = _ref3["public"]) != null ? (_ref5 = _ref4.offlineData) != null ? _ref5.disableWorker : void 0 : void 0 : void 0) && (typeof SharedWorker !== "undefined" && SharedWorker !== null)) || (typeof BrowserMsg !== "undefined" && BrowserMsg !== null ? BrowserMsg.supported : void 0));
} else if (Meteor.isServer) {
  Offline.persistent = true;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/broadcast.litcoffee.js                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var onMessage, topic, topics,           
  __slice = [].slice;

if (Offline.isWebWorker) {
  return;
}

topics = {};

topic = function(messageTopic) {
  return topics[messageTopic] || (topics[messageTopic] = new Fanout());
};

onMessage = function(messageTopic, args) {
  Context.withContext("received broadcast msg " + messageTopic, function() {
    topic(messageTopic).apply(null, args);
  });
};

Meteor.startup(function() {
  if (!Offline._usingSharedWebWorker) {
    BrowserMsg.listen({
      '/awwx/offline-data/broadcast': function(messageTopic, args) {
        onMessage(messageTopic, args);
      }
    });
  }
});

broadcast = function() {
  var args, messageTopic;
  messageTopic = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  BrowserMsg.send('/awwx/offline-data/broadcast', messageTopic, args);
};

broadcast.includingSelf = function() {
  var args, messageTopic;
  messageTopic = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  BrowserMsg.send('/awwx/offline-data/broadcast', messageTopic, args);
  Errors.defer(function() {
    return topic(messageTopic).apply(null, args);
  });
};

broadcast.listen = function(messageTopic, callback) {
  topic(messageTopic).listen(callback);
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/database.litcoffee.js                                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var DATABASE_NAME, DATABASE_VERSION, SQLStore, andthen, begin, global, now, placeholders, sqlRows, store,
  __slice = [].slice;

if (!Offline.persistent) {
  return;
}

DATABASE_NAME = 'awwx/offline-data';

DATABASE_VERSION = '8';

global = this;

sqlRows = function(sqlResultSet) {
  var array, i, r, _i, _ref;
  array = [];
  r = sqlResultSet.rows;
  for (i = _i = 0, _ref = r.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    array.push(r.item(i));
  }
  return array;
};

placeholders = function(array) {
  return _.map(array, function() {
    return "?";
  }).join(",");
};

now = function() {
  return new Date().getTime();
};

andthen = function() {
  var fn, fns, result,
    _this = this;
  result = arguments[0], fns = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  while (fns.length > 0) {
    fn = fns.shift();
    (function(fn) {
      return result = result.then(function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return fn.apply(null, args);
      });
    })(fn);
  }
  return result;
};

begin = function() {
  var description, steps,
    _this = this;
  description = arguments[0], steps = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return Context.withContext(description, function() {
    return andthen.apply(null, [Result.completed()].concat(__slice.call(steps)));
  });
};

SQLStore = (function() {
  function SQLStore() {
    this.databaseOpen = new Result();
  }

  SQLStore.prototype.implementation = 'SQL';

  SQLStore.prototype.processTransaction = function(fn, runtx) {
    var inTxResult, result, txDone,
      _this = this;
    if (!_.isFunction(fn)) {
      throw new Error('fn should be a function');
    }
    txDone = new Result();
    inTxResult = new Result();
    runtx(Errors.bind(function(tx) {
      Context.withContext('SQL transaction', function() {
        return fn(tx);
      }).into(inTxResult);
    }), (function(error) {
      Errors.reportError(error);
      txDone.fail();
    }), (function() {
      txDone.complete();
    }));
    result = new Result();
    Result.join([inTxResult, txDone]).onSuccess(function(_arg) {
      var inValue, txValue;
      inValue = _arg[0], txValue = _arg[1];
      return result.complete(inValue);
    }).onFailure(function() {
      return result.fail();
    });
    return result;
  };

  SQLStore.prototype._transaction = function(fn) {
    var _this = this;
    return this.processTransaction(fn, function(withTx, onError, onSuccess) {
      return _this.sqldb.transaction(withTx, onError, onSuccess);
    });
  };

  SQLStore.prototype.transaction = function(fn) {
    var _this = this;
    return this.databaseOpen.then(function() {
      return _this._transaction(fn);
    });
  };

  SQLStore.prototype.changeVersion = function(newVersion, fn) {
    var _this = this;
    return this.processTransaction(fn, function(withTx, onError, onSuccess) {
      return _this.sqldb.changeVersion(_this.sqldb.version, newVersion, withTx, onError, onSuccess);
    });
  };

  SQLStore.prototype.openDatabase = function(options) {
    var _this = this;
    if (options == null) {
      options = {};
    }
    return Context.withContext('open SQL database', function() {
      _this.sqldb = global.openDatabase(DATABASE_NAME, '', '', 1024 * 1024);
    });
  };

  SQLStore.prototype.sql = function(tx, sqlStatement, args) {
    var _this = this;
    return Context.withContext("execute SQL statement: " + sqlStatement, function() {
      var result;
      result = new Result();
      tx.executeSql(sqlStatement, args, Errors.bind(function(tx, sqlResultSet) {
        result.complete(sqlRows(sqlResultSet));
      }), Errors.bind(function(tx, sqlError) {
        Errors.reportError(sqlError);
        result.fail();
      }));
      return result;
    });
  };

  SQLStore.prototype.listTables = function(tx) {
    var _this = this;
    return begin("listTables", (function() {
      return _this.sql(tx, "SELECT * FROM sqlite_master\n  WHERE type=\"table\" AND\n        name NOT LIKE \"!_%\" ESCAPE \"!\" AND\n        name NOT LIKE \"sqlite!_%\" ESCAPE \"!\"");
    }), (function(tables) {
      var table;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tables.length; _i < _len; _i++) {
          table = tables[_i];
          _results.push(table.name);
        }
        return _results;
      })()).sort();
    }));
  };

  SQLStore.prototype.dropTable = function(tx, tableName) {
    var _this = this;
    return begin("dropTable " + tableName, (function() {
      return _this.sql(tx, "DROP TABLE " + tableName);
    }));
  };

  SQLStore.prototype.dropAllTables = function(tx) {
    var _this = this;
    return begin("dropAllTables", (function() {
      return _this.listTables(tx);
    }), (function(names) {
      var name;
      return Result.join((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          _results.push(this.dropTable(tx, name));
        }
        return _results;
      }).call(_this));
    }), (function() {}));
  };

  SQLStore.prototype.eraseDatabase = function() {
    var _this = this;
    return begin("eraseDatabase", (function() {
      _this.openDatabase();
      return _this.changeVersion('', function(tx) {
        return _this.dropAllTables(tx);
      });
    }));
  };

  SQLStore.prototype.createTables = function(tx) {
    var _this = this;
    return begin("createTables", function() {
      return Result.join([_this.sql(tx, "CREATE TABLE windows (\n  windowId TEXT PRIMARY KEY NOT NULL,\n  updateId INTEGER NOT NULL\n)"), _this.sql(tx, "CREATE TABLE agentWindow (\n  singleton INTEGER PRIMARY KEY NOT NULL,\n  windowId TEXT NOT NULL\n)"), _this.sql(tx, "CREATE TABLE docs (\n  connection TEXT NOT NULL,\n  collectionName TEXT NOT NULL,\n  docId TEXT NOT NULL,\n  doc TEXT NOT NULL,\n  PRIMARY KEY (connection, collectionName, docId)\n)"), _this.sql(tx, "CREATE TABLE stubDocs (\n  connection TEXT NOT NULL,\n  methodId TEXT NOT NULL,\n  collectionName TEXT NOT NULL,\n  docId TEXT NOT NULL,\n  PRIMARY KEY (connection, methodId, collectionName, docId)\n)"), _this.sql(tx, "CREATE TABLE queuedMethods (\n  connection TEXT NOT NULL,\n  methodId TEXT NOT NULL,\n  method TEXT NOT NULL,\n  PRIMARY KEY (connection, methodId)\n)"), _this.sql(tx, "CREATE TABLE windowSubscriptions (\n  windowId TEXT NOT NULL,\n  connection TEXT NOT NULL,\n  subscription TEXT NOT NULL,\n  PRIMARY KEY (windowId, connection, subscription)\n)"), _this.sql(tx, "CREATE TABLE subscriptions (\n  connection TEXT NOT NULL,\n  subscription TEXT NOT NULL,\n  serverReady INTEGER NOT NULL,\n  status TEXT NOT NULL,\n  error TEXT NOT NULL,\n  loaded INTEGER NOT NULL,\n  PRIMARY KEY (connection, subscription)\n)"), _this.sql(tx, "CREATE TABLE methodsHoldingUpSubscriptions (\n  connection TEXT NOT NULL,\n  subscription TEXT NOT NULL,\n  methodId TEXT NOT NULL,\n  PRIMARY KEY (connection, subscription, methodId)\n)"), _this.sql(tx, "CREATE TABLE updates (\n  id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,\n  theUpdate TEXT NOT NULL\n)")]);
    });
  };

  SQLStore.prototype.initializeNewDatabase = function() {
    var _this = this;
    return begin("initializeNewDatabase", function() {
      return _this.changeVersion(DATABASE_VERSION, (function(tx) {
        return _this.createTables(tx);
      }));
    });
  };

  SQLStore.prototype.resetDatabase = function() {
    var _this = this;
    return begin("resetDatabase", (function() {
      return _this.eraseDatabase();
    }), (function() {
      return _this.initializeNewDatabase();
    }));
  };

  SQLStore.prototype.upgradeDatabaseIfNeeded = function() {
    var _this = this;
    return begin("upgradeDatabaseIfNeeded", function() {
      if (_this.sqldb.version === DATABASE_VERSION) {
        return Result.completed();
      } else {
        return _this.resetDatabase();
      }
    });
  };

  SQLStore.prototype.open = function() {
    var _this = this;
    return begin("open", function() {
      _this.openDatabase();
      _this.upgradeDatabaseIfNeeded().into(_this.databaseOpen);
      return _this.databaseOpen;
    });
  };

  SQLStore.prototype.ensureWindow = function(tx, windowId) {
    var _this = this;
    return begin("ensureWindow", (function() {
      return _this.highestUpdateId(tx);
    }), (function(updateId) {
      return _this.sql(tx, "INSERT OR IGNORE INTO windows (windowId, updateId)\n  VALUES (?, ?)", [windowId, updateId]);
    }));
  };

  SQLStore.prototype.readAllWindowIds = function(tx) {
    var _this = this;
    return begin("readKnownWindowIds", (function() {
      return _this.sql(tx, "SELECT windowId FROM windows UNION\nSELECT windowId FROM windowSubscriptions UNION\nSELECT windowId FROM agentWindow");
    }), (function(rows) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _results.push(row.windowId);
      }
      return _results;
    }));
  };

  SQLStore.prototype.deleteWindows = function(tx, windowIds) {
    var _this = this;
    return begin("deleteWindows", (function() {
      return _this.sql(tx, "DELETE FROM windows\n  WHERE windowId IN (" + (placeholders(windowIds)) + ")", windowIds);
    }), (function() {
      return _this.sql(tx, "DELETE FROM windowSubscriptions\n  WHERE windowId IN (" + (placeholders(windowIds)) + ")", windowIds);
    }), (function() {
      return _this.sql(tx, "DELETE FROM agentWindow\n  WHERE windowId IN (" + (placeholders(windowIds)) + ")", windowIds);
    }));
  };

  SQLStore.prototype.readAgentWindow = function(tx) {
    var _this = this;
    return begin("readAgentWindow", (function() {
      return _this.sql(tx, "SELECT windowId FROM agentWindow");
    }), (function(rows) {
      if (rows.length === 0) {
        return null;
      } else if (rows.length === 1) {
        return rows[0].windowId;
      } else {
        Errors.reportError('agentWindow table does not contain a singleton row');
        return Result.failed();
      }
    }));
  };

  SQLStore.prototype.writeAgentWindow = function(tx, windowId) {
    var _this = this;
    return begin("writeAgentWindow", (function() {
      return _this.sql(tx, "INSERT OR REPLACE INTO agentWindow\n  (singleton, windowId) VALUES (0, ?)", [windowId]);
    }));
  };

  SQLStore.prototype.writeDoc = function(tx, connection, collectionName, doc) {
    var _this = this;
    return begin("writeDoc", (function() {
      return _this.sql(tx, "INSERT OR REPLACE INTO docs\n  (connection, collectionName, docId, doc)\n  VALUES (?, ?, ?, ?)", [connection, collectionName, doc._id, EJSON.stringify(doc)]);
    }));
  };

  SQLStore.prototype.readDocs = function(tx, connection) {
    var _this = this;
    return begin("readDocs", (function() {
      return _this.sql(tx, "SELECT collectionName, doc FROM docs WHERE connection=?", [connection]);
    }), (function(rows) {
      var doc, output, row, _i, _len;
      output = {};
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        doc = EJSON.parse(row.doc);
        Meteor._ensure(output, row.collectionName)[doc._id] = doc;
      }
      return output;
    }));
  };

  SQLStore.prototype.readDocIdsOfCollection = function(tx, connection, collectionName) {
    var _this = this;
    return begin('readDocIdsOfCollection', (function() {
      return _this.sql(tx, "SELECT docId FROM docs\n  WHERE connection = ? AND\n        collectionName = ?", [connection, collectionName]);
    }), (function(rows) {
      return _.map(rows, function(row) {
        return row.docId;
      });
    }));
  };

  SQLStore.prototype.deleteDoc = function(tx, connection, collectionName, docId) {
    var _this = this;
    return begin("deleteDoc", (function() {
      return _this.sql(tx, "DELETE FROM docs\n  WHERE connection=? AND\n        collectionName=? AND\n        docID=?", [connection, collectionName, docId]);
    }));
  };

  SQLStore.prototype.addDocumentWrittenByStub = function(tx, connection, methodId, collectionName, docId) {
    var _this = this;
    return begin("addDocumentWrittenByStub", (function() {
      return _this.sql(tx, "INSERT INTO stubDocs\n  (connection, methodId, collectionName, docId)\n  VALUES (?, ?, ?, ?)", [connection, methodId, collectionName, docId]);
    }));
  };

  SQLStore.prototype.isDocumentWrittenByAnyStub = function(tx, connection, collectionName, docId) {
    var _this = this;
    return begin("isDocumentWrittenByAnyStub", (function() {
      return _this.sql(tx, "SELECT 1 FROM stubDocs\n  WHERE connection=? AND\n        collectionName=? AND\n        docID=?\n  LIMIT 1", [connection, collectionName, docId]);
    }), (function(rows) {
      return rows.length > 0;
    }));
  };

  SQLStore.prototype.readDocsWrittenByStub = function(tx, connection, methodId) {
    var _this = this;
    return begin("readDocsWrittenByStub", (function() {
      return _this.sql(tx, "SELECT collectionName, docId FROM stubDocs\n  WHERE connection=? AND\n        methodId=?", [connection, methodId]);
    }));
  };

  SQLStore.prototype.removeDocumentsWrittenByStub = function(tx, connection, methodId) {
    var _this = this;
    return begin("removeDocumentsWrittenByStub", (function() {
      return _this.sql(tx, "DELETE FROM stubDocs\n  WHERE connection=? AND\n        methodId=?", [connection, methodId]);
    }));
  };

  SQLStore.prototype.readMethodsWithDocsWritten = function(tx, connection) {
    var _this = this;
    return begin("readMethodsWithDocsWritten", (function() {
      return _this.sql(tx, "SELECT DISTINCT methodId FROM stubDocs\n  WHERE connection=?\n  ORDER BY methodId", [connection]);
    }), (function(rows) {
      var row;
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          row = rows[_i];
          _results.push(row.methodId);
        }
        return _results;
      })();
    }));
  };

  SQLStore.prototype.addQueuedMethod = function(tx, connection, methodId, name, args) {
    var _this = this;
    return begin("addQueuedMethod", (function() {
      var method;
      method = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "INSERT INTO queuedMethods\n  (connection, methodId, method)\n  VALUES (?, ?, ?)", [connection, methodId, method]);
    }));
  };

  SQLStore.prototype.readQueuedMethods = function(tx) {
    var _this = this;
    return begin("readQueuedMethods", (function() {
      return _this.sql(tx, "SELECT connection, methodId, method FROM queuedMethods");
    }), (function(rows) {
      var args, name, output, row, _i, _len, _ref;
      output = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = EJSON.parse(row.method), name = _ref.name, args = _ref.args;
        output.push({
          connection: row.connection,
          methodId: row.methodId,
          name: name,
          args: args
        });
      }
      return output;
    }));
  };

  SQLStore.prototype.removeQueuedMethod = function(tx, connection, methodId) {
    var _this = this;
    return begin("removedQueuedMethod", (function() {
      return _this.sql(tx, "DELETE FROM queuedMethods\n  WHERE connection=? AND\n        methodId=?", [connection, methodId]);
    }));
  };

  SQLStore.prototype.addWindowSubscription = function(tx, windowId, connection, name, args) {
    var _this = this;
    return begin("addWindowSubscription", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "INSERT OR IGNORE INTO windowSubscriptions\n  (windowId, connection, subscription)\n  VALUES (?, ?, ?)", [windowId, connection, subscription]);
    }));
  };

  SQLStore.prototype.setWindowSubscriptions = function(tx, windowId, connection, subscriptions) {
    var _this = this;
    return begin("setWindowSubscriptions", (function() {
      return _this.sql(tx, "DELETE FROM windowSubscriptions\n  WHERE windowId = ? AND connection = ?", [windowId, connection]);
    }), (function() {
      return Result.map(subscriptions, (function(subscription) {
        var serialized;
        serialized = stringify({
          name: subscription[0],
          args: subscription.slice(1)
        });
        return _this.sql(tx, "INSERT INTO windowSubscriptions\n  (windowId, connection, subscription)\n  VALUES (?, ?, ?)", [windowId, connection, serialized]);
      }));
    }));
  };

  SQLStore.prototype._testReadWindowSubscriptions = function(tx) {
    var _this = this;
    return begin("_testReadWindowSubscriptions", (function() {
      return _this.sql(tx, "SELECT windowId, connection, subscription\n  FROM windowSubscriptions\n  ORDER BY windowId, connection, subscription");
    }), (function(rows) {
      var args, name, output, row, _i, _len, _ref;
      output = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = EJSON.parse(row.subscription), name = _ref.name, args = _ref.args;
        output.push({
          windowId: row.windowId,
          connection: row.connection,
          name: name,
          args: args
        });
      }
      return output;
    }));
  };

  SQLStore.prototype.readMergedSubscriptions = function(tx) {
    var _this = this;
    return begin("readMergedSubscriptions", (function() {
      return _this.sql(tx, "SELECT DISTINCT connection, subscription\n  FROM windowSubscriptions\n  ORDER BY connection, subscription");
    }), (function(rows) {
      var args, name, output, row, _i, _len, _ref;
      output = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = EJSON.parse(row.subscription), name = _ref.name, args = _ref.args;
        output.push({
          connection: row.connection,
          name: name,
          args: args
        });
      }
      return output;
    }));
  };

  SQLStore.prototype.removeWindowSubscription = function(tx, windowId, connection, name, args) {
    var _this = this;
    return begin("removeWindowSubscription", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "DELETE FROM windowSubscriptions\n  WHERE windowId=? AND\n        connection=? AND\n        subscription=?", [windowId, connection, subscription]);
    }));
  };

  SQLStore.prototype.ensureSubscription = function(tx, connection, name, args) {
    var _this = this;
    return begin("ensureSubscription", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "INSERT OR IGNORE INTO subscriptions\n  (connection, subscription, serverReady, loaded, status, error)\n  VALUES (?, ?, 0, 0, 'subscribing', '')", [connection, subscription]);
    }));
  };

  SQLStore.prototype.initializeSubscriptions = function(tx) {
    var _this = this;
    return begin("initializeSubscriptions", (function() {
      return _this.sql(tx, "UPDATE subscriptions\n  SET serverReady = 0,\n      status = 'unsubscribed',\n      error = ''");
    }));
  };

  SQLStore.prototype.removeSubscription = function(tx, connection, name, args) {
    var _this = this;
    return begin("removeSubscription", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "DELETE FROM subscriptions\n  WHERE connection = ? AND\n        subscription = ?", [connection, subscription]);
    }));
  };

  SQLStore.prototype.cleanSubscriptions = function(tx) {
    var _this = this;
    return begin("cleanSubscriptions", (function() {
      return Result.join([_this.readMergedSubscriptions(tx), _this.readSubscriptions(tx)]);
    }), (function(_arg) {
      var args, connection, mergedSubscriptions, name, subscriptions, toDelete, writes, _i, _j, _len, _len1, _ref, _ref1;
      mergedSubscriptions = _arg[0], subscriptions = _arg[1];
      toDelete = [];
      for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
        _ref = subscriptions[_i], connection = _ref.connection, name = _ref.name, args = _ref.args;
        if (!contains(mergedSubscriptions, {
          connection: connection,
          name: name,
          args: args
        })) {
          toDelete.push({
            connection: connection,
            name: name,
            args: args
          });
        }
      }
      writes = [];
      for (_j = 0, _len1 = toDelete.length; _j < _len1; _j++) {
        _ref1 = toDelete[_j], connection = _ref1.connection, name = _ref1.name, args = _ref1.args;
        writes.push(_this.removeSubscription(tx, connection, name, args));
      }
      return Result.join(writes).then(function() {
        return toDelete;
      });
    }));
  };

  SQLStore.prototype._loadSubscription = function(row) {
    var args, name, o, _ref;
    _ref = EJSON.parse(row.subscription), name = _ref.name, args = _ref.args;
    o = {
      connection: row.connection,
      name: name,
      args: args,
      serverReady: row.serverReady === 1,
      status: row.status,
      loaded: row.loaded === 1
    };
    if (row.error !== '') {
      o.error = EJSON.parse(row.error);
    }
    return o;
  };

  SQLStore.prototype.readSubscription = function(tx, connection, name, args) {
    var _this = this;
    return begin("readSubscription", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "SELECT connection, subscription, serverReady, status,\n       error, loaded\n  FROM subscriptions\n  WHERE connection=? AND subscription=?", [connection, subscription]);
    }), (function(rows) {
      if (rows.length === 0) {
        return null;
      } else {
        return _this._loadSubscription(rows[0]);
      }
    }));
  };

  SQLStore.prototype.readSubscriptions = function(tx) {
    var _this = this;
    return begin("readSubscriptions", (function() {
      return _this.sql(tx, "SELECT connection, subscription, serverReady, status,\n       error, loaded\n  FROM subscriptions\n  ORDER BY connection, subscription");
    }), (function(rows) {
      return _.map(rows, _this._loadSubscription);
    }));
  };

  SQLStore.prototype.haveSubscription = function(tx, connection, name, args) {
    var _this = this;
    return begin("haveSubscription", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "SELECT 1 FROM subscriptions\n  WHERE connection=? AND\n        subscription=?", [connection, subscription]);
    }), (function(rows) {
      return rows.length > 0;
    }));
  };

  SQLStore.prototype.setSubscriptionServerReady = function(tx, connection, name, args) {
    var _this = this;
    return begin("setSubscriptionServerReady", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "UPDATE subscriptions SET serverReady = 1\n  WHERE connection=? AND\n        subscription=?", [connection, subscription]);
    }));
  };

  SQLStore.prototype.setSubscriptionStatus = function(tx, connection, name, args, status) {
    var _this = this;
    return begin("setSubscriptionStatus", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "UPDATE subscriptions SET status=?\n  WHERE connection=? AND\n        subscription=?", [status, connection, subscription]);
    }));
  };

  SQLStore.prototype.setSubscriptionReady = function(tx, connection, name, args) {
    var _this = this;
    return begin("setSubscriptionReady", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "UPDATE subscriptions SET status = 'ready', loaded = 1\n  WHERE connection = ? AND subscription = ?", [connection, subscription]);
    }));
  };

  SQLStore.prototype.setSubscriptionError = function(tx, connection, name, args, error) {
    var _this = this;
    return begin("setSubscriptionError", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "UPDATE subscriptions\n  SET serverReady = 0, status = 'error', error = ?, loaded = 0\n  WHERE connection = ? AND\n        subscription = ?", [EJSON.stringify(error), connection, subscription]);
    }));
  };

  SQLStore.prototype.setSubscriptionLoaded = function(tx, connection, name, args) {
    var _this = this;
    return begin("setSubscriptionLoaded", (function() {
      var subscription;
      subscription = stringify({
        name: name,
        args: args
      });
      return _this.sql(tx, "UPDATE subscriptions SET loaded = 1\n  WHERE connection=? AND\n        subscription=?", [connection, subscription]);
    }));
  };

  SQLStore.prototype._testReadMethodsHoldingUpSubscriptions = function(tx) {
    var _this = this;
    return begin("_testReadMethodsHoldingUpSubscriptions", (function() {
      return _this.sql(tx, "SELECT connection, subscription, methodId\n  FROM methodsHoldingUpSubscriptions\n  ORDER BY connection, subscription, methodId");
    }), (function(rows) {
      var args, name, output, row, _i, _len, _ref;
      output = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = EJSON.parse(row.subscription), name = _ref.name, args = _ref.args;
        output.push({
          connection: row.connection,
          name: name,
          args: args,
          methodId: row.methodId
        });
      }
      return output;
    }));
  };

  SQLStore.prototype.readSubscriptionsHeldUp = function(tx) {
    var _this = this;
    return begin("readSubscriptionsHeldUp", (function() {
      return _this.sql(tx, "SELECT DISTINCT connection, subscription\n  FROM methodsHoldingUpSubscriptions\n  ORDER BY connection, subscription");
    }), (function(rows) {
      var args, name, output, row, _i, _len, _ref;
      output = [];
      for (_i = 0, _len = rows.length; _i < _len; _i++) {
        row = rows[_i];
        _ref = EJSON.parse(row.subscription), name = _ref.name, args = _ref.args;
        output.push({
          connection: row.connection,
          name: name,
          args: args
        });
      }
      return output;
    }));
  };

  SQLStore.prototype.addSubscriptionWaitingOnMethods = function(tx, connection, name, args, methodIds) {
    var _this = this;
    return begin("addSubscriptionWaitingOnMethods", (function() {
      var methodId, subscription, writes, _fn, _i, _len;
      subscription = stringify({
        name: name,
        args: args
      });
      writes = [];
      _fn = function(methodId) {
        return writes.push(_this.sql(tx, "INSERT OR IGNORE INTO methodsHoldingUpSubscriptions\n  (connection, subscription, methodId)\n  VALUES (?, ?, ?)", [connection, subscription, methodId]));
      };
      for (_i = 0, _len = methodIds.length; _i < _len; _i++) {
        methodId = methodIds[_i];
        _fn(methodId);
      }
      return Result.join(writes);
    }));
  };

  SQLStore.prototype.removeMethodHoldingUpSubscriptions = function(tx, methodId) {
    var _this = this;
    return begin("removeMethodHoldingUpSubscriptions", (function() {
      return _this.sql(tx, "DELETE FROM methodsHoldingUpSubscriptions\n  WHERE methodId=?", [methodId]);
    }));
  };

  SQLStore.prototype.addUpdate = function(tx, update) {
    var _this = this;
    return begin("addUpdate", (function() {
      var serialized;
      serialized = EJSON.stringify(update);
      return _this.sql(tx, "INSERT INTO updates (theUpdate) VALUES (?)", [serialized]);
    }));
  };

  SQLStore.prototype._loadUpdates = function(rows) {
    var output, row, _i, _len;
    output = [];
    for (_i = 0, _len = rows.length; _i < _len; _i++) {
      row = rows[_i];
      output.push({
        id: row.id,
        update: EJSON.parse(row.theUpdate)
      });
    }
    return output;
  };

  SQLStore.prototype._testReadUpdates = function(tx) {
    var _this = this;
    return begin("_testReadUpdates", (function() {
      return _this.sql(tx, "SELECT id, theUpdate FROM updates ORDER BY id");
    }), (function(rows) {
      return _this._loadUpdates(rows);
    }));
  };

  SQLStore.prototype.highestUpdateId = function(tx) {
    var _this = this;
    return begin("highestUpdateId", (function() {
      return _this.sql(tx, "SELECT MAX(id) AS id FROM updates");
    }), (function(rows) {
      var _ref;
      return (_ref = rows[0].id) != null ? _ref : 0;
    }));
  };

  SQLStore.prototype.writeWindowUpdateIndex = function(tx, windowId, updateId) {
    var _this = this;
    return begin("writeWindowUpdateIndex", (function() {
      return _this.sql(tx, "UPDATE windows SET updateId = ?\n  WHERE windowId = ?", [updateId, windowId]);
    }));
  };

  SQLStore.prototype.initializeWindowUpdateIndex = function(tx, windowId) {
    var _this = this;
    return begin("initializeWindowUpdateIndex", (function() {
      return _this.highestUpdateId(tx);
    }), (function(updateId) {
      return _this.writeWindowUpdateIndex(tx, windowId, updateId);
    }));
  };

  SQLStore.prototype._testReadWindows = function(tx) {
    var _this = this;
    return begin("_testReadWindows", (function() {
      return _this.sql(tx, "SELECT windowId, updateId FROM windows\n  ORDER BY windowId");
    }));
  };

  SQLStore.prototype.removeUpdatesProcessedByAllWindows = function(tx) {
    var _this = this;
    return begin("removeUpdatesProcessedByAllWindows", (function() {
      return _this.sql(tx, "SELECT MIN(updateId) AS minUpdateId FROM windows");
    }), (function(rows) {
      var minUpdateId, _ref, _ref1;
      minUpdateId = (_ref = (_ref1 = rows[0]) != null ? _ref1.minUpdateId : void 0) != null ? _ref : 0;
      return _this.sql(tx, "DELETE FROM updates WHERE id <= ?", [minUpdateId]);
    }));
  };

  SQLStore.prototype.pullUpdatesForWindow = function(tx, windowId) {
    var updates,
      _this = this;
    updates = null;
    return begin("pullUpdatesForWindow", (function() {
      return _this.sql(tx, "SELECT updateId FROM windows WHERE windowId=?", [windowId]);
    }), (function(rows) {
      var updateId, _ref, _ref1;
      updateId = (_ref = (_ref1 = rows[0]) != null ? _ref1.updateId : void 0) != null ? _ref : 0;
      return _this.sql(tx, "SELECT theUpdate FROM updates WHERE id > ?", [updateId]);
    }), (function(rows) {
      var update;
      updates = (function() {
        var _i, _len, _ref, _results;
        _ref = this._loadUpdates(rows);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          update = _ref[_i];
          _results.push(update.update);
        }
        return _results;
      }).call(_this);
      return _this.initializeWindowUpdateIndex(tx, windowId);
    }), (function() {
      return updates;
    }));
  };

  return SQLStore;

})();

store = new SQLStore();

Offline._SQLStore = SQLStore;

Offline._database = store;

Offline._databaseName = DATABASE_NAME;

Offline._databaseVersion = DATABASE_VERSION;

Offline.resetDatabase = function() {
  return store.resetDatabase();
};

Meteor.startup(function() {
  if (Offline._disableStartupForTesting || !Offline.persistent) {
    return;
  }
  store.open();
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/windows.litcoffee.js                                                                          //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var becomeTheAgentWindow, check, checkPongs, checking, currentlyTheAgent, db, deadWindows, lastPing, now, nowAgent, startupCheck, testingWindows, thisWindowId, unload, windowsAreDead;

if (!Offline.persistent) {
  return;
}

db = Offline._database;

Offline._windows = {};

Offline._windows.windowsAreDead = windowsAreDead = new Fanout();

now = function() {
  return +(new Date());
};

if (Offline.isWebWorker) {
  deadWindows = function(windowIds) {
    var windowId, _i, _len;
    for (_i = 0, _len = windowIds.length; _i < _len; _i++) {
      windowId = windowIds[_i];
      WebWorker.windowIsDead(windowId);
    }
    windowsAreDead(windowIds);
  };
  checking = false;
  lastPing = null;
  testingWindows = {};
  WebWorker.addMessageHandler('goodbye', function(port, data) {
    deadWindows([data.windowId]);
  });
  WebWorker.addMessageHandler('pong', function(port, data) {
    if (testingWindows != null) {
      delete testingWindows[data.windowId];
    }
  });
  checkPongs = function() {
    deadWindows(_.keys(testingWindows));
    checking = false;
    return testingWindows = null;
  };
  check = function() {
    return Context.withContext("window check", function() {
      if (checking || (lastPing != null) && now() - lastPing < 9000) {
        return;
      }
      checking = true;
      db.transaction(function(tx) {
        return db.readAllWindowIds(tx);
      }).then(function(windowIds) {
        var port, windowId, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        testingWindows = {};
        _ref = WebWorker.windowIds;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          windowId = _ref[_i];
          testingWindows[windowId] = true;
        }
        for (_j = 0, _len1 = windowIds.length; _j < _len1; _j++) {
          windowId = windowIds[_j];
          testingWindows[windowId] = true;
        }
        lastPing = now();
        _ref1 = WebWorker.ports;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          port = _ref1[_k];
          port.postMessage({
            msg: 'ping'
          });
        }
        Meteor.setTimeout(checkPongs, 4000);
      });
    });
  };
  Meteor.startup(function() {
    check();
    return Meteor.setInterval(check, 10000);
  });
} else {
  Offline._windows.thisWindowId = thisWindowId = Random.id();
  Offline._windows.nowAgent = nowAgent = new Fanout();
  testingWindows = null;
  lastPing = null;
  checking = false;
  deadWindows = function(deadWindowIds) {
    return Context.withContext("deadWindows", function() {
      return db.transaction(function(tx) {
        return db.readAgentWindow(tx).then(function(agentWindowId) {
          if ((agentWindowId == null) || _.contains(deadWindowIds, agentWindowId)) {
            return becomeTheAgentWindow(tx);
          } else {
            return Result.completed();
          }
        });
      }).then(function() {
        return windowsAreDead(deadWindowIds);
      });
    });
  };
  currentlyTheAgent = false;
  Offline._windows.currentlyTheAgent = function() {
    return currentlyTheAgent;
  };
  becomeTheAgentWindow = function(tx) {
    return Context.withContext("becomeTheAgentWindow", function() {
      currentlyTheAgent = true;
      Errors.defer(function() {
        return nowAgent();
      });
      return db.writeAgentWindow(tx, thisWindowId);
    });
  };
  startupCheck = function() {
    return Context.withContext("startupCheck", function() {
      return db.transaction(function(tx) {
        return db.readAgentWindow(tx).then(function(agentWindowId) {
          var closedAgentWindow;
          if (agentWindowId == null) {
            return becomeTheAgentWindow(tx);
          } else {
            closedAgentWindow = localStorage.getItem('/awwx/offline-data/agentWindowClosed');
            if (closedAgentWindow === agentWindowId) {
              return becomeTheAgentWindow(tx);
            }
          }
        }).then(function() {
          localStorage.removeItem('/awwx/offline-data/agentWindowClosed');
        });
      });
    });
  };
  check = function() {
    return Context.withContext("window check", function() {
      if (checking) {
        return;
      }
      checking = true;
      return db.transaction(function(tx) {
        return db.readAllWindowIds(tx);
      }).then(function(windowIds) {
        var windowId, _i, _len;
        if ((lastPing != null) && now() - lastPing < 9000) {
          return;
        }
        testingWindows = {};
        for (_i = 0, _len = windowIds.length; _i < _len; _i++) {
          windowId = windowIds[_i];
          if (windowId !== thisWindowId) {
            testingWindows[windowId] = true;
          }
        }
        broadcast('ping');
        return Result.delay(4000).then(function() {
          return windowIds;
        });
      }).then(function(windowIds) {
        return deadWindows(_.keys(testingWindows));
      }).then(function() {
        return checking = false;
      });
    });
  };
  Meteor.startup(function() {
    return Context.withContext("windows startup", function() {
      if (Offline._disableStartupForTesting) {
        return;
      }
      if (Offline._usingSharedWebWorker) {
        return db.transaction(function(tx) {
          return db.ensureWindow(tx, thisWindowId);
        });
      } else {
        broadcast.listen('ping', function() {
          return Context.withContext("listen ping", function() {
            broadcast('pong', thisWindowId);
          });
        });
        broadcast.listen('pong', function(windowId) {
          return Context.withContext("listen pong", function() {
            if (testingWindows != null) {
              delete testingWindows[windowId];
            }
          });
        });
        broadcast.listen('goodbye', function(windowId) {
          return deadWindows([windowId]);
        });
        db.transaction(function(tx) {
          return db.ensureWindow(tx, thisWindowId);
        }).then(function() {
          return startupCheck();
        }).then(function() {
          check();
          return Meteor.setInterval(check, 10000);
        });
      }
    });
  });
  unload = function() {
    return Context.withContext("unload", function() {
      if (Offline._usingSharedWebWorker) {
        Offline._sharedWebWorker.post({
          msg: 'goodbye',
          windowId: thisWindowId
        });
      } else {
        if (currentlyTheAgent) {
          localStorage.setItem('/awwx/offline-data/agentWindowClosed', thisWindowId);
        }
        broadcast('goodbye', thisWindowId);
      }
    });
  };
  if (window.addEventListener != null) {
    window.addEventListener('unload', unload, false);
  }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/model.litcoffee.js                                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
Offline._subscriptionStatus = function(subscription) {
  var status;
  status = {
    status: subscription.status,
    loaded: subscription.loaded
  };
  if (subscription.error != null) {
    status.error = subscription.error;
  }
  return status;
};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/agent.litcoffee.js                                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var CollectionAgent, ConnectionAgent, addMessageHandler, addUpdate, asAgentWindow, broadcastStatusOfSubscription, broadcastSubscriptionStatus, broadcastUpdate, cleanSubscriptions, connectionAgentFor, database, handlers, initializeAgent, initialized, justNameAndArgs, newConnectionAgent, nowAgent, sendQueuedMethods, sendQueuedMethodsInTx, subscribeToSubscriptions, thisWindowId, updateSubscriptionsReady, windowSubscriptionsUpdated, windowsAreDead, withUpdateTracking, _ref,
  __slice = [].slice;

if (!Offline.persistent) {
  return;
}

database = Offline._database;

Offline._test || (Offline._test = {});

if (!Offline.isWebWorker) {
  _ref = Offline._windows, nowAgent = _ref.nowAgent, thisWindowId = _ref.thisWindowId;
}

windowsAreDead = Offline._windows.windowsAreDead;

Offline._messageAgent = function() {
  var args, topic;
  topic = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (Offline.isWebWorker) {
    throw new Error("oops, messaging agent from agent");
  } else if (Offline._usingSharedWebWorker) {
    Offline._sharedWebWorker.post({
      msg: topic,
      args: args
    });
  } else if (Offline._windows.currentlyTheAgent()) {
    Errors.defer(function() {
      return typeof handlers[topic] === "function" ? handlers[topic].apply(handlers, args) : void 0;
    });
  } else {
    broadcast.apply(null, [topic].concat(__slice.call(args)));
  }
};

if (Offline.isWebWorker) {
  WebWorker.addMessageHandler('update', function(sourcePort, data) {
    var port, _i, _len, _ref1;
    _ref1 = WebWorker.ports;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      port = _ref1[_i];
      if (port !== sourcePort) {
        port.postMessage({
          msg: 'update'
        });
      }
    }
  });
  addMessageHandler = function(topic, callback) {
    return WebWorker.addMessageHandler(topic, function(sourcePort, data) {
      callback();
    });
  };
  broadcastUpdate = function() {
    var port, _i, _len, _ref1;
    _ref1 = WebWorker.ports;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      port = _ref1[_i];
      port.postMessage({
        msg: 'update'
      });
    }
  };
} else {
  handlers = {};
  addMessageHandler = function(topic, callback) {
    handlers[topic] = callback;
    broadcast.listen(topic, callback);
  };
  broadcastUpdate = function() {
    broadcast.includingSelf('update');
  };
}

addUpdate = function(tx, trackUpdate, update) {
  if (trackUpdate != null) {
    trackUpdate.madeUpdate = true;
  }
  return database.addUpdate(tx, update);
};

broadcastStatusOfSubscription = function(tx, trackUpdate, subscription) {
  return addUpdate(tx, trackUpdate, {
    update: 'subscriptionStatus',
    subscription: {
      connection: subscription.connection,
      name: subscription.name,
      args: subscription.args
    },
    status: Offline._subscriptionStatus(subscription)
  });
};

broadcastSubscriptionStatus = function(tx, trackUpdate, connection, name, args) {
  var _this = this;
  return database.readSubscription(tx, connection, name, args).then(function(subscription) {
    return broadcastStatusOfSubscription(tx, trackUpdate, subscription);
  });
};

updateSubscriptionsReady = function(tx, trackUpdate) {
  return Context.withContext("updateSubscriptionsReady", function() {
    return Result.join([database.readSubscriptions(tx), database.readSubscriptionsHeldUp(tx)]).then(function(_arg) {
      var args, connection, name, newlyReady, serverReady, status, subscriptions, subscriptionsHeldUp, _i, _len, _ref1;
      subscriptions = _arg[0], subscriptionsHeldUp = _arg[1];
      newlyReady = [];
      for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
        _ref1 = subscriptions[_i], connection = _ref1.connection, name = _ref1.name, args = _ref1.args, serverReady = _ref1.serverReady, status = _ref1.status;
        if (serverReady && status === 'subscribing' && !contains(subscriptionsHeldUp, {
          connection: connection,
          name: name,
          args: args
        })) {
          newlyReady.push({
            connection: connection,
            name: name,
            args: args
          });
        }
      }
      return Result.map(newlyReady, (function(_arg1) {
        var args, connection, name;
        connection = _arg1.connection, name = _arg1.name, args = _arg1.args;
        return database.setSubscriptionReady(tx, connection, name, args).then(function() {
          return broadcastSubscriptionStatus(tx, trackUpdate, connection, name, args);
        });
      }));
    });
  });
};

Offline._test.updateSubscriptionsReady = updateSubscriptionsReady;

justNameAndArgs = function(subscription) {
  return {
    name: subscription.name,
    args: subscription.args
  };
};

if (Offline.isWebWorker) {
  asAgentWindow = function(fn) {
    return database.transaction(fn);
  };
} else {
  asAgentWindow = function(fn) {
    var _this = this;
    return database.transaction(function(tx) {
      return database.readAgentWindow(tx).then(function(agentWindowId) {
        if (agentWindowId === thisWindowId) {
          return fn(tx);
        } else {
          return Result.failed();
        }
      });
    });
  };
}

this.connectionAgents = {};

ConnectionAgent = (function() {
  function ConnectionAgent(connectionName, meteorConnection) {
    this.connectionName = connectionName;
    this.meteorConnection = meteorConnection;
    if (connectionAgents[this.connectionName] != null) {
      throw new Error("a ConnectionAgent has already been constructed for this connection name: " + this.connectionName);
    }
    connectionAgents[this.connectionName] = this;
    this.methodHandlers = {};
    this.collectionAgents = {};
    this.methodsSent = {};
    this.meteorSubscriptionHandles = {};
    this._nMeteorSubscriptionsReady = 0;
    this._deletedRemovedDocs = false;
  }

  ConnectionAgent.prototype.deleteRemovedDocuments = function(tx) {
    if (this._deletedRemovedDocs) {
      return Result.completed();
    } else {
      this._deletedRemovedDocs = true;
      return this._eachCollectionAgent(function(collectionAgent) {
        return collectionAgent.deleteDocumentsGoneFromServer(tx);
      });
    }
  };

  ConnectionAgent.prototype.checkIfReadyToDeleteDocs = function(tx) {
    if (this.allMeteorSubscriptionsReady()) {
      return this.deleteRemovedDocuments(tx);
    }
  };

  ConnectionAgent.prototype._alreadyHaveMeteorSubscription = function(subscription) {
    return !!this.meteorSubscriptionHandles[stringify(subscription)];
  };

  ConnectionAgent.prototype.allMeteorSubscriptionsReady = function() {
    return this._nMeteorSubscriptionsReady === _.size(this.meteorSubscriptionHandles);
  };

  ConnectionAgent.prototype._eachCollectionAgent = function(fn) {
    var collectionAgent, name, results, _ref1;
    results = [];
    _ref1 = this.collectionAgents;
    for (name in _ref1) {
      collectionAgent = _ref1[name];
      results.push(fn(collectionAgent));
    }
    return Result.join(results);
  };

  ConnectionAgent.prototype.instantiateCollectionAgent = function(collectionName) {
    var _base;
    (_base = this.collectionAgents)[collectionName] || (_base[collectionName] = new CollectionAgent(this, collectionName, new Meteor.Collection(collectionName)));
  };

  ConnectionAgent.prototype.instantiateCollectionAgents = function(collectionNames) {
    var collectionName, _i, _len;
    for (_i = 0, _len = collectionNames.length; _i < _len; _i++) {
      collectionName = collectionNames[_i];
      this.instantiateCollectionAgent(collectionName);
    }
  };

  ConnectionAgent.prototype.meteorSubscriptionReady = function(subscription) {
    var _this = this;
    this.instantiateCollectionAgents(_.keys(this.meteorConnection._updatesForUnknownStores));
    return asAgentWindow(function(tx) {
      return database.setSubscriptionServerReady(tx, _this.connectionName, subscription.name, subscription.args).then(function() {
        return broadcastSubscriptionStatus(tx, null, _this.connectionName, subscription.name, subscription.args);
      }).then(function() {
        return updateSubscriptionsReady(tx, null);
      }).then(function() {
        ++_this._nMeteorSubscriptionsReady;
        return _this.checkIfReadyToDeleteDocs(tx);
      }).then(function() {
        return broadcastUpdate();
      });
    });
  };

  ConnectionAgent.prototype.currentSubscriptions = function() {
    return _.map(_.keys(this.meteorSubscriptionHandles), EJSON.parse);
  };

  ConnectionAgent.prototype.oldSubscriptions = function(subscriptions) {
    var _this = this;
    return _.reject(this.currentSubscriptions(), (function(subscription) {
      return contains(subscriptions, subscription);
    }));
  };

  ConnectionAgent.prototype.newSubscriptions = function(subscriptions) {
    var _this = this;
    return _.reject(subscriptions, function(subscription) {
      return _this._alreadyHaveMeteorSubscription(subscription);
    });
  };

  ConnectionAgent.prototype.stopOldSubscriptions = function(tx, trackUpdate, subscriptions) {
    var serialized, subscription, writes, _i, _len, _ref1;
    writes = [];
    _ref1 = this.oldSubscriptions(subscriptions);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      subscription = _ref1[_i];
      serialized = stringify(subscription);
      this.meteorSubscriptionHandles[serialized].stop();
      delete this.meteorSubscriptionHandles[serialized];
      trackUpdate.madeUpdate = true;
      writes.push(database.addUpdate(tx, {
        update: 'subscriptionStatus',
        subscription: {
          connection: this.connectionName,
          name: subscription.name,
          args: subscription.args
        },
        status: {
          status: 'unsubscribed',
          loaded: false
        }
      }));
    }
    return Result.join(writes);
  };

  ConnectionAgent.prototype.subscriptionError = function(subscription, error) {
    var _this = this;
    database.transaction(function(tx) {
      return database.setSubscriptionError(tx, _this.connectionName, subscription.name, subscription.args, error).then(function() {
        return broadcastSubscriptionStatus(tx, null, _this.connectionName, subscription.name, subscription.args);
      });
    }).then(function() {
      return broadcastUpdate();
    });
  };

  ConnectionAgent.prototype.startNewSubscription = function(subscription) {
    var args, handle, name,
      _this = this;
    this._deletedRemovedDocs = false;
    name = subscription.name, args = subscription.args;
    handle = Meteor.subscribe.apply(Meteor, [name].concat(__slice.call(args), [{
      onError: function(err) {
        _this.subscriptionError(subscription, err);
      },
      onReady: function() {
        _this.meteorSubscriptionReady(subscription);
      }
    }]));
    this.meteorSubscriptionHandles[stringify(subscription)] = handle;
  };

  ConnectionAgent.prototype.startNewSubscriptions = function(tx, trackUpdate, subscriptions) {
    var _this = this;
    return Result.map(this.newSubscriptions(subscriptions), (function(subscription) {
      _this.startNewSubscription(subscription);
      return database.ensureSubscription(tx, _this.connectionName, subscription.name, subscription.args).then(function() {
        return database.setSubscriptionStatus(tx, _this.connectionName, subscription.name, subscription.args, 'subscribing');
      }).then(function() {
        return broadcastSubscriptionStatus(tx, trackUpdate, _this.connectionName, subscription.name, subscription.args);
      });
    }));
  };

  ConnectionAgent.prototype.subscribeToSubscriptions = function(tx, trackUpdate, subscriptions) {
    subscriptions = _.map(subscriptions, justNameAndArgs);
    return Result.join([this.stopOldSubscriptions(tx, trackUpdate, subscriptions), this.startNewSubscriptions(tx, trackUpdate, subscriptions)]);
  };

  ConnectionAgent.prototype.checkIfDocumentNowFree = function(tx, collectionName, docId) {
    return this.collectionAgents[collectionName].updateDocFromServerIfFree(tx, docId);
  };

  ConnectionAgent.prototype.methodCompleted = function(methodId) {
    var docsWhichWereWrittenByStub,
      _this = this;
    docsWhichWereWrittenByStub = null;
    asAgentWindow(function(tx) {
      return database.removeQueuedMethod(tx, _this.connectionName, methodId).then(function() {
        return database.readDocsWrittenByStub(tx, this.connectionName, methodId);
      }).then(function(docs) {
        docsWhichWereWrittenByStub = docs;
        return database.removeDocumentsWrittenByStub(tx, _this.connectionName, methodId);
      }).then(function() {
        var collectionName, docId, writes, _i, _len, _ref1;
        writes = [];
        for (_i = 0, _len = docsWhichWereWrittenByStub.length; _i < _len; _i++) {
          _ref1 = docsWhichWereWrittenByStub[_i], collectionName = _ref1.collectionName, docId = _ref1.docId;
          writes.push(_this.checkIfDocumentNowFree(tx, collectionName, docId));
        }
        return Result.join(writes);
      }).then(function() {
        return database.removeMethodHoldingUpSubscriptions(tx, methodId);
      }).then(function() {
        return updateSubscriptionsReady(tx, null);
      });
    }).then(function() {
      return broadcastUpdate();
    });
  };

  ConnectionAgent.prototype.sendQueuedMethod = function(methodId, name, args) {
    var _this = this;
    if (this.methodsSent[methodId]) {
      return;
    }
    this.methodsSent[methodId] = true;
    Meteor.call('/awwx/offline-data/apply', methodId, name, args, function(error, result) {
      if (error) {
        Meteor._debug('offline method error', name, error);
      }
      _this.methodCompleted(methodId);
    });
  };

  return ConnectionAgent;

})();

newConnectionAgent = function(connectionName) {
  var meteorConnection;
  meteorConnection = connectionName === '/' ? Meteor.default_connection : Meteor.connect(connectionName);
  return new ConnectionAgent(connectionName, meteorConnection);
};

connectionAgentFor = function(connectionName) {
  return connectionAgents[connectionName] || (connectionAgents[connectionName] = newConnectionAgent(connectionName));
};

sendQueuedMethodsInTx = function(tx) {
  return database.readQueuedMethods(tx).then(function(methods) {
    var args, connection, methodId, name, _i, _len, _ref1;
    for (_i = 0, _len = methods.length; _i < _len; _i++) {
      _ref1 = methods[_i], connection = _ref1.connection, methodId = _ref1.methodId, name = _ref1.name, args = _ref1.args;
      connectionAgentFor(connection).sendQueuedMethod(methodId, name, args);
    }
  });
};

sendQueuedMethods = function() {
  return asAgentWindow(function(tx) {
    return sendQueuedMethodsInTx(tx);
  });
};

subscribeToSubscriptions = function(tx, trackUpdate) {
  return database.readMergedSubscriptions(tx).then(function(subscriptions) {
    var connectionAgent, connectionName, subscription, writes, _i, _len;
    for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
      subscription = subscriptions[_i];
      connectionAgentFor(subscription.connection);
    }
    writes = [];
    for (connectionName in connectionAgents) {
      connectionAgent = connectionAgents[connectionName];
      writes.push(connectionAgent.subscribeToSubscriptions(tx, trackUpdate, _.filter(subscriptions, function(subscription) {
        return subscription.connection === connectionName;
      })));
    }
    Result.join(writes).then(function() {
      if (trackUpdate.madeUpdate) {
        broadcastUpdate();
      }
    });
  });
};

CollectionAgent = (function() {
  function CollectionAgent(connectionAgent, collectionName, serverCollection) {
    this.connectionAgent = connectionAgent;
    this.collectionName = collectionName;
    this.serverCollection = serverCollection;
    this.connectionName = this.connectionAgent.connectionName;
    this.watchServer();
  }

  CollectionAgent.prototype.offlineDocumentsNotInServerCollection = function(tx) {
    var _this = this;
    return database.readDocIdsOfCollection(tx, this.connectionName, this.collectionName).then(function(docIds) {
      return _.reject(docIds, (function(docId) {
        return _this.serverCollection.findOne(docId);
      }));
    });
  };

  CollectionAgent.prototype.deleteDocUnlessWrittenByStub = function(tx, docId) {
    var _this = this;
    return database.isDocumentWrittenByAnyStub(tx, this.connectionName, this.collectionName, docId).then(function(wasWritten) {
      if (wasWritten) {

      } else {
        return database.deleteDoc(tx, _this.connectionName, _this.collectionName, docId).then(function() {
          return _this.addDocumentUpdate(tx, docId, null);
        });
      }
    });
  };

  CollectionAgent.prototype.deleteDocumentsGoneFromServer = function(tx) {
    var _this = this;
    return this.offlineDocumentsNotInServerCollection(tx).then(function(docIds) {
      var docId, writes, _i, _len;
      writes = [];
      for (_i = 0, _len = docIds.length; _i < _len; _i++) {
        docId = docIds[_i];
        writes.push(_this.deleteDocUnlessWrittenByStub(tx, docId));
      }
      return Result.join(writes);
    });
  };

  CollectionAgent.prototype.addDocumentUpdate = function(tx, docId, doc) {
    return database.addUpdate(tx, {
      update: 'documentUpdated',
      connectionName: this.connectionName,
      collectionName: this.collectionName,
      docId: docId,
      doc: doc
    });
  };

  CollectionAgent.prototype.updateDocIfFree = function(tx, docId, doc) {
    var _this = this;
    return database.isDocumentWrittenByAnyStub(tx, this.connectionName, this.collectionName, docId).then(function(wasWritten) {
      if (wasWritten) {
        return;
      }
      return (doc != null ? database.writeDoc(tx, _this.connectionName, _this.collectionName, doc) : database.deleteDoc(tx, _this.connectionName, _this.collectionName, docId)).then(function() {
        return _this.addDocumentUpdate(tx, docId, doc);
      });
    });
  };

  CollectionAgent.prototype.updateDocFromServerIfFree = function(tx, docId) {
    return this.updateDocIfFree(tx, docId, this.serverCollection.findOne(docId));
  };

  CollectionAgent.prototype.serverDocUpdated = function(docId, doc) {
    var _this = this;
    asAgentWindow(function(tx) {
      return _this.updateDocIfFree(tx, docId, doc);
    }).then(function() {
      return broadcastUpdate();
    });
  };

  CollectionAgent.prototype.watchServer = function() {
    var _this = this;
    this.serverCollection.find().observe({
      added: function(doc) {
        return _this.serverDocUpdated(doc._id, doc);
      },
      changed: function(doc) {
        return _this.serverDocUpdated(doc._id, doc);
      },
      removed: function(doc) {
        return _this.serverDocUpdated(doc._id, null);
      }
    });
  };

  return CollectionAgent;

})();

withUpdateTracking = function(fn) {
  var trackUpdate;
  trackUpdate = {
    madeUpdate: false
  };
  return database.transaction(function(tx) {
    return fn(tx, trackUpdate);
  }).then(function() {
    if (trackUpdate.madeUpdate) {
      broadcastUpdate();
    }
  });
};

windowSubscriptionsUpdated = function() {
  withUpdateTracking(function(tx, trackUpdate) {
    return subscribeToSubscriptions(tx, trackUpdate);
  });
};

initialized = new Result();

cleanSubscriptions = function(tx, trackUpdate) {
  return database.cleanSubscriptions(tx).then(function(deletedSubscriptions) {
    return Result.map(deletedSubscriptions, (function(subscription) {
      trackUpdate.madeUpdate = true;
      return database.addUpdate(tx, {
        update: 'subscriptionStatus',
        subscription: subscription,
        status: {
          status: 'unsubscribed',
          loaded: false
        }
      });
    }));
  });
};

initializeAgent = function() {
  withUpdateTracking(function(tx, trackUpdate) {
    return cleanSubscriptions(tx, trackUpdate).then(function() {
      return database.initializeSubscriptions(tx);
    }).then(function() {
      return database.readSubscriptions(tx);
    }).then(function(subscriptions) {
      return Result.map(subscriptions, (function(subscription) {
        return broadcastStatusOfSubscription(tx, trackUpdate, subscription);
      }));
    }).then(function() {
      return sendQueuedMethodsInTx(tx);
    });
  }).then(function() {
    return initialized.complete();
  });
};

windowsAreDead.listen(function(deadWindowIds) {
  initialized.then(function() {
    var trackUpdate;
    trackUpdate = {
      madeUpdate: false
    };
    asAgentWindow(function(tx) {
      return database.deleteWindows(tx, deadWindowIds).then(function() {
        return cleanSubscriptions(tx, trackUpdate);
      }).then(function() {
        return subscribeToSubscriptions(tx, trackUpdate);
      });
    }).then(function() {
      if (trackUpdate.madeUpdate) {
        return broadcastUpdate();
      }
    });
  });
});

Meteor.startup(function() {
  if (!Offline.isWebWorker && Offline._usingSharedWebWorker) {
    return;
  }
  addMessageHandler('windowSubscriptionsUpdated', function() {
    windowSubscriptionsUpdated();
  });
  addMessageHandler('newQueuedMethod', function() {
    sendQueuedMethods();
  });
  if (Offline.isWebWorker) {
    initializeAgent();
  } else {
    nowAgent.listen(initializeAgent);
  }
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/worker-client.litcoffee.js                                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var Worker, hash, messageHandlers, url, worker, _ref, _ref1, _ref2;

if (Offline.isWebWorker) {
  return;
}

if (!(typeof Offline !== "undefined" && Offline !== null ? Offline.persistent : void 0) || (this.SharedWorker == null) || ((_ref = Meteor.settings) != null ? (_ref1 = _ref["public"]) != null ? (_ref2 = _ref1.offlineData) != null ? _ref2.disableWorker : void 0 : void 0 : void 0) || (this.Tinytest != null)) {
  Offline._usingSharedWebWorker = false;
  return;
}

Offline._usingSharedWebWorker = true;

url = __meteor_runtime_config__.offlineDataWorker.urls['worker-boot.js'];

hash = url.substr(url.lastIndexOf('?') + 1);

worker = new SharedWorker(url, hash);

messageHandlers = {};

Offline._sharedWebWorker = Worker = {};

Worker.addMessageHandler = function(msg, callback) {
  messageHandlers[msg] = callback;
};

Worker.addMessageHandler('log', function(data) {
  var entry, _i, _len, _ref3;
  _ref3 = data.log;
  for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
    entry = _ref3[_i];
    Meteor._debug("worker log: " + entry);
  }
});

worker.port.onmessage = function(event) {
  var handler, _ref3;
  handler = messageHandlers[(_ref3 = event.data) != null ? _ref3.msg : void 0];
  if (handler != null) {
    return handler(event.data);
  } else {
    return Meteor._debug("unknown message received from shared web worker: " + JSON.stringify(event.data));
  }
};

Worker.post = function(data) {
  worker.port.postMessage(_.extend(data, {
    windowId: Offline._windows.thisWindowId
  }));
};

Worker.addMessageHandler('ping', function(data) {
  Worker.post({
    msg: 'pong'
  });
});

Worker.post({
  msg: 'boot',
  __meteor_runtime_config__: __meteor_runtime_config__
});
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/proxy.litcoffee.js                                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var MethodInvocation, OfflineCollection, OfflineConnection, addWindowSubscription, broadcastUpdate, database, debug, defaultOfflineConnection, getLocalCollection, getSubscriptionStatus, localCollections, log, messageAgent, offlineCollections, offlineConnectionFor, offlineConnections, processDocumentUpdated, processUpdate, processUpdates, processUpdatesInTx, setSubscriptionStatus, subscriptionStatus, subscriptionStatusVariable, thisWindowId, updateLocal, _ref, _ref1, _ref2, _ref3,
  __slice = [].slice;

if (Offline.isWebWorker || !Offline.persistent) {
  return;
}

database = Offline._database;

thisWindowId = Offline._windows.thisWindowId;

messageAgent = Offline._messageAgent;

debug = (_ref = Meteor.settings) != null ? (_ref1 = _ref["public"]) != null ? (_ref2 = _ref1.offlineData) != null ? (_ref3 = _ref2.debug) != null ? _ref3.proxy : void 0 : void 0 : void 0 : void 0;

log = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  Meteor._debug.apply(Meteor, ["offline-data proxy:"].concat(__slice.call(args)));
};

if (Offline._usingSharedWebWorker) {
  broadcastUpdate = function() {
    if (debug) {
      log("broadcast update");
    }
    messageAgent('update');
  };
} else {
  broadcastUpdate = function() {
    if (debug) {
      log("broadcast update");
    }
    broadcast('update');
  };
}

subscriptionStatus = {};

subscriptionStatusVariable = function(subscription) {
  var _name;
  return subscriptionStatus[_name = stringify(subscription)] || (subscriptionStatus[_name] = Variable({
    status: 'unsubscribed',
    loaded: false
  }));
};

getSubscriptionStatus = function(subscription) {
  return subscriptionStatusVariable(subscription)();
};

setSubscriptionStatus = function(subscription, status) {
  if (debug) {
    log("set subscription status", stringify(subscription), stringify(status));
  }
  return subscriptionStatusVariable(subscription).set(status);
};

addWindowSubscription = function(connection, name, args) {
  return database.transaction(function(tx) {
    return database.addWindowSubscription(tx, thisWindowId, connection, name, args);
  }).then(function() {
    return messageAgent('windowSubscriptionsUpdated');
  });
};

MethodInvocation = (function() {
  function MethodInvocation(options) {
    this.isSimulation = options.isSimulation;
    this.userId = options.userId;
  }

  MethodInvocation.prototype.setUserId = function(userId) {
    throw new Error("accounts are not yet supported for offline data");
  };

  return MethodInvocation;

})();

offlineConnections = {};

OfflineConnection = (function() {
  function OfflineConnection(connectionName) {
    this.connectionName = connectionName;
    if (offlineConnections[this.connectionName] != null) {
      throw new Error("an OfflineConnection has already been constructed for this connection: " + this.connectionName);
    }
    offlineConnections[this.connectionName] = this;
    this._methodHandlers = {};
    this._offlineCollections = {};
    this._initialized = new Result();
    this._initialize();
  }

  OfflineConnection.prototype._initialize = function() {
    var _this = this;
    return Context.withContext("initialize offline connection " + this.connectionName, function() {
      return Meteor.startup(function() {
        database.transaction(function(tx) {
          return database.readDocs(tx, _this.connectionName);
        }).then(function(connectionDocs) {
          var collectionName, doc, docId, docs;
          for (collectionName in connectionDocs) {
            docs = connectionDocs[collectionName];
            for (docId in docs) {
              doc = docs[docId];
              updateLocal(_this.connectionName, collectionName, docId, doc);
            }
          }
        }).then(function() {
          return _this._initialized.complete();
        });
      });
    });
  };

  OfflineConnection.prototype._addCollection = function(offlineCollection) {
    var name;
    name = offlineCollection._collectionName;
    if (this._offlineCollections[name] != null) {
      throw new Error("already have an offline collection for: " + name);
    }
    this._offlineCollections[name] = offlineCollection;
  };

  OfflineConnection.prototype.registerStore = function(name, wrappedStore) {
    return wrappedStore;
  };

  OfflineConnection.prototype.userId = function() {
    return null;
  };

  OfflineConnection.prototype.setUserId = function(userId) {
    throw new Error('not implemented yet');
  };

  OfflineConnection.prototype.subscriptions = function(subscriptions) {
    var subscription, _i, _len,
      _this = this;
    if (!_.isArray(subscriptions)) {
      throw new Error('`subscriptions` argument should be an array');
    }
    for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
      subscription = subscriptions[_i];
      if (!_.isArray(subscription)) {
        throw new Error('each individual subscription should be an array');
      }
      if (!(subscription.length > 0)) {
        throw new Error('a subscription should include at least the subscription name');
      }
      if (!_.isString(subscription[0])) {
        throw new Error('the subscription name should be a string');
      }
    }
    return database.transaction(function(tx) {
      return database.setWindowSubscriptions(tx, thisWindowId, _this.connectionName, subscriptions);
    }).then(function() {
      return messageAgent('windowSubscriptionsUpdated');
    });
  };

  OfflineConnection.prototype.subscriptionStatus = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return getSubscriptionStatus({
      connection: this.connectionName,
      name: name,
      args: args
    });
  };

  OfflineConnection.prototype.subscriptionLoaded = function() {
    var args, name,
      _this = this;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return isolateValue(function() {
      return _this.subscriptionStatus.apply(_this, [name].concat(__slice.call(args))).loaded;
    });
  };

  OfflineConnection.prototype.methods = function(methods) {
    var _this = this;
    _.each(methods, function(func, name) {
      if (_this._methodHandlers[name]) {
        throw new Error("A method named '" + name + "' is already defined");
      }
      return _this._methodHandlers[name] = func;
    });
  };

  OfflineConnection.prototype._saveOriginals = function() {
    var name, offlineCollection, _ref4;
    _ref4 = this._offlineCollections;
    for (name in _ref4) {
      offlineCollection = _ref4[name];
      offlineCollection._saveOriginals();
    }
  };

  OfflineConnection.prototype._writeChanges = function(tx, methodId) {
    var name, offlineCollection, writes, _ref4;
    writes = [];
    _ref4 = this._offlineCollections;
    for (name in _ref4) {
      offlineCollection = _ref4[name];
      writes.push(offlineCollection._writeMethodChanges(tx, methodId));
    }
    return Result.join(writes);
  };

  OfflineConnection.prototype._runStub = function(methodId, alreadyInSimulation, name, args) {
    var e, exception, invocation, ret, stub,
      _this = this;
    stub = this._methodHandlers[name];
    if (!stub) {
      return;
    }
    invocation = new MethodInvocation({
      isSimulation: true,
      userId: this.userId(),
      setUserId: function(userId) {
        return _this.setUserId(userId);
      }
    });
    if (alreadyInSimulation) {
      try {
        ret = DDP._CurrentInvocation.withValue(invocation, function() {
          return stub.apply(invocation, EJSON.clone(args));
        });
      } catch (_error) {
        e = _error;
        exception = e;
      }
      if (exception) {
        return Result.failed(exception);
      } else {
        return Result.completed(ret);
      }
    }
    return database.transaction(function(tx) {
      return processUpdatesInTx(tx).then(function() {
        _this._saveOriginals();
        try {
          ret = DDP._CurrentInvocation.withValue(invocation, function() {
            return stub.apply(invocation, EJSON.clone(args));
          });
        } catch (_error) {
          e = _error;
          exception = e;
        }
        return _this._writeChanges(tx, methodId);
      });
    }).then(function() {
      broadcastUpdate();
      if (exception) {
        return Result.failed(exception);
      } else {
        return Result.completed(ret);
      }
    });
  };

  OfflineConnection.prototype.call = function() {
    var args, callback, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (args.length && typeof args[args.length - 1] === 'function') {
      callback = args.pop();
    }
    return this.apply(name, args, callback);
  };

  OfflineConnection.prototype.apply = function(name, args, options, callback) {
    var alreadyInSimulation, enclosing, methodId,
      _this = this;
    if (!callback && typeof options === 'function') {
      callback = options;
      options = {};
    }
    if (callback) {
      callback = Meteor.bindEnvironment(callback, function(e) {
        return Meteor._debug("Exception while delivering result of invoking '" + name + "'", e, e != null ? e.stack : void 0);
      });
    }
    methodId = Random.id();
    enclosing = DDP._CurrentInvocation.get();
    alreadyInSimulation = enclosing && enclosing.isSimulation;
    this._runStub(methodId, alreadyInSimulation, name, args).onFailure(function(exception) {
      if (!exception.expected) {
        Meteor._debug("Exception while simulating the effect of invoking '" + name + "'", exception, exception != null ? exception.stack : void 0);
      }
    }).always(function() {
      if (alreadyInSimulation) {
        return;
      }
      return database.transaction(function(tx) {
        return database.addQueuedMethod(tx, _this.connectionName, methodId, name, args);
      }).then(function() {
        messageAgent('newQueuedMethod');
      });
    });
  };

  return OfflineConnection;

})();

offlineConnectionFor = function(connectionName) {
  return offlineConnections[connectionName] || new OfflineConnection(connectionName);
};

Offline._defaultOfflineConnection = defaultOfflineConnection = new OfflineConnection('/');

Offline.subscriptions = function(subscriptions) {
  return defaultOfflineConnection.subscriptions(subscriptions);
};

Offline.subscriptionStatus = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return defaultOfflineConnection.subscriptionStatus.apply(defaultOfflineConnection, [name].concat(__slice.call(args)));
};

Offline.subscriptionLoaded = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return defaultOfflineConnection.subscriptionLoaded.apply(defaultOfflineConnection, [name].concat(__slice.call(args)));
};

Offline.methods = function(methods) {
  return defaultOfflineConnection.methods(methods);
};

Offline._localCollections = localCollections = {};

getLocalCollection = function(connectionName, collectionName) {
  var _base;
  return (_base = (localCollections[connectionName] || (localCollections[connectionName] = {})))[collectionName] || (_base[collectionName] = new LocalCollection());
};

updateLocal = function(connectionName, collectionName, docId, doc) {
  var localCollection;
  localCollection = getLocalCollection(connectionName, collectionName);
  if (doc != null) {
    if (doc._id !== docId) {
      throw new Error("oops, document id doesn't match");
    }
    if (localCollection.findOne(docId) != null) {
      localCollection.update(docId, doc);
    } else {
      localCollection.insert(doc);
    }
  } else {
    localCollection.remove(docId);
  }
};

offlineCollections = {};

OfflineCollection = (function() {
  function OfflineCollection(_collectionName, options) {
    var driver, offlineConnection, _ref4,
      _this = this;
    this._collectionName = _collectionName;
    if (options == null) {
      options = {};
    }
    this._connectionName = (_ref4 = options.connectionName) != null ? _ref4 : '/';
    offlineConnection = offlineConnectionFor(this._connectionName);
    offlineConnection._addCollection(this);
    this._localCollection = getLocalCollection(this._connectionName, this._collectionName);
    driver = {
      open: function(_name) {
        if (_name !== _this._collectionName) {
          throw new Error("oops, driver is being called with the wrong name                 for this collection: " + _name);
        }
        return _this._localCollection;
      }
    };
    this._collection = new Meteor.Collection(this._collectionName, {
      connection: offlineConnection,
      _driver: driver
    });
  }

  OfflineCollection.prototype.find = function() {
    var args, _ref4;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref4 = this._localCollection).find.apply(_ref4, args);
  };

  OfflineCollection.prototype.findOne = function() {
    var args, _ref4;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref4 = this._localCollection).findOne.apply(_ref4, args);
  };

  OfflineCollection.prototype._saveOriginals = function() {
    return this._localCollection.saveOriginals();
  };

  OfflineCollection.prototype._writeDoc = function(tx, docId) {
    var doc;
    doc = this._localCollection.findOne(docId);
    if (doc != null) {
      return database.writeDoc(tx, this._connectionName, this._collectionName, doc);
    } else {
      return database.deleteDoc(tx, this._connectionName, this._collectionName, docId);
    }
  };

  OfflineCollection.prototype._writeMethodChanges = function(tx, methodId) {
    var docId, originals, writes;
    originals = this._localCollection.retrieveOriginals();
    writes = [];
    for (docId in originals) {
      writes.push(this._writeDoc(tx, docId));
      writes.push(database.addDocumentWrittenByStub(tx, this._connectionName, methodId, this._collectionName, docId));
      writes.push(database.addUpdate(tx, {
        update: 'documentUpdated',
        connectionName: this._connectionName,
        collectionName: this._collectionName,
        docId: docId,
        doc: this._localCollection.findOne(docId)
      }));
    }
    return Result.join(writes);
  };

  OfflineCollection.prototype.insert = function(doc, callback) {
    if (callback != null) {
      Meteor._debug("Warning: the insert `callback` argument will not called for an Offline collection");
    }
    return this._collection.insert(doc);
  };

  OfflineCollection.prototype.update = function(selector, modifier, options, callback) {
    if (typeof options === 'function' || typeof callback === 'function') {
      Meteor._debug("Warning: the update `callback` argument will not called for an Offline collection");
    }
    if (typeof options === 'function') {
      options = void 0;
    }
    return this._collection.update(selector, modifier, options);
  };

  OfflineCollection.prototype.remove = function(selector, callback) {
    if (callback != null) {
      Meteor._debug("Warning: the remove `callback` argument will not called for an Offline collection");
    }
    return this._collection.remove(selector);
  };

  return OfflineCollection;

})();

processDocumentUpdated = function(update) {
  var collectionName, connectionName, doc, docId;
  connectionName = update.connectionName, collectionName = update.collectionName, docId = update.docId, doc = update.doc;
  updateLocal(connectionName, collectionName, docId, doc);
};

processUpdate = function(update) {
  if (debug) {
    log("process update", stringify(update));
  }
  switch (update.update) {
    case 'documentUpdated':
      processDocumentUpdated(update);
      break;
    case 'subscriptionStatus':
      setSubscriptionStatus(update.subscription, update.status);
      break;
    default:
      throw new Error("unknown update: " + stringify(update));
  }
};

processUpdatesInTx = function(tx) {
  return database.pullUpdatesForWindow(tx, thisWindowId).then(function(updates) {
    return database.removeUpdatesProcessedByAllWindows(tx).then(function() {
      var update, _i, _len;
      for (_i = 0, _len = updates.length; _i < _len; _i++) {
        update = updates[_i];
        processUpdate(update);
      }
    });
  });
};

processUpdates = function() {
  database.transaction(function(tx) {
    return processUpdatesInTx(tx);
  });
};

Meteor.startup(function() {
  return database.transaction(function(tx) {
    return database.readSubscriptions(tx);
  }).then(function(subscriptions) {
    var subscription, _i, _len;
    if (debug) {
      log("startup subscriptions", stringify(subscriptions));
    }
    for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
      subscription = subscriptions[_i];
      setSubscriptionStatus(_.pick(subscription, ['connection', 'name', 'args']), Offline._subscriptionStatus(subscription));
    }
  });
});

Offline.Collection = OfflineCollection;

if (Offline._usingSharedWebWorker) {
  Offline._sharedWebWorker.addMessageHandler('update', function(data) {
    processUpdates();
  });
} else {
  broadcast.listen('update', function() {
    processUpdates();
  });
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/offline-data/fallback.litcoffee.js                                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;
var OfflineConnection, currentSubscriptions, defaultOfflineConnection, offlineConnections, subscriptionKey,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

if (Offline.persistent) {
  return;
}

subscriptionKey = function(subscription) {
  return stringify(subscription);
};

currentSubscriptions = {};

Offline.subscriptions = function(subscriptions) {
  var args, name, subscription, _i, _j, _len, _len1, _ref;
  subscriptions = _.map(subscriptions, (function(subscriptionArray) {
    return stringify({
      name: subscriptionArray[0],
      args: subscriptionArray.slice(1)
    });
  }));
  for (_i = 0, _len = currentSubscriptions.length; _i < _len; _i++) {
    subscription = currentSubscriptions[_i];
    if (__indexOf.call(subscriptions, subscription) < 0) {
      subscription.stop();
      delete currentSubscriptions[subscription];
    }
  }
  for (_j = 0, _len1 = subscriptions.length; _j < _len1; _j++) {
    subscription = subscriptions[_j];
    if (!currentSubscriptions[subscription]) {
      _ref = EJSON.parse(subscription), name = _ref.name, args = _ref.args;
      currentSubscriptions[subscription] = Meteor.subscribe.apply(Meteor, [name].concat(__slice.call(args)));
    }
  }
};

Offline.Collection = Meteor.Collection;

Offline.subscriptionLoaded = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
};

offlineConnections = {};

OfflineConnection = (function() {
  function OfflineConnection(connectionName, meteorConnection) {
    this.connectionName = connectionName;
    this.meteorConnection = meteorConnection;
    if (offlineConnections[this.connectionName] != null) {
      throw new Error("an OfflineConnection has already been constructed for this connection: " + this.connectionName);
    }
    offlineConnections[this.connectionName] = this;
    this.currentSubscriptions = {};
    this.subscriptionStatusVariables = {};
  }

  OfflineConnection.prototype.subscriptions = function(subscriptions) {
    var handle, key, subscription, subscriptionKeys, _fn, _i, _j, _len, _len1, _ref,
      _this = this;
    if (!_.isArray(subscriptions)) {
      throw new Error('`subscriptions` argument should be an array');
    }
    for (_i = 0, _len = subscriptions.length; _i < _len; _i++) {
      subscription = subscriptions[_i];
      if (!_.isArray(subscription)) {
        throw new Error('each individual subscription should be an array');
      }
      if (!(subscription.length > 0)) {
        throw new Error('a subscription should include at least the subscription name');
      }
      if (!_.isString(subscription[0])) {
        throw new Error('the subscription name should be a string');
      }
      subscriptions = _.map(subscriptions, function(array) {
        return {
          name: array[0],
          args: array.slice(1)
        };
      });
      subscriptionKeys = _.map(subscriptions, subscriptionKey);
      _ref = this.currentSubscriptions;
      for (key in _ref) {
        handle = _ref[key];
        if (__indexOf.call(subscriptionKeys, key) < 0) {
          handle.stop();
          delete this.currentSubscriptions[key];
          this.setSubscriptionStatus(EJSON.parse(key), {
            status: 'stopped',
            loaded: false
          });
        }
      }
      _fn = function(subscription) {
        var _ref1;
        key = subscriptionKey(subscription);
        if (!_this.currentSubscriptions[key]) {
          return _this.currentSubscriptions[key] = (_ref1 = _this.meteorConnection).subscribe.apply(_ref1, [subscription.name].concat(__slice.call(subscription.args), [{
            onError: function(err) {
              _this.setSubscriptionStatus(subscription, {
                status: 'error',
                loaded: false,
                error: err
              });
            },
            onReady: function() {
              return _this.setSubscriptionStatus(subscription, {
                status: 'ready',
                loaded: true
              });
            }
          }]));
        }
      };
      for (_j = 0, _len1 = subscriptions.length; _j < _len1; _j++) {
        subscription = subscriptions[_j];
        _fn(subscription);
      }
      return;
    }
  };

  OfflineConnection.prototype.subscriptionStatusVariable = function(subscription) {
    var _base, _name;
    return (_base = this.subscriptionStatusVariables)[_name = stringify(subscription)] || (_base[_name] = Variable({
      status: 'unsubscribed',
      loaded: false
    }));
  };

  OfflineConnection.prototype.subscriptionStatus = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return this.subscriptionStatusVariable({
      name: name,
      args: args
    })();
  };

  OfflineConnection.prototype.setSubscriptionStatus = function(subscription, status) {
    return this.subscriptionStatusVariable(subscription).set(status);
  };

  OfflineConnection.prototype.subscriptionLoaded = function() {
    var args, name,
      _this = this;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return isolateValue(function() {
      return _this.subscriptionStatus.apply(_this, [name].concat(__slice.call(args))).loaded;
    });
  };

  OfflineConnection.prototype.call = function() {
    var args, _ref;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this.meteorConnection).call.apply(_ref, args);
  };

  return OfflineConnection;

})();

Offline._defaultOfflineConnection = defaultOfflineConnection = new OfflineConnection('/', Meteor.connection);

Offline.subscriptions = function(subscriptions) {
  return defaultOfflineConnection.subscriptions(subscriptions);
};

Offline.subscriptionStatus = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return defaultOfflineConnection.subscriptionStatus.apply(defaultOfflineConnection, [name].concat(__slice.call(args)));
};

Offline.subscriptionLoaded = function() {
  var args, name;
  name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return defaultOfflineConnection.subscriptionLoaded.apply(defaultOfflineConnection, [name].concat(__slice.call(args)));
};

Offline.methods = function(methods) {
  return defaultOfflineConnection.methods(methods);
};

Offline.call = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return defaultOfflineConnection.call.apply(defaultOfflineConnection, args);
};

Offline.resetDatabase = function() {};
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['offline-data'] = {
  Context: Context,
  Errors: Errors,
  Fanout: Fanout,
  Result: Result,
  contains: contains,
  Offline: Offline,
  broadcast: broadcast
};

})();

//# sourceMappingURL=a923ead5a815e5ea77aa9c63e3d9373c08bb77e0.map
